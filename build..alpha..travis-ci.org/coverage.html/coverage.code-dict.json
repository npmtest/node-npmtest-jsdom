{"/home/travis/build/npmtest/node-npmtest-jsdom/test.js":"/* istanbul instrument in package npmtest_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdom/lib.npmtest_jsdom.js":"/* istanbul instrument in package npmtest_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jsdom = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jsdom = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdom/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jsdom && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jsdom\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jsdom.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_jsdom.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jsdom.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_jsdom.__dirname +\n                    '/lib.npmtest_jsdom.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom.js":"\"use strict\";\n/* eslint-disable no-unused-expressions */\n() => `jsdom 7.x onward only works on Node.js 4 or newer: https://github.com/tmpvar/jsdom#install`;\n/* eslint-enable no-unused-expressions */\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst CookieJar = require(\"tough-cookie\").CookieJar;\nconst parseContentType = require(\"content-type-parser\");\n\nconst toFileUrl = require(\"./jsdom/utils\").toFileUrl;\nconst documentFeatures = require(\"./jsdom/browser/documentfeatures\");\nconst domToHtml = require(\"./jsdom/browser/domtohtml\").domToHtml;\nconst Window = require(\"./jsdom/browser/Window\");\nconst resourceLoader = require(\"./jsdom/browser/resource-loader\");\nconst VirtualConsole = require(\"./jsdom/virtual-console\");\nconst locationInfo = require(\"./jsdom/living/helpers/internal-constants\").locationInfo;\nconst idlUtils = require(\"./jsdom/living/generated/utils\");\nconst Blob = require(\"./jsdom/living/generated/Blob\");\n\nconst whatwgURL = require(\"whatwg-url\");\n\nrequire(\"./jsdom/living\"); // Enable living standard features\n\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\nconst URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\nconst canReadFilesFromFS = Boolean(fs.readFile); // in a browserify environment, this isn't present\n\nexports.createVirtualConsole = function (options) {\n  return new VirtualConsole(options);\n};\n\nexports.getVirtualConsole = function (window) {\n  return window._virtualConsole;\n};\n\nexports.createCookieJar = function () {\n  return new CookieJar(null, { looseMode: true });\n};\n\nexports.nodeLocation = function (node) {\n  return idlUtils.implForWrapper(node)[locationInfo];\n};\n\nexports.reconfigureWindow = function (window, newProps) {\n  if (\"top\" in newProps) {\n    window._top = newProps.top;\n  }\n};\n\nexports.changeURL = function (window, urlString) {\n  const doc = idlUtils.implForWrapper(window._document);\n\n  const url = whatwgURL.parseURL(urlString);\n\n  if (url === \"failure\") {\n    throw new TypeError(`Could not parse \"${urlString}\" as a URL`);\n  }\n\n  doc._URL = url;\n  doc._origin = whatwgURL.serializeURLToUnicodeOrigin(doc._URL);\n};\n\n// Proxy to features module\nObject.defineProperty(exports, \"defaultDocumentFeatures\", {\n  enumerable: true,\n  configurable: true,\n  get() {\n    return documentFeatures.defaultDocumentFeatures;\n  },\n  set(v) {\n    documentFeatures.defaultDocumentFeatures = v;\n  }\n});\n\nexports.jsdom = function (html, options) {\n  if (options === undefined) {\n    options = {};\n  }\n  if (options.parsingMode === undefined || options.parsingMode === \"auto\") {\n    options.parsingMode = \"html\";\n  }\n\n  if (options.parsingMode !== \"html\" && options.parsingMode !== \"xml\") {\n    throw new RangeError(`Invalid parsingMode option ${JSON.stringify(options.parsingMode)}; must be either \"html\", ` +\n      `\"xml\", \"auto\", or undefined`);\n  }\n\n  options.encoding = options.encoding || \"UTF-8\";\n\n  setGlobalDefaultConfig(options);\n\n  // Back-compat hack: we have previously suggested nesting these under document, for jsdom.env at least.\n  // So we need to support that.\n  if (options.document) {\n    if (options.document.cookie !== undefined) {\n      options.cookie = options.document.cookie;\n    }\n    if (options.document.referrer !== undefined) {\n      options.referrer = options.document.referrer;\n    }\n  }\n\n  // List options explicitly to be clear which are passed through\n  const window = new Window({\n    parsingMode: options.parsingMode,\n    contentType: options.contentType,\n    encoding: options.encoding,\n    parser: options.parser,\n    url: options.url,\n    lastModified: options.lastModified,\n    referrer: options.referrer,\n    cookieJar: options.cookieJar,\n    cookie: options.cookie,\n    resourceLoader: options.resourceLoader,\n    deferClose: options.deferClose,\n    concurrentNodeIterators: options.concurrentNodeIterators,\n    virtualConsole: options.virtualConsole,\n    pool: options.pool,\n    agent: options.agent,\n    agentClass: options.agentClass,\n    agentOptions: options.agentOptions,\n    strictSSL: options.strictSSL,\n    proxy: options.proxy,\n    userAgent: options.userAgent\n  });\n\n  const documentImpl = idlUtils.implForWrapper(window.document);\n  documentFeatures.applyDocumentFeatures(documentImpl, options.features);\n\n  if (options.created) {\n    options.created(null, window.document.defaultView);\n  }\n\n  if (options.parsingMode === \"html\") {\n    if (html === undefined || html === \"\") {\n      html = \"<html><head></head><body></body></html>\";\n    }\n\n    window.document.write(html);\n  } else if (options.parsingMode === \"xml\") {\n    if (html !== undefined) {\n      documentImpl._htmlToDom.appendHtmlToDocument(html, documentImpl);\n    }\n  }\n\n  if (window.document.close && !options.deferClose) {\n    window.document.close();\n  }\n\n  return window.document;\n};\n\nexports.jQueryify = exports.jsdom.jQueryify = function (window, jqueryUrl, callback) {\n  if (!window || !window.document) {\n    return;\n  }\n\n  const implImpl = idlUtils.implForWrapper(window.document.implementation);\n  const features = implImpl._features;\n  implImpl._addFeature(\"FetchExternalResources\", [\"script\"]);\n  implImpl._addFeature(\"ProcessExternalResources\", [\"script\"]);\n\n  const scriptEl = window.document.createElement(\"script\");\n  scriptEl.className = \"jsdom\";\n  scriptEl.src = jqueryUrl;\n  scriptEl.onload = scriptEl.onerror = () => {\n    implImpl._features = features;\n\n    if (callback) {\n      callback(window, window.jQuery);\n    }\n  };\n\n  window.document.body.appendChild(scriptEl);\n};\n\nexports.env = exports.jsdom.env = function () {\n  const config = getConfigFromArguments(arguments);\n  let req = null;\n\n  if (config.file && canReadFilesFromFS) {\n    req = resourceLoader.readFile(config.file,\n    { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },\n    (err, text, res) => {\n      if (err) {\n        reportInitError(err, config);\n        return;\n      }\n\n      const contentType = parseContentType(res.headers[\"content-type\"]);\n      config.encoding = contentType.get(\"charset\");\n      setParsingModeFromExtension(config, config.file);\n\n      config.html = text;\n      processHTML(config);\n    });\n  } else if (config.html !== undefined) {\n    processHTML(config);\n  } else if (config.url) {\n    req = handleUrl(config);\n  } else if (config.somethingToAutodetect !== undefined) {\n    const url = URL.parse(config.somethingToAutodetect);\n    if (url.protocol && url.hostname) {\n      config.url = config.somethingToAutodetect;\n      req = handleUrl(config.somethingToAutodetect);\n    } else if (canReadFilesFromFS) {\n      req = resourceLoader.readFile(config.somethingToAutodetect,\n      { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },\n      (err, text, res) => {\n        if (err) {\n          if (err.code === \"ENOENT\" || err.code === \"ENAMETOOLONG\") {\n            config.html = config.somethingToAutodetect;\n            processHTML(config);\n          } else {\n            reportInitError(err, config);\n          }\n        } else {\n          const contentType = parseContentType(res.headers[\"content-type\"]);\n          config.encoding = contentType.get(\"charset\");\n          setParsingModeFromExtension(config, config.somethingToAutodetect);\n\n          config.html = text;\n          config.url = toFileUrl(config.somethingToAutodetect);\n          processHTML(config);\n        }\n      });\n    } else {\n      config.html = config.somethingToAutodetect;\n      processHTML(config);\n    }\n  }\n\n  function handleUrl() {\n    config.cookieJar = config.cookieJar || exports.createCookieJar();\n\n    const options = {\n      defaultEncoding: config.defaultEncoding,\n      detectMetaCharset: true,\n      headers: config.headers,\n      pool: config.pool,\n      strictSSL: config.strictSSL,\n      proxy: config.proxy,\n      cookieJar: config.cookieJar,\n      userAgent: config.userAgent,\n      agent: config.agent,\n      agentClass: config.agentClass,\n      agentOptions: config.agentOptions\n    };\n\n    const fragment = whatwgURL.parseURL(config.url).fragment;\n\n    return resourceLoader.download(config.url, options, (err, responseText, res) => {\n      if (err) {\n        reportInitError(err, config);\n        return;\n      }\n\n      // The use of `res.request.uri.href` ensures that `window.location.href`\n      // is updated when `request` follows redirects.\n      config.html = responseText;\n      config.url = res.request.uri.href;\n      if (fragment) {\n        config.url += `#${fragment}`;\n      }\n\n      if (res.headers[\"last-modified\"]) {\n        config.lastModified = new Date(res.headers[\"last-modified\"]);\n      }\n\n      const contentType = parseContentType(res.headers[\"content-type\"]);\n      if (config.parsingMode === \"auto\") {\n        if (contentType.isXML()) {\n          config.parsingMode = \"xml\";\n        }\n      }\n      config.encoding = contentType.get(\"charset\");\n\n      processHTML(config);\n    });\n  }\n  return req;\n};\n\nexports.serializeDocument = function (doc) {\n  return domToHtml([doc]);\n};\n\nexports.blobToBuffer = function (blob) {\n  return Blob.is(blob) && idlUtils.implForWrapper(blob)._buffer || undefined;\n};\n\nexports.evalVMScript = (window, script) => {\n  return script.runInContext(idlUtils.implForWrapper(window._document)._global);\n};\n\nfunction processHTML(config) {\n  const window = exports.jsdom(config.html, config).defaultView;\n  const implImpl = idlUtils.implForWrapper(window.document.implementation);\n  const features = JSON.parse(JSON.stringify(implImpl._features));\n\n  let docsLoaded = 0;\n  const totalDocs = config.scripts.length + config.src.length;\n\n  if (!window || !window.document) {\n    reportInitError(new Error(\"JSDOM: a window object could not be created.\"), config);\n    return;\n  }\n\n  function scriptComplete() {\n    docsLoaded++;\n\n    if (docsLoaded >= totalDocs) {\n      implImpl._features = features;\n\n      process.nextTick(() => {\n        if (config.onload) {\n          config.onload(window);\n        }\n        if (config.done) {\n          config.done(null, window);\n        }\n      });\n    }\n  }\n\n  function handleScriptError() {\n    // nextTick so that an exception within scriptComplete won't cause\n    // another script onerror (which would be an infinite loop)\n    process.nextTick(scriptComplete);\n  }\n\n  if (config.scripts.length > 0 || config.src.length > 0) {\n    implImpl._addFeature(\"FetchExternalResources\", [\"script\"]);\n    implImpl._addFeature(\"ProcessExternalResources\", [\"script\"]);\n\n    for (const scriptSrc of config.scripts) {\n      const script = window.document.createElement(\"script\");\n      script.className = \"jsdom\";\n      script.onload = scriptComplete;\n      script.onerror = handleScriptError;\n      script.src = scriptSrc;\n\n      window.document.body.appendChild(script);\n    }\n\n    for (const scriptText of config.src) {\n      const script = window.document.createElement(\"script\");\n      script.onload = scriptComplete;\n      script.onerror = handleScriptError;\n      script.text = scriptText;\n\n      window.document.documentElement.appendChild(script);\n      window.document.documentElement.removeChild(script);\n    }\n  } else if (window.document.readyState === \"complete\") {\n    scriptComplete();\n  } else {\n    window.addEventListener(\"load\", scriptComplete);\n  }\n}\n\nfunction setGlobalDefaultConfig(config) {\n  config.pool = config.pool !== undefined ? config.pool : {\n    maxSockets: 6\n  };\n\n  config.agentOptions = config.agentOptions !== undefined ? config.agentOptions : {\n    keepAlive: true,\n    keepAliveMsecs: 115 * 1000\n  };\n\n  config.strictSSL = config.strictSSL !== undefined ? config.strictSSL : true;\n\n  config.userAgent = config.userAgent ||\n    `Node.js (${process.platform}; U; rv:${process.version}) AppleWebKit/537.36 (KHTML, like Gecko)`;\n}\n\nfunction getConfigFromArguments(args) {\n  const config = {};\n  if (typeof args[0] === \"object\") {\n    Object.assign(config, args[0]);\n  } else {\n    for (const arg of args) {\n      switch (typeof arg) {\n        case \"string\":\n          config.somethingToAutodetect = arg;\n          break;\n        case \"function\":\n          config.done = arg;\n          break;\n        case \"object\":\n          if (Array.isArray(arg)) {\n            config.scripts = arg;\n          } else {\n            Object.assign(config, arg);\n          }\n          break;\n      }\n    }\n  }\n\n  if (!config.done && !config.created && !config.onload) {\n    throw new Error(\"Must pass a \\\"created\\\", \\\"onload\\\", or \\\"done\\\" option, or a callback, to jsdom.env\");\n  }\n\n  if (config.somethingToAutodetect === undefined &&\n      config.html === undefined && !config.file && !config.url) {\n    throw new Error(\"Must pass a \\\"html\\\", \\\"file\\\", or \\\"url\\\" option, or a string, to jsdom.env\");\n  }\n\n  config.scripts = ensureArray(config.scripts);\n  config.src = ensureArray(config.src);\n  config.parsingMode = config.parsingMode || \"auto\";\n\n  config.features = config.features || {\n    FetchExternalResources: false,\n    ProcessExternalResources: false,\n    SkipExternalResources: false\n  };\n\n  if (!config.url && config.file) {\n    config.url = toFileUrl(config.file);\n  }\n\n  config.defaultEncoding = config.defaultEncoding || \"windows-1252\";\n\n  setGlobalDefaultConfig(config);\n\n  return config;\n}\n\nfunction reportInitError(err, config) {\n  if (config.created) {\n    config.created(err);\n  }\n  if (config.done) {\n    config.done(err);\n  }\n}\n\nfunction ensureArray(value) {\n  let array = value || [];\n  if (typeof array === \"string\") {\n    array = [array];\n  }\n  return array;\n}\n\nfunction setParsingModeFromExtension(config, filename) {\n  if (config.parsingMode === \"auto\") {\n    const ext = path.extname(filename);\n    if (ext === \".xhtml\" || ext === \".xml\") {\n      config.parsingMode = \"xml\";\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/utils.js":"\"use strict\";\nconst path = require(\"path\");\nconst whatwgURL = require(\"whatwg-url\");\nconst querystring = require(\"querystring\");\nconst domSymbolTree = require(\"./living/helpers/internal-constants\").domSymbolTree;\nconst SYMBOL_TREE_POSITION = require(\"symbol-tree\").TreePosition;\nconst parseURLToResultingURLRecord = require(\"./living/helpers/document-base-url\").parseURLToResultingURLRecord;\n\nexports.toFileUrl = function (fileName) {\n  // Beyond just the `path.resolve`, this is mostly for the benefit of Windows,\n  // where we need to convert \"\\\" to \"/\" and add an extra \"/\" prefix before the\n  // drive letter.\n  let pathname = path.resolve(process.cwd(), fileName).replace(/\\\\/g, \"/\");\n  if (pathname[0] !== \"/\") {\n    pathname = \"/\" + pathname;\n  }\n\n  // path might contain spaces, so convert those to %20\n  return \"file://\" + encodeURI(pathname);\n};\n\n/**\n * Define a getter on an object\n *\n * This method replaces any existing getter but leaves setters in place.\n *\n * - `object` {Object} the object to define the getter on\n * - `property` {String} the name of the getter\n * - `getterFn` {Function} the getter\n */\nexports.defineGetter = function defineGetter(object, property, getterFn) {\n  const descriptor = Object.getOwnPropertyDescriptor(object, property) || {\n    configurable: true,\n    enumerable: true\n  };\n\n  descriptor.get = getterFn;\n\n  Object.defineProperty(object, property, descriptor);\n};\n\n/**\n * Define a set of properties on an object, by copying the property descriptors\n * from the original object.\n *\n * - `object` {Object} the target object\n * - `properties` {Object} the source from which to copy property descriptors\n */\nexports.define = function define(object, properties) {\n  for (const name of Object.getOwnPropertyNames(properties)) {\n    const propDesc = Object.getOwnPropertyDescriptor(properties, name);\n    Object.defineProperty(object, name, propDesc);\n  }\n};\n\n/**\n * Define a list of constants on a constructor and its .prototype\n *\n * - `Constructor` {Function} the constructor to define the constants on\n * - `propertyMap` {Object}  key/value map of properties to define\n */\nexports.addConstants = function addConstants(Constructor, propertyMap) {\n  for (const property in propertyMap) {\n    const value = propertyMap[property];\n    addConstant(Constructor, property, value);\n    addConstant(Constructor.prototype, property, value);\n  }\n};\n\nfunction addConstant(object, property, value) {\n  Object.defineProperty(object, property, {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value\n  });\n}\n\nlet memoizeQueryTypeCounter = 0;\n\n/**\n * Returns a version of a method that memoizes specific types of calls on the object\n *\n * - `fn` {Function} the method to be memozied\n */\nexports.memoizeQuery = function memoizeQuery(fn) {\n  // Only memoize query functions with arity <= 2\n  if (fn.length > 2) {\n    return fn;\n  }\n\n  const type = memoizeQueryTypeCounter++;\n\n  return function () {\n    if (!this._memoizedQueries) {\n      return fn.apply(this, arguments);\n    }\n\n    if (!this._memoizedQueries[type]) {\n      this._memoizedQueries[type] = Object.create(null);\n    }\n\n    let key;\n    if (arguments.length === 1 && typeof arguments[0] === \"string\") {\n      key = arguments[0];\n    } else if (arguments.length === 2 && typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n      key = arguments[0] + \"::\" + arguments[1];\n    } else {\n      return fn.apply(this, arguments);\n    }\n\n    if (!(key in this._memoizedQueries[type])) {\n      this._memoizedQueries[type][key] = fn.apply(this, arguments);\n    }\n    return this._memoizedQueries[type][key];\n  };\n};\n\nexports.reflectURLAttribute = (elementImpl, contentAttributeName) => {\n  const attributeValue = elementImpl.getAttribute(contentAttributeName);\n  if (attributeValue === null || attributeValue === \"\") {\n    return \"\";\n  }\n\n  const urlRecord = parseURLToResultingURLRecord(attributeValue, elementImpl._ownerDocument);\n  if (urlRecord === \"failure\") {\n    return attributeValue;\n  }\n  return whatwgURL.serializeURL(urlRecord);\n};\n\nfunction isValidAbsoluteURL(str) {\n  return whatwgURL.parseURL(str) !== \"failure\";\n}\n\nexports.isValidTargetOrigin = function (str) {\n  return str === \"*\" || str === \"/\" || isValidAbsoluteURL(str);\n};\n\nexports.simultaneousIterators = function* (first, second) {\n  for (;;) {\n    const firstResult = first.next();\n    const secondResult = second.next();\n\n    if (firstResult.done && secondResult.done) {\n      return;\n    }\n\n    yield [\n      firstResult.done ? null : firstResult.value,\n      secondResult.done ? null : secondResult.value\n    ];\n  }\n};\n\nexports.treeOrderSorter = function (a, b) {\n  const compare = domSymbolTree.compareTreePosition(a, b);\n\n  if (compare & SYMBOL_TREE_POSITION.PRECEDING) { // b is preceding a\n    return 1;\n  }\n\n  if (compare & SYMBOL_TREE_POSITION.FOLLOWING) {\n    return -1;\n  }\n\n  // disconnected or equal:\n  return 0;\n};\n\nexports.lengthFromProperties = function (arrayLike) {\n  let max = -1;\n  const keys = Object.keys(arrayLike);\n  const highestKeyIndex = keys.length - 1;\n\n  // Abuses a v8 implementation detail for a very fast case\n  // (if this implementation detail changes, this method will still\n  //  return correct results)\n  /* eslint-disable eqeqeq */\n  if (highestKeyIndex == keys[highestKeyIndex]) { // not ===\n    /* eslint-enable eqeqeq */\n    return keys.length;\n  }\n\n  for (let i = highestKeyIndex; i >= 0; --i) {\n    const asNumber = Number(keys[i]);\n\n    if (!Number.isNaN(asNumber) && asNumber > max) {\n      max = asNumber;\n    }\n  }\n  return max + 1;\n};\n\nconst base64Regexp = /^(?:[A-Z0-9+/]{4})*(?:[A-Z0-9+/]{2}==|[A-Z0-9+/]{3}=|[A-Z0-9+/]{4})$/i;\n\nexports.parseDataUrl = function parseDataUrl(url) {\n  const urlParts = url.match(/^data:(.+?)(?:;(base64))?,(.*)$/);\n  let buffer;\n  if (urlParts[2] === \"base64\") {\n    if (urlParts[3] && !base64Regexp.test(urlParts[3])) {\n      throw new Error(\"Not a base64 string\");\n    }\n    buffer = new Buffer(urlParts[3], \"base64\");\n  } else {\n    buffer = new Buffer(querystring.unescape(urlParts[3]));\n  }\n  return { buffer, type: urlParts[1] };\n};\n\n/* eslint-disable global-require */\n\nexports.Canvas = null;\n[\"canvas\", \"canvas-prebuilt\"].some(moduleName => {\n  try {\n    exports.Canvas = require(moduleName);\n    if (typeof exports.Canvas !== \"function\") {\n      // In browserify, the require will succeed but return an empty object\n      exports.Canvas = null;\n    }\n  } catch (e) {\n    exports.Canvas = null;\n  }\n  return exports.Canvas !== null;\n});\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/internal-constants.js":"\"use strict\";\nconst SymbolTree = require(\"symbol-tree\");\n\nexports.cloningSteps = Symbol(\"cloning steps\");\nexports.locationInfo = Symbol(\"location info\");\n\n// TODO: the many underscore-prefixed hooks should move here\n// E.g. _attrModified (which maybe should be split into its per-spec variants)\n\n/**\n * This SymbolTree is used to build the tree for all Node in a document\n */\nexports.domSymbolTree = new SymbolTree(\"DOM SymbolTree\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/document-base-url.js":"\"use strict\";\nconst internalQuerySelector = require(\"./selectors\").querySelector;\nconst whatwgURL = require(\"whatwg-url\");\n\nexports.documentBaseURL = document => {\n  // https://html.spec.whatwg.org/multipage/infrastructure.html#document-base-url\n\n  const firstBase = internalQuerySelector(document, \"base[href]\");\n  const fallbackBaseURL = exports.fallbackBaseURL(document);\n\n  if (firstBase === null) {\n    return fallbackBaseURL;\n  }\n\n  return frozenBaseURL(firstBase, fallbackBaseURL);\n};\n\nexports.documentBaseURLSerialized = document => {\n  return whatwgURL.serializeURL(exports.documentBaseURL(document));\n};\n\nexports.fallbackBaseURL = document => {\n  // https://html.spec.whatwg.org/multipage/infrastructure.html#fallback-base-url\n\n  // Unimplemented: <iframe srcdoc>\n\n  if (document.URL === \"about:blank\" && document._defaultView &&\n      document._defaultView._parent !== document._defaultView) {\n    return exports.documentBaseURL(document._defaultView._parent._document);\n  }\n\n  return document._URL;\n};\n\nexports.parseURLToResultingURLRecord = (url, document) => {\n  // https://html.spec.whatwg.org/#resolve-a-url\n\n  // Encoding stuff ignored; always UTF-8 for us, for now.\n\n  const baseURL = exports.documentBaseURL(document);\n\n  return whatwgURL.parseURL(url, { baseURL });\n  // This returns the resulting URL record; to get the resulting URL string, just serialize it.\n};\n\nfunction frozenBaseURL(baseElement, fallbackBaseURL) {\n  // https://html.spec.whatwg.org/multipage/semantics.html#frozen-base-url\n  // The spec is eager (setting the frozen base URL when things change); we are lazy (getting it when we need to)\n\n  const baseHrefAttribute = baseElement.getAttribute(\"href\");\n  const result = whatwgURL.parseURL(baseHrefAttribute, { baseURL: fallbackBaseURL });\n  return result === \"failure\" ? fallbackBaseURL : result;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/selectors.js":"\"use strict\";\n\nconst idlUtils = require(\"../generated/utils\");\nconst nwmatcher = require(\"nwmatcher/src/nwmatcher-noqsa\");\nconst domSymbolTree = require(\"./internal-constants\").domSymbolTree;\n\n// Internal method so you don't have to go through the public API\nexports.querySelector = function (parentNode, selectors) {\n  if (!domSymbolTree.hasChildren(parentNode) ||\n      (parentNode === parentNode._ownerDocument && !parentNode.documentElement)) {\n    // This allows us to avoid the explosion that occurs if you try to add nwmatcher to a document that is not yet\n    // initialized.\n    return null;\n  }\n\n  return addNwmatcher(parentNode).first(selectors, idlUtils.wrapperForImpl(parentNode));\n};\n\n// nwmatcher gets `document.documentElement` at creation-time, so we have to initialize lazily, since in the initial\n// stages of Document initialization, there is no documentElement present yet.\nfunction addNwmatcher(parentNode) {\n  const document = parentNode._ownerDocument;\n\n  if (!document._nwmatcher) {\n    document._nwmatcher = nwmatcher({ document });\n    document._nwmatcher.configure({ UNIQUE_ID: false });\n  }\n\n  return document._nwmatcher;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/utils.js":"\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nconst wrapperSymbol = Symbol(\"wrapper\");\nconst implSymbol = Symbol(\"impl\");\n\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n};\n\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n};\n\nfunction tryWrapperForImpl(impl) {\n  const wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n};\n\nfunction tryImplForWrapper(wrapper) {\n  const impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n};\n\nconst iterInternalSymbol = Symbol(\"internal\");\nconst IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\nmodule.exports.wrapperSymbol = wrapperSymbol;\nmodule.exports.implSymbol = implSymbol;\nmodule.exports.wrapperForImpl = wrapperForImpl;\nmodule.exports.implForWrapper = implForWrapper;\nmodule.exports.tryWrapperForImpl = tryWrapperForImpl;\nmodule.exports.tryImplForWrapper = tryImplForWrapper;\nmodule.exports.iterInternalSymbol = iterInternalSymbol;\nmodule.exports.IteratorPrototype = IteratorPrototype;\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/browser/documentfeatures.js":"\"use strict\";\n\nexports.availableDocumentFeatures = [\n  \"FetchExternalResources\",\n  \"ProcessExternalResources\",\n  \"SkipExternalResources\"\n];\n\nexports.defaultDocumentFeatures = {\n  FetchExternalResources: [\"script\", \"link\"], // omitted by default: \"frame\"\n  ProcessExternalResources: [\"script\"], // omitted by default: \"frame\", \"iframe\"\n  SkipExternalResources: false\n};\n\nexports.applyDocumentFeatures = (documentImpl, features) => {\n  features = features || {};\n\n  for (let i = 0; i < exports.availableDocumentFeatures.length; ++i) {\n    const featureName = exports.availableDocumentFeatures[i];\n    let featureSource;\n\n    if (features[featureName] !== undefined) {\n      featureSource = features[featureName];\n      // We have to check the lowercase version also because the Document feature\n      // methods convert everything to lowercase.\n    } else if (typeof features[featureName.toLowerCase()] !== \"undefined\") {\n      featureSource = features[featureName.toLowerCase()];\n    } else if (exports.defaultDocumentFeatures[featureName]) {\n      featureSource = exports.defaultDocumentFeatures[featureName];\n    } else {\n      continue;\n    }\n\n    const implImpl = documentImpl._implementation;\n    implImpl._removeFeature(featureName);\n\n    if (featureSource !== undefined) {\n      if (Array.isArray(featureSource)) {\n        for (let j = 0; j < featureSource.length; ++j) {\n          implImpl._addFeature(featureName, featureSource[j]);\n        }\n      } else {\n        implImpl._addFeature(featureName, featureSource);\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/browser/domtohtml.js":"\"use strict\";\nconst parse5 = require(\"parse5\");\nconst documentAdapter = require(\"./documentAdapter\");\nconst NODE_TYPE = require(\"../living/node-type\");\nconst idlUtils = require(\"../living/generated/utils\");\n\nconst serializer = new parse5.TreeSerializer(documentAdapter);\n\nexports.domToHtml = function (iterable) {\n  let ret = \"\";\n  for (const node of iterable) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      ret += serializer.serialize(node);\n    } else {\n      ret += serializer.serialize({ childNodes: [idlUtils.wrapperForImpl(node)] });\n    }\n  }\n  return ret;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/browser/documentAdapter.js":"\"use strict\";\n\nconst idlUtils = require(\"../living/generated/utils\");\n\n// Tree traversing\nexports.getFirstChild = function (node) {\n  return node.childNodes[0];\n};\n\nexports.getChildNodes = function (node) {\n  // parse5 treats template elements specially, assuming you return an array whose single item is the document fragment\n  const children = node._templateContents ? [node._templateContents] : [];\n  if (children.length === 0) {\n    for (let i = 0; i < node.childNodes.length; ++i) {\n      children.push(idlUtils.implForWrapper(node.childNodes[i]));\n    }\n  }\n  return children;\n};\n\nexports.getParentNode = function (node) {\n  return node.parentNode;\n};\n\nexports.getAttrList = function (node) {\n  return node.attributes;\n};\n\n// Node data\nexports.getTagName = function (element) {\n  return element.tagName.toLowerCase();\n};\n\nexports.getNamespaceURI = function (element) {\n  return element.namespaceURI || \"http://www.w3.org/1999/xhtml\";\n};\n\nexports.getTextNodeContent = function (textNode) {\n  return textNode.nodeValue;\n};\n\nexports.getCommentNodeContent = function (commentNode) {\n  return commentNode.nodeValue;\n};\n\nexports.getDocumentTypeNodeName = function (doctypeNode) {\n  return doctypeNode.name;\n};\n\nexports.getDocumentTypeNodePublicId = function (doctypeNode) {\n  return doctypeNode.publicId || null;\n};\n\nexports.getDocumentTypeNodeSystemId = function (doctypeNode) {\n  return doctypeNode.systemId || null;\n};\n\n// Node types\nexports.isTextNode = function (node) {\n  return node.nodeName === \"#text\";\n};\n\nexports.isCommentNode = function (node) {\n  return node.nodeName === \"#comment\";\n};\n\nexports.isDocumentTypeNode = function (node) {\n  return node.nodeType === 10;\n};\n\nexports.isElementNode = function (node) {\n  return Boolean(node.tagName);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/node-type.js":"\"use strict\";\n\nmodule.exports = Object.freeze({\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2, // historical\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4, // historical\n  ENTITY_REFERENCE_NODE: 5, // historical\n  ENTITY_NODE: 6, // historical\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n  NOTATION_NODE: 12 // historical\n});\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/browser/Window.js":"\"use strict\";\n\nconst webIDLConversions = require(\"webidl-conversions\");\nconst CSSStyleDeclaration = require(\"cssstyle\").CSSStyleDeclaration;\nconst notImplemented = require(\"./not-implemented\");\nconst VirtualConsole = require(\"../virtual-console\");\nconst define = require(\"../utils\").define;\nconst EventTarget = require(\"../living/generated/EventTarget\");\nconst namedPropertiesWindow = require(\"../living/named-properties-window\");\nconst cssom = require(\"cssom\");\nconst postMessage = require(\"../living/post-message\");\nconst DOMException = require(\"../web-idl/DOMException\");\nconst btoa = require(\"abab\").btoa;\nconst atob = require(\"abab\").atob;\nconst idlUtils = require(\"../living/generated/utils\");\nconst createXMLHttpRequest = require(\"../living/xmlhttprequest\");\nconst createFileReader = require(\"../living/generated/FileReader\").createInterface;\nconst Document = require(\"../living/generated/Document\");\nconst Navigator = require(\"../living/generated/Navigator\");\nconst reportException = require(\"../living/helpers/runtime-script-errors\");\n\n// NB: the require() must be after assigning `module.exports` because this require() is circular\n// TODO: this above note might not even be true anymore... figure out the cycle and document it, or clean up.\nmodule.exports = Window;\nconst dom = require(\"../living\");\n\nconst cssSelectorSplitRE = /((?:[^,\"']|\"[^\"]*\"|'[^']*')+)/;\n\nconst defaultStyleSheet = cssom.parse(require(\"./default-stylesheet\"));\n\ndom.Window = Window;\n\n// NOTE: per https://heycam.github.io/webidl/#Global, all properties on the Window object must be own-properties.\n// That is why we assign everything inside of the constructor, instead of using a shared prototype.\n// You can verify this in e.g. Firefox or Internet Explorer, which do a good job with Web IDL compliance.\n\nfunction Window(options) {\n  EventTarget.setup(this);\n\n  const window = this;\n\n  ///// INTERFACES FROM THE DOM\n  // TODO: consider a mode of some sort where these are not shared between all DOM instances\n  // It'd be very memory-expensive in most cases, though.\n  for (const name in dom) {\n    Object.defineProperty(window, name, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: dom[name]\n    });\n  }\n  this._core = dom;\n\n  ///// PRIVATE DATA PROPERTIES\n\n  // vm initialization is defered until script processing is activated (in level1/core)\n  this._globalProxy = this;\n\n  this.__timers = Object.create(null);\n\n  // Set up the window as if it's a top level window.\n  // If it's not, then references will be corrected by frame/iframe code.\n  this._parent = this._top = this._globalProxy;\n  this._frameElement = null;\n\n  // List options explicitly to be clear which are passed through\n  this._document = Document.create([], {\n    core: dom,\n    options: {\n      parsingMode: options.parsingMode,\n      contentType: options.contentType,\n      encoding: options.encoding,\n      cookieJar: options.cookieJar,\n      parser: options.parser,\n      url: options.url,\n      lastModified: options.lastModified,\n      referrer: options.referrer,\n      cookie: options.cookie,\n      deferClose: options.deferClose,\n      resourceLoader: options.resourceLoader,\n      concurrentNodeIterators: options.concurrentNodeIterators,\n      pool: options.pool,\n      agent: options.agent,\n      agentClass: options.agentClass,\n      agentOptions: options.agentOptions,\n      strictSSL: options.strictSSL,\n      proxy: options.proxy,\n      defaultView: this._globalProxy,\n      global: this\n    }\n  });\n  // https://html.spec.whatwg.org/#session-history\n  this._sessionHistory = [{\n    document: idlUtils.implForWrapper(this._document),\n    url: idlUtils.implForWrapper(this._document)._URL,\n    stateObject: null\n  }];\n  this._currentSessionHistoryEntryIndex = 0;\n\n\n  // This implements window.frames.length, since window.frames returns a\n  // self reference to the window object.  This value is incremented in the\n  // HTMLFrameElement init function (see: level2/html.js).\n  this._length = 0;\n\n  if (options.virtualConsole) {\n    if (options.virtualConsole instanceof VirtualConsole) {\n      this._virtualConsole = options.virtualConsole;\n    } else {\n      throw new TypeError(\n        \"options.virtualConsole must be a VirtualConsole (from createVirtualConsole)\");\n    }\n  } else {\n    this._virtualConsole = new VirtualConsole();\n  }\n\n  ///// GETTERS\n\n  const navigator = Navigator.create([], { userAgent: options.userAgent });\n\n  define(this, {\n    get length() {\n      return window._length;\n    },\n    get window() {\n      return window._globalProxy;\n    },\n    get frameElement() {\n      return window._frameElement;\n    },\n    get frames() {\n      return window._globalProxy;\n    },\n    get self() {\n      return window._globalProxy;\n    },\n    get parent() {\n      return window._parent;\n    },\n    get top() {\n      return window._top;\n    },\n    get document() {\n      return window._document;\n    },\n    get location() {\n      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._location);\n    },\n    get history() {\n      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._history);\n    },\n    get navigator() {\n      return navigator;\n    }\n  });\n\n  namedPropertiesWindow.initializeWindow(this, dom.HTMLCollection);\n\n  ///// METHODS for [ImplicitThis] hack\n  // See https://lists.w3.org/Archives/Public/public-script-coord/2015JanMar/0109.html\n  this.addEventListener = this.addEventListener.bind(this);\n  this.removeEventListener = this.removeEventListener.bind(this);\n  this.dispatchEvent = this.dispatchEvent.bind(this);\n\n  ///// METHODS\n\n  let latestTimerId = 0;\n\n  this.setTimeout = function (fn, ms) {\n    const args = [];\n    for (let i = 2; i < arguments.length; ++i) {\n      args[i - 2] = arguments[i];\n    }\n    return startTimer(window, setTimeout, clearTimeout, ++latestTimerId, fn, ms, args);\n  };\n  this.setInterval = function (fn, ms) {\n    const args = [];\n    for (let i = 2; i < arguments.length; ++i) {\n      args[i - 2] = arguments[i];\n    }\n    return startTimer(window, setInterval, clearInterval, ++latestTimerId, fn, ms, args);\n  };\n  this.clearInterval = stopTimer.bind(this, window);\n  this.clearTimeout = stopTimer.bind(this, window);\n  this.__stopAllTimers = stopAllTimers.bind(this, window);\n\n  function Option(text, value, defaultSelected, selected) {\n    if (text === undefined) {\n      text = \"\";\n    }\n    text = webIDLConversions.DOMString(text);\n\n    if (value !== undefined) {\n      value = webIDLConversions.DOMString(value);\n    }\n\n    defaultSelected = webIDLConversions.boolean(defaultSelected);\n    selected = webIDLConversions.boolean(selected);\n\n    const option = window._document.createElement(\"option\");\n    const impl = idlUtils.implForWrapper(option);\n\n    if (text !== \"\") {\n      impl.text = text;\n    }\n    if (value !== undefined) {\n      impl.setAttribute(\"value\", value);\n    }\n    if (defaultSelected) {\n      impl.setAttribute(\"selected\", \"\");\n    }\n    impl._selectedness = selected;\n\n    return option;\n  }\n  Object.defineProperty(Option, \"prototype\", {\n    value: this.HTMLOptionElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Option\", {\n    value: Option,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function Image() {\n    const img = window._document.createElement(\"img\");\n    const impl = idlUtils.implForWrapper(img);\n\n    if (arguments.length > 0) {\n      impl.setAttribute(\"width\", String(arguments[0]));\n    }\n    if (arguments.length > 1) {\n      impl.setAttribute(\"height\", String(arguments[1]));\n    }\n\n    return img;\n  }\n  Object.defineProperty(Image, \"prototype\", {\n    value: this.HTMLImageElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Image\", {\n    value: Image,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function Audio(src) {\n    const audio = window._document.createElement(\"audio\");\n    const impl = idlUtils.implForWrapper(audio);\n    impl.setAttribute(\"preload\", \"auto\");\n\n    if (src !== undefined) {\n      impl.setAttribute(\"src\", String(src));\n    }\n\n    return audio;\n  }\n  Object.defineProperty(Audio, \"prototype\", {\n    value: this.HTMLAudioElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Audio\", {\n    value: Audio,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function wrapConsoleMethod(method) {\n    return function () {\n      const args = Array.prototype.slice.call(arguments);\n      window._virtualConsole.emit.apply(window._virtualConsole, [method].concat(args));\n    };\n  }\n\n  this.postMessage = postMessage;\n\n  this.atob = function (str) {\n    const result = atob(str);\n    if (result === null) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n        \"The string to be decoded contains invalid characters.\");\n    }\n    return result;\n  };\n\n  this.btoa = function (str) {\n    const result = btoa(str);\n    if (result === null) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n        \"The string to be encoded contains invalid characters.\");\n    }\n    return result;\n  };\n\n  this.FileReader = createFileReader({\n    window: this\n  }).interface;\n\n  this.XMLHttpRequest = createXMLHttpRequest(this);\n\n  // TODO: necessary for Blob and FileReader due to different-globals weirdness; investigate how to avoid this.\n  this.ArrayBuffer = ArrayBuffer;\n  this.Int8Array = Int8Array;\n  this.Uint8Array = Uint8Array;\n  this.Uint8ClampedArray = Uint8ClampedArray;\n  this.Int16Array = Int16Array;\n  this.Uint16Array = Uint16Array;\n  this.Int32Array = Int32Array;\n  this.Uint32Array = Uint32Array;\n  this.Float32Array = Float32Array;\n  this.Float64Array = Float64Array;\n\n  this.stop = function () {\n    const manager = idlUtils.implForWrapper(this._document)._requestManager;\n    if (manager) {\n      manager.close();\n    }\n  };\n\n  this.close = function () {\n    // Recursively close child frame windows, then ourselves.\n    const currentWindow = this;\n    (function windowCleaner(windowToClean) {\n      for (let i = 0; i < windowToClean.length; i++) {\n        windowCleaner(windowToClean[i]);\n      }\n\n      // We\"re already in our own window.close().\n      if (windowToClean !== currentWindow) {\n        windowToClean.close();\n      }\n    }(this));\n\n    // Clear out all listeners. Any in-flight or upcoming events should not get delivered.\n    idlUtils.implForWrapper(this)._eventListeners = Object.create(null);\n\n    if (this._document) {\n      if (this._document.body) {\n        this._document.body.innerHTML = \"\";\n      }\n\n      if (this._document.close) {\n        // It's especially important to clear out the listeners here because document.close() causes a \"load\" event to\n        // fire.\n        idlUtils.implForWrapper(this._document)._eventListeners = Object.create(null);\n        this._document.close();\n      }\n      const doc = idlUtils.implForWrapper(this._document);\n      if (doc._requestManager) {\n        doc._requestManager.close();\n      }\n      delete this._document;\n    }\n\n    stopAllTimers(currentWindow);\n  };\n\n  this.getComputedStyle = function (node) {\n    const s = node.style;\n    const cs = new CSSStyleDeclaration();\n    const forEach = Array.prototype.forEach;\n\n    function setPropertiesFromRule(rule) {\n      if (!rule.selectorText) {\n        return;\n      }\n\n      const selectors = rule.selectorText.split(cssSelectorSplitRE);\n      let matched = false;\n      for (const selectorText of selectors) {\n        if (selectorText !== \"\" && selectorText !== \",\" && !matched && matchesDontThrow(node, selectorText)) {\n          matched = true;\n          forEach.call(rule.style, property => {\n            cs.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));\n          });\n        }\n      }\n    }\n\n    function readStylesFromStyleSheet(sheet) {\n      forEach.call(sheet.cssRules, rule => {\n        if (rule.media) {\n          if (Array.prototype.indexOf.call(rule.media, \"screen\") !== -1) {\n            forEach.call(rule.cssRules, setPropertiesFromRule);\n          }\n        } else {\n          setPropertiesFromRule(rule);\n        }\n      });\n    }\n\n    readStylesFromStyleSheet(defaultStyleSheet);\n    forEach.call(node.ownerDocument.styleSheets, readStylesFromStyleSheet);\n\n    forEach.call(s, property => {\n      cs.setProperty(property, s.getPropertyValue(property), s.getPropertyPriority(property));\n    });\n\n    return cs;\n  };\n\n  ///// PUBLIC DATA PROPERTIES (TODO: should be getters)\n\n  this.console = {\n    assert: wrapConsoleMethod(\"assert\"),\n    clear: wrapConsoleMethod(\"clear\"),\n    count: wrapConsoleMethod(\"count\"),\n    debug: wrapConsoleMethod(\"debug\"),\n    error: wrapConsoleMethod(\"error\"),\n    group: wrapConsoleMethod(\"group\"),\n    groupCollapsed: wrapConsoleMethod(\"groupCollapsed\"),\n    groupEnd: wrapConsoleMethod(\"groupEnd\"),\n    info: wrapConsoleMethod(\"info\"),\n    log: wrapConsoleMethod(\"log\"),\n    table: wrapConsoleMethod(\"table\"),\n    time: wrapConsoleMethod(\"time\"),\n    timeEnd: wrapConsoleMethod(\"timeEnd\"),\n    trace: wrapConsoleMethod(\"trace\"),\n    warn: wrapConsoleMethod(\"warn\")\n  };\n\n  function notImplementedMethod(name) {\n    return function () {\n      notImplemented(name, window);\n    };\n  }\n\n  define(this, {\n    name: \"nodejs\",\n    innerWidth: 1024,\n    innerHeight: 768,\n    outerWidth: 1024,\n    outerHeight: 768,\n    pageXOffset: 0,\n    pageYOffset: 0,\n    screenX: 0,\n    screenY: 0,\n    screenLeft: 0,\n    screenTop: 0,\n    scrollX: 0,\n    scrollY: 0,\n    scrollTop: 0,\n    scrollLeft: 0,\n    screen: {\n      width: 0,\n      height: 0\n    },\n\n    alert: notImplementedMethod(\"window.alert\"),\n    blur: notImplementedMethod(\"window.blur\"),\n    confirm: notImplementedMethod(\"window.confirm\"),\n    createPopup: notImplementedMethod(\"window.createPopup\"),\n    focus: notImplementedMethod(\"window.focus\"),\n    moveBy: notImplementedMethod(\"window.moveBy\"),\n    moveTo: notImplementedMethod(\"window.moveTo\"),\n    open: notImplementedMethod(\"window.open\"),\n    print: notImplementedMethod(\"window.print\"),\n    prompt: notImplementedMethod(\"window.prompt\"),\n    resizeBy: notImplementedMethod(\"window.resizeBy\"),\n    resizeTo: notImplementedMethod(\"window.resizeTo\"),\n    scroll: notImplementedMethod(\"window.scroll\"),\n    scrollBy: notImplementedMethod(\"window.scrollBy\"),\n    scrollTo: notImplementedMethod(\"window.scrollTo\"),\n\n    toString: () => {\n      return \"[object Window]\";\n    }\n  });\n\n  ///// INITIALIZATION\n\n  process.nextTick(() => {\n    if (!window.document) {\n      return; // window might've been closed already\n    }\n\n    if (window.document.readyState === \"complete\") {\n      const ev = window.document.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"load\", false, false);\n      window.dispatchEvent(ev);\n    } else {\n      window.document.addEventListener(\"load\", () => {\n        const ev = window.document.createEvent(\"HTMLEvents\");\n        ev.initEvent(\"load\", false, false);\n        window.dispatchEvent(ev);\n      });\n    }\n  });\n}\n\nObject.setPrototypeOf(Window, EventTarget.interface);\nObject.setPrototypeOf(Window.prototype, EventTarget.interface.prototype);\n\nfunction matchesDontThrow(el, selector) {\n  try {\n    return el.matches(selector);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction startTimer(window, startFn, stopFn, timerId, callback, ms, args) {\n  if (typeof callback !== \"function\") {\n    const code = String(callback);\n    callback = window._globalProxy.eval.bind(window, code + `\\n//# sourceURL=${window.location.href}`);\n  }\n\n  const oldCallback = callback;\n  callback = () => {\n    try {\n      oldCallback.apply(window._globalProxy, args);\n    } catch (e) {\n      reportException(window, e, window.location.href);\n    }\n  };\n\n  const res = startFn(callback, ms);\n  window.__timers[timerId] = [res, stopFn];\n  return timerId;\n}\n\nfunction stopTimer(window, id) {\n  const timer = window.__timers[id];\n  if (timer) {\n    // Need to .call() with undefined to ensure the thisArg is not timer itself\n    timer[1].call(undefined, timer[0]);\n    delete window.__timers[id];\n  }\n}\n\nfunction stopAllTimers(window) {\n  Object.keys(window.__timers).forEach(key => {\n    const timer = window.__timers[key];\n    // Need to .call() with undefined to ensure the thisArg is not timer itself\n    timer[1].call(undefined, timer[0]);\n  });\n  window.__timers = Object.create(null);\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/browser/not-implemented.js":"\"use strict\";\n\nmodule.exports = function (nameForErrorMessage, window) {\n  if (!window) {\n    // Do nothing for window-less documents.\n    return;\n  }\n\n  const error = new Error(`Not implemented: ${nameForErrorMessage}`);\n  error.type = \"not implemented\";\n\n  window._virtualConsole.emit(\"jsdomError\", error);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/virtual-console.js":"\"use strict\";\nconst EventEmitter = require(\"events\").EventEmitter;\n\nmodule.exports = class VirtualConsole extends EventEmitter {\n  constructor() {\n    super();\n\n    this.on(\"error\", () => {\n      // If \"error\" event has no listeners,\n      // EventEmitter throws an exception\n    });\n  }\n\n  sendTo(anyConsole, options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    for (const method of Object.keys(anyConsole)) {\n      if (typeof anyConsole[method] === \"function\") {\n        function onMethodCall() {\n          anyConsole[method].apply(anyConsole, arguments);\n        }\n        this.on(method, onMethodCall);\n      }\n    }\n\n    if (!options.omitJsdomErrors) {\n      this.on(\"jsdomError\", e => anyConsole.error(e.stack, e.detail));\n    }\n\n    return this;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/EventTarget.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction EventTarget() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nEventTarget.prototype.addEventListener = function addEventListener(type, callback) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  if (args[1] === null || args[1] === undefined) {\n    args[1] = null;\n  } else {\n  }\n  return this[impl].addEventListener.apply(this[impl], args);\n};\n\nEventTarget.prototype.removeEventListener = function removeEventListener(type, callback) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'removeEventListener' on 'EventTarget': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  if (args[1] === null || args[1] === undefined) {\n    args[1] = null;\n  } else {\n  }\n  return this[impl].removeEventListener.apply(this[impl], args);\n};\n\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'dispatchEvent' on 'EventTarget': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].dispatchEvent.apply(this[impl], args);\n};\n\nEventTarget.prototype.toString = function () {\n  if (this === EventTarget.prototype) {\n    return \"[object EventTargetPrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(EventTarget.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(EventTarget.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: EventTarget,\n  expose: {\n    Window: { EventTarget: EventTarget },\n    Worker: { EventTarget: EventTarget }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/EventTarget-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/EventTarget-impl.js":"\"use strict\";\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst idlUtils = require(\"../generated/utils\");\n\nconst EventImpl = require(\"./Event-impl\").implementation;\nconst Event = require(\"../generated/Event\").interface;\n\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (!(eventImpl instanceof EventImpl)) {\n      throw new TypeError(\"Argument to dispatchEvent must be an Event\");\n    }\n\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR, \"Tried to dispatch an uninitialized event\");\n    }\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR, \"Tried to dispatch a dispatching event\");\n    }\n\n    eventImpl.isTrusted = false;\n\n    return this._dispatch(eventImpl);\n  }\n\n  _dispatch(eventImpl, targetOverride) {\n    eventImpl._dispatchFlag = true;\n    eventImpl.target = targetOverride || this;\n\n    const eventPath = [];\n    let targetParent = domSymbolTree.parent(eventImpl.target);\n    let target = eventImpl.target;\n    while (targetParent) {\n      eventPath.push(targetParent);\n      target = targetParent;\n      targetParent = domSymbolTree.parent(targetParent);\n    }\n    if (eventImpl.type !== \"load\" && target._defaultView) {\n      // https://html.spec.whatwg.org/#events-and-the-window-object\n      eventPath.push(idlUtils.implForWrapper(target._defaultView));\n    }\n\n    eventImpl.eventPhase = Event.CAPTURING_PHASE;\n    for (let i = eventPath.length - 1; i >= 0; --i) {\n      if (eventImpl._stopPropagationFlag) {\n        break;\n      }\n\n      const object = eventPath[i];\n      const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n      const eventListeners = objectImpl._eventListeners[eventImpl.type];\n      invokeEventListeners(eventListeners, object, eventImpl);\n    }\n\n    eventImpl.eventPhase = Event.AT_TARGET;\n\n    if (!eventImpl._stopPropagationFlag) {\n      invokeInlineListeners(eventImpl.target, eventImpl);\n\n      if (this._eventListeners[eventImpl.type]) {\n        const eventListeners = this._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, eventImpl.target, eventImpl);\n      }\n    }\n\n    if (eventImpl.bubbles) {\n      eventImpl.eventPhase = Event.BUBBLING_PHASE;\n      for (let i = 0; i < eventPath.length; ++i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n\n        const object = eventPath[i];\n        const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n        const eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeInlineListeners(object, eventImpl);\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n    }\n\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n    eventImpl.eventPhase = Event.NONE;\n    eventImpl.currentTarget = null;\n    return !eventImpl._canceledFlag;\n  }\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\nfunction invokeInlineListeners(object, event) {\n  const wrapper = idlUtils.wrapperForImpl(object);\n  const inlineListener = getListenerForInlineEventHandler(wrapper, event.type);\n  if (inlineListener) {\n    const document = object._ownerDocument || (wrapper && (wrapper._document || wrapper._ownerDocument));\n\n    // Will be falsy for windows that have closed\n    if (document && (!object.nodeName || document.implementation._hasFeature(\"ProcessExternalResources\", \"script\"))) {\n      invokeEventListeners([{\n        callback: inlineListener,\n        options: normalizeEventHandlerOptions(false, [\"capture\", \"once\"])\n      }], object, event);\n    }\n  }\n}\n\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  const wrapper = idlUtils.wrapperForImpl(target);\n  const document = target._ownerDocument || (wrapper && (wrapper._document || wrapper._ownerDocument));\n  // Will be falsy for windows that have closed\n  if (!document) {\n    return;\n  }\n\n  // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n  if (wrapper._document) {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n  eventImpl.currentTarget = target;\n  if (!listeners) {\n    return;\n  }\n\n  const handlers = listeners.slice();\n  for (let i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n\n    const listener = handlers[i];\n    const capture = listener.options.capture;\n    const once = listener.options.once;\n    // const passive = listener.options.passive;\n\n    if (listeners.indexOf(listener) === -1 ||\n        (eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture) ||\n        (eventImpl.eventPhase === Event.BUBBLING_PHASE && capture)) {\n      continue;\n    }\n\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n  }\n}\n\nconst wrappedListener = Symbol(\"inline event listener wrapper\");\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}\n\nfunction getListenerForInlineEventHandler(target, type) {\n  const callback = target[\"on\" + type];\n\n  if (!callback) { // TODO event handlers: only check null\n    return null;\n  }\n\n  if (!callback[wrappedListener]) {\n    // https://html.spec.whatwg.org/multipage/webappapis.html#the-event-handler-processing-algorithm\n    callback[wrappedListener] = function (E) {\n      const isWindowError = E.constructor.name === \"ErrorEvent\" && type === \"error\"; // TODO branding\n\n      let returnValue;\n      if (isWindowError) {\n        returnValue = callback.call(E.currentTarget, E.message, E.filename, E.lineno, E.colno, E.error);\n      } else {\n        returnValue = callback.call(E.currentTarget, E);\n      }\n\n      if (type === \"mouseover\" || isWindowError) {\n        if (returnValue === true) {\n          E.preventDefault();\n        }\n      } else if (returnValue === false) {\n        E.preventDefault();\n      }\n    };\n  }\n\n  return callback[wrappedListener];\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/web-idl/DOMException.js":"\"use strict\";\nconst addConstants = require(\"../utils\").addConstants;\nconst table = require(\"./dom-exception-table.json\"); // https://heycam.github.io/webidl/#idl-DOMException-error-names\n\n// Precompute some stuff. Mostly unnecessary once we take care of the TODO below.\nconst namesWithCodes = Object.keys(table).filter(name => \"legacyCodeValue\" in table[name]);\n\nconst codesToNames = Object.create(null);\nfor (const name of namesWithCodes) {\n  codesToNames[table[name].legacyCodeValue] = name;\n}\n\nmodule.exports = DOMException;\n\n// TODO: update constructor signature to match WebIDL spec\n// See also https://github.com/heycam/webidl/pull/22 which isn't merged as of yet\nfunction DOMException(code, message) {\n  const name = codesToNames[code];\n\n  if (message === undefined) {\n    message = table[name].description;\n  }\n  Error.call(this, message);\n\n  Object.defineProperty(this, \"name\", { value: name, writable: true, configurable: true, enumerable: false });\n  Object.defineProperty(this, \"code\", { value: code, writable: true, configurable: true, enumerable: false });\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, DOMException);\n  }\n}\n\nObject.setPrototypeOf(DOMException, Error);\nObject.setPrototypeOf(DOMException.prototype, Error.prototype);\n\nconst constants = Object.create(null);\nfor (const name of namesWithCodes) {\n  constants[table[name].legacyCodeName] = table[name].legacyCodeValue;\n}\n\naddConstants(DOMException, constants);\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/runtime-script-errors.js":"\"use strict\";\nconst util = require(\"util\");\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\n\nconst errorReportingMode = Symbol(\"error reporting mode\");\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#report-the-error\n// Omits script parameter and any check for muted errors; takes error object, message, and location as params, unlike\n// the spec. Returns whether the event was handled or not.\nfunction reportAnError(line, col, target, errorObject, message, location) {\n  if (target[errorReportingMode]) {\n    return false;\n  }\n\n  target[errorReportingMode] = true;\n\n  // TODO Events: use constructor directly, once they are no longer tied to a window.\n  const event = ErrorEvent.createImpl([\"error\", {\n    bubbles: false,\n    cancelable: true,\n    message,\n    filename: location,\n    lineno: line,\n    colno: col,\n    error: errorObject\n  }]);\n\n  try {\n    target.dispatchEvent(event);\n  } finally {\n    target[errorReportingMode] = false;\n    return event.defaultPrevented;\n  }\n}\n\nmodule.exports = function reportException(window, error, filenameHint) {\n  // This function will give good results on real Error objects with stacks; poor ones otherwise\n\n  const stack = error && error.stack;\n  const lines = stack && stack.split(\"\\n\");\n\n  // Find the first line that matches; important for multi-line messages\n  let pieces;\n  if (lines) {\n    for (let i = 1; i < lines.length && !pieces; ++i) {\n      pieces = lines[i].match(/at (?:(.+)\\s+)?\\(?(?:(.+?):(\\d+):(\\d+)|([^)]+))\\)?/);\n    }\n  }\n\n  const fileName = pieces && pieces[2] || filenameHint || window._document.URL;\n  const lineNumber = pieces && parseInt(pieces[3]) || 0;\n  const columnNumber = pieces && parseInt(pieces[4]) || 0;\n\n  const handled = reportAnError(lineNumber, columnNumber, window, error, error.message, fileName);\n\n  if (!handled) {\n    const errorString = shouldBeDisplayedAsError(error) ? `[${error.name}: ${error.message}]` : util.inspect(error);\n    const jsdomError = new Error(`Uncaught ${errorString}`);\n    jsdomError.detail = error;\n    jsdomError.type = \"unhandled exception\";\n\n    window._virtualConsole.emit(\"jsdomError\", jsdomError);\n  }\n};\n\nfunction shouldBeDisplayedAsError(x) {\n  return x.name && x.message !== undefined && x.stack;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ErrorEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Event = require(\"./Event.js\");\nconst impl = utils.implSymbol;\nconst convertErrorEventInit = require(\"./ErrorEventInit\").convert;\n\nfunction ErrorEvent(type) {\n  if (!this || this[impl] || !(this instanceof ErrorEvent)) {\n    throw new TypeError(\"Failed to construct 'ErrorEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'ErrorEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertErrorEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nErrorEvent.prototype = Object.create(Event.interface.prototype);\nErrorEvent.prototype.constructor = ErrorEvent;\n\n\nErrorEvent.prototype.toString = function () {\n  if (this === ErrorEvent.prototype) {\n    return \"[object ErrorEventPrototype]\";\n  }\n  return Event.interface.prototype.toString.call(this);\n};\nObject.defineProperty(ErrorEvent.prototype, \"message\", {\n  get() {\n    return this[impl].message;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ErrorEvent.prototype, \"filename\", {\n  get() {\n    return this[impl].filename;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ErrorEvent.prototype, \"lineno\", {\n  get() {\n    return this[impl].lineno;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ErrorEvent.prototype, \"colno\", {\n  get() {\n    return this[impl].colno;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ErrorEvent.prototype, \"error\", {\n  get() {\n    return this[impl].error;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(ErrorEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(ErrorEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Event._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: ErrorEvent,\n  expose: {\n    Window: { ErrorEvent: ErrorEvent },\n    Worker: { ErrorEvent: ErrorEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/ErrorEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Event.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\nconst convertEventInit = require(\"./EventInit\").convert;\n\nfunction Event(type) {\n  if (!this || this[impl] || !(this instanceof Event)) {\n    throw new TypeError(\"Failed to construct 'Event': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'Event': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertEventInit(args[1]);\n\n  iface.setup(this, args);\n}\n\n\nEvent.prototype.stopPropagation = function stopPropagation() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].stopPropagation.apply(this[impl], args);\n};\n\nEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].stopImmediatePropagation.apply(this[impl], args);\n};\n\nEvent.prototype.preventDefault = function preventDefault() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].preventDefault.apply(this[impl], args);\n};\n\nEvent.prototype.initEvent = function initEvent(type, bubbles, cancelable) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 3) {\n    throw new TypeError(\"Failed to execute 'initEvent' on 'Event': 3 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"boolean\"](args[1]);\n  args[2] = conversions[\"boolean\"](args[2]);\n  return this[impl].initEvent.apply(this[impl], args);\n};\n\nEvent.prototype.toString = function () {\n  if (this === Event.prototype) {\n    return \"[object EventPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(Event.prototype, \"type\", {\n  get() {\n    return this[impl].type;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"target\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].target);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"currentTarget\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].currentTarget);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event, \"NONE\", {\n  value: 0,\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"NONE\", {\n  value: 0,\n  enumerable: true\n});\n\nObject.defineProperty(Event, \"CAPTURING_PHASE\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"CAPTURING_PHASE\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(Event, \"AT_TARGET\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"AT_TARGET\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(Event, \"BUBBLING_PHASE\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"BUBBLING_PHASE\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(Event.prototype, \"eventPhase\", {\n  get() {\n    return this[impl].eventPhase;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"cancelBubble\", {\n  get() {\n    return this[impl].cancelBubble;\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    this[impl].cancelBubble = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"bubbles\", {\n  get() {\n    return this[impl].bubbles;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"cancelable\", {\n  get() {\n    return this[impl].cancelable;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"defaultPrevented\", {\n  get() {\n    return this[impl].defaultPrevented;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"timeStamp\", {\n  get() {\n    return this[impl].timeStamp;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Event.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Event.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Object.defineProperty(obj, \"isTrusted\", {\n      get() {\n        return obj[impl].isTrusted;\n      },\n      enumerable: true,\n      configurable: false\n    });\n    \n    \n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Event,\n  expose: {\n    Window: { Event: Event },\n    Worker: { Event: Event }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/Event-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/EventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    let key, value;\n\n    key = \"bubbles\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"cancelable\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/Event-impl.js":"\"use strict\";\n\nconst EventInit = require(\"../generated/EventInit\");\n\nclass EventImpl {\n  constructor(args, privateData) {\n    const type = args[0]; // TODO: Replace with destructuring\n    const eventInitDict = args[1] || EventInit.convert(undefined);\n\n    this.type = type;\n\n    const wrapper = privateData.wrapper;\n    for (const key in eventInitDict) {\n      if (key in wrapper) {\n        this[key] = eventInitDict[key];\n      }\n    }\n\n    this.target = null;\n    this.currentTarget = null;\n    this.eventPhase = 0;\n\n    this._initializedFlag = true;\n    this._stopPropagationFlag = false;\n    this._stopImmediatePropagationFlag = false;\n    this._canceledFlag = false;\n    this._dispatchFlag = false;\n\n    this.isTrusted = privateData.isTrusted || false;\n    this.timeStamp = Date.now();\n  }\n\n  get defaultPrevented() {\n    return this._canceledFlag;\n  }\n\n  stopPropagation() {\n    this._stopPropagationFlag = true;\n  }\n\n  get cancelBubble() {\n    return this._stopPropagationFlag;\n  }\n\n  set cancelBubble(v) {\n    if (v) {\n      this._stopPropagationFlag = true;\n    }\n  }\n\n  stopImmediatePropagation() {\n    this._stopPropagationFlag = true;\n    this._stopImmediatePropagationFlag = true;\n  }\n\n  preventDefault() {\n    if (this.cancelable) {\n      this._canceledFlag = true;\n    }\n  }\n\n  _initialize(type, bubbles, cancelable) {\n    this.type = type;\n    this._initializedFlag = true;\n\n    this._stopPropagationFlag = false;\n    this._stopImmediatePropagationFlag = false;\n    this._canceledFlag = false;\n\n    this.isTrusted = false;\n    this.target = null;\n    this.bubbles = bubbles;\n    this.cancelable = cancelable;\n  }\n\n  initEvent(type, bubbles, cancelable) {\n    if (this._dispatchFlag) {\n      return;\n    }\n\n    this._initialize(type, bubbles, cancelable);\n  }\n}\n\nmodule.exports = {\n  implementation: EventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ErrorEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventInit = require(\"./EventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"colno\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned long\"](value);\n    }\n\n    key = \"error\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"any\"](value);\n    }\n\n    key = \"filename\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    }\n\n    key = \"lineno\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned long\"](value);\n    }\n\n    key = \"message\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/ErrorEvent-impl.js":"\"use strict\";\n\nconst EventImpl = require(\"./Event-impl\").implementation;\n\nclass ErrorEventImpl extends EventImpl {\n\n}\n\nmodule.exports = {\n  implementation: ErrorEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/named-properties-window.js":"\"use strict\";\nconst hasOwnProp = Object.prototype.hasOwnProperty;\nconst namedPropertiesTracker = require(\"../named-properties-tracker\");\nconst NODE_TYPE = require(\"./node-type\");\nconst createHTMLCollection = require(\"./html-collection\").create;\nconst treeOrderSorter = require(\"../utils\").treeOrderSorter;\nconst idlUtils = require(\"./generated/utils\");\n\nfunction isNamedPropertyElement(element) {\n  // (for the name attribute)\n\n  // use hasOwnProperty to make sure contentWindow comes from the prototype,\n  // and is not set directly on the node by a script.\n  if (\"contentWindow\" in element && !hasOwnProp.call(element, \"contentWindow\")) {\n    return true;\n  }\n\n  switch (element.nodeName) {\n    case \"A\":\n    case \"APPLET\":\n    case \"AREA\":\n    case \"EMBED\":\n    case \"FORM\":\n    case \"FRAMESET\":\n    case \"IMG\":\n    case \"OBJECT\":\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction namedPropertyResolver(HTMLCollection, window, name, values) {\n  function getResult() {\n    const results = [];\n\n    for (const node of values().keys()) {\n      if (node.nodeType !== NODE_TYPE.ELEMENT_NODE) {\n        continue;\n      }\n\n      if (node.getAttribute(\"id\") === name) {\n        results.push(node);\n      } else if (node.getAttribute(\"name\") === name && isNamedPropertyElement(node)) {\n        results.push(node);\n      }\n    }\n\n    results.sort(treeOrderSorter);\n\n    return results;\n  }\n\n  const document = window._document;\n  const objects = createHTMLCollection(idlUtils.implForWrapper(document.documentElement), getResult);\n\n  const length = objects.length;\n  for (let i = 0; i < length; ++i) {\n    const node = objects[i];\n\n    if (\"contentWindow\" in node && !hasOwnProp.call(node, \"contentWindow\") &&\n       node.getAttribute(\"name\") === name) {\n      return node.contentWindow;\n    }\n  }\n\n  if (length === 0) {\n    return undefined;\n  }\n\n  if (length === 1) {\n    return objects[0];\n  }\n\n  return objects;\n}\n\nexports.initializeWindow = function (window, HTMLCollection) {\n  namedPropertiesTracker.create(window, namedPropertyResolver.bind(null, HTMLCollection));\n};\n\nexports.elementAttributeModified = function (element, name, value, oldValue) {\n  if (!element._attached) {\n    return;\n  }\n\n  const useName = isNamedPropertyElement(element);\n\n  if (name === \"id\" || (name === \"name\" && useName)) {\n    const tracker = namedPropertiesTracker.get(element._ownerDocument._global);\n\n    // (tracker will be null if the document has no Window)\n    if (tracker) {\n      if (name === \"id\" && (!useName || element.getAttribute(\"name\") !== oldValue)) {\n        tracker.untrack(oldValue, element);\n      }\n\n      if (name === \"name\" && element.getAttribute(\"id\") !== oldValue) {\n        tracker.untrack(oldValue, element);\n      }\n\n      tracker.track(value, element);\n    }\n  }\n};\n\nexports.nodeAttachedToDocument = function (node) {\n  if (node.nodeType !== NODE_TYPE.ELEMENT_NODE) {\n    return;\n  }\n\n  const tracker = namedPropertiesTracker.get(node._ownerDocument._global);\n  if (!tracker) {\n    return;\n  }\n\n  tracker.track(node.getAttribute(\"id\"), node);\n\n  if (isNamedPropertyElement(node)) {\n    tracker.track(node.getAttribute(\"name\"), node);\n  }\n};\n\nexports.nodeDetachedFromDocument = function (node) {\n  if (node.nodeType !== NODE_TYPE.ELEMENT_NODE) {\n    return;\n  }\n\n  const tracker = namedPropertiesTracker.get(node._ownerDocument._global);\n  if (!tracker) {\n    return;\n  }\n\n  tracker.untrack(node.getAttribute(\"id\"), node);\n\n  if (isNamedPropertyElement(node)) {\n    tracker.untrack(node.getAttribute(\"name\"), node);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/named-properties-tracker.js":"\"use strict\";\n// https://heycam.github.io/webidl/#idl-named-properties\n\nconst IS_NAMED_PROPERTY = Symbol();\nconst TRACKER = Symbol();\n\n/**\n * Create a new NamedPropertiesTracker for the given `object`.\n *\n * Named properties are used in DOM to let you lookup (for example) a Node by accessing a property on another object.\n * For example `window.foo` might resolve to an image element with id \"foo\".\n *\n * This tracker is a workaround because the ES6 Proxy feature is not yet available.\n *\n * @param {Object} object\n * @param {Function} resolverFunc Each time a property is accessed, this function is called to determine the value of\n *        the property. The function is passed 3 arguments: (object, name, values).\n *        `object` is identical to the `object` parameter of this `create` function.\n *        `name` is the name of the property.\n *        `values` is a function that returns a Set with all the tracked values for this name. The order of these\n *        values is undefined.\n *\n * @returns {NamedPropertiesTracker}\n */\nexports.create = function (object, resolverFunc) {\n  if (object[TRACKER]) {\n    throw Error(\"A NamedPropertiesTracker has already been created for this object\");\n  }\n\n  const tracker = new NamedPropertiesTracker(object, resolverFunc);\n  object[TRACKER] = tracker;\n  return tracker;\n};\n\nexports.get = function (object) {\n  if (!object) {\n    return null;\n  }\n\n  return object[TRACKER] || null;\n};\n\nfunction NamedPropertiesTracker(object, resolverFunc) {\n  this.object = object;\n  this.resolverFunc = resolverFunc;\n  this.trackedValues = new Map(); // Map<Set<value>>\n}\n\nfunction newPropertyDescriptor(tracker, name) {\n  const emptySet = new Set();\n\n  function getValues() {\n    return tracker.trackedValues.get(name) || emptySet;\n  }\n\n  const descriptor = {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return tracker.resolverFunc(tracker.object, name, getValues);\n    },\n    set(value) {\n      Object.defineProperty(tracker.object, name, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n      });\n    }\n  };\n\n  descriptor.get[IS_NAMED_PROPERTY] = true;\n  descriptor.set[IS_NAMED_PROPERTY] = true;\n  return descriptor;\n}\n\n/**\n * Track a value (e.g. a Node) for a specified name.\n *\n * Values can be tracked eagerly, which means that not all tracked values *have* to appear in the output. The resolver\n * function that was passed to the output may filter the value.\n *\n * Tracking the same `name` and `value` pair multiple times has no effect\n *\n * @param {String} name\n * @param {*} value\n */\nNamedPropertiesTracker.prototype.track = function (name, value) {\n  if (name === undefined || name === null || name === \"\") {\n    return;\n  }\n\n  let valueSet = this.trackedValues.get(name);\n  if (!valueSet) {\n    valueSet = new Set();\n    this.trackedValues.set(name, valueSet);\n  }\n\n  valueSet.add(value);\n\n  if (name in this.object) {\n    // already added our getter or it is not a named property (e.g. \"addEventListener\")\n    return;\n  }\n\n  const descriptor = newPropertyDescriptor(this, name);\n  Object.defineProperty(this.object, name, descriptor);\n};\n\n/**\n * Stop tracking a previously tracked `name` & `value` pair, see track().\n *\n * Untracking the same `name` and `value` pair multiple times has no effect\n *\n * @param {String} name\n * @param {*} value\n */\nNamedPropertiesTracker.prototype.untrack = function (name, value) {\n  if (name === undefined || name === null || name === \"\") {\n    return;\n  }\n\n  const valueSet = this.trackedValues.get(name);\n  if (!valueSet) {\n    // the value is not present\n    return;\n  }\n\n  if (!valueSet.delete(value)) {\n    // the value was not present\n    return;\n  }\n\n  if (valueSet.size === 0) {\n    this.trackedValues.delete(name);\n  }\n\n  if (valueSet.size > 0) {\n    // other values for this name are still present\n    return;\n  }\n\n  // at this point there are no more values, delete the property\n\n  const descriptor = Object.getOwnPropertyDescriptor(this.object, name);\n\n  if (!descriptor || !descriptor.get || descriptor.get[IS_NAMED_PROPERTY] !== true) {\n    // Not defined by NamedPropertyTracker\n    return;\n  }\n\n  // note: delete puts the object in dictionary mode.\n  // if this turns out to be a performance issue, maybe add:\n  // https://github.com/petkaantonov/bluebird/blob/3e36fc861ac5795193ba37935333eb6ef3716390/src/util.js#L177\n  delete this.object[name];\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/html-collection.js":"\"use strict\";\nconst lengthFromProperties = require(\"../utils\").lengthFromProperties;\nconst getAttributeValue = require(\"./attributes\").getAttributeValue;\nconst idlUtils = require(\"./generated/utils\");\n\nconst privates = Symbol(\"HTMLCollection internal slots\");\n\nconst conflictKeys = new Set([\"length\", \"item\", \"namedItem\"]);\n\nclass HTMLCollection {\n  constructor(secret, element, query) {\n    if (secret !== privates) {\n      throw new TypeError(\"Invalid constructor\");\n    }\n\n    this[privates] = { element, query, keys: [], length: 0, version: -1, conflictElements: Object.create(null) };\n    updateHTMLCollection(this);\n  }\n\n  get length() {\n    updateHTMLCollection(this);\n    return this[privates].length;\n  }\n\n  item(index) {\n    updateHTMLCollection(this);\n    return this[index] || null;\n  }\n\n  namedItem(name) {\n    updateHTMLCollection(this);\n\n    if (conflictKeys.has(name)) {\n      return this[privates].conflictElements[name] || null;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(this, name)) {\n      return this[name];\n    }\n    return null;\n  }\n}\n\nHTMLCollection.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];\n\nfunction updateHTMLCollection(collection) {\n  if (collection[privates].version < collection[privates].element._version) {\n    resetHTMLCollectionTo(collection, collection[privates].query());\n    collection[privates].version = collection[privates].element._version;\n  }\n}\n\nfunction resetHTMLCollectionTo(collection, impls) {\n  const wrappers = impls.map(idlUtils.wrapperForImpl);\n\n  const startingLength = lengthFromProperties(collection);\n  for (let i = 0; i < startingLength; ++i) {\n    delete collection[i];\n  }\n\n  for (let i = 0; i < wrappers.length; ++i) {\n    collection[i] = wrappers[i];\n  }\n  collection[privates].length = wrappers.length;\n\n  const keys = collection[privates].keys;\n  for (let i = 0; i < keys.length; ++i) {\n    delete collection[keys[i]];\n  }\n  keys.length = 0;\n\n  for (let i = 0; i < impls.length; ++i) {\n    addIfAttrPresent(impls[i], wrappers[i], \"name\");\n  }\n  for (let i = 0; i < impls.length; ++i) {\n    addIfAttrPresent(impls[i], wrappers[i], \"id\");\n  }\n\n  function addIfAttrPresent(impl, wrapper, attr) {\n    const value = getAttributeValue(impl, attr);\n\n    if (value === null || value === \"\") {\n      return;\n    }\n\n    // Don't overwrite numeric indices with named ones.\n    const valueAsNumber = Number(value);\n    if (!Number.isNaN(valueAsNumber) && valueAsNumber >= 0) {\n      return;\n    }\n\n    // Don't override existing named ones\n    if (keys.indexOf(value) !== -1) {\n      return;\n    }\n\n    if (conflictKeys.has(value)) {\n      collection[privates].conflictElements[value] = wrapper;\n    } else {\n      collection[value] = wrapper;\n    }\n    keys.push(value);\n  }\n}\n\nmodule.exports = function (core) {\n  core.HTMLCollection = HTMLCollection;\n};\n\nmodule.exports.create = function (element, query) {\n  return new HTMLCollection(privates, element, query);\n};\n\nmodule.exports.update = updateHTMLCollection;\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/attributes.js":"\"use strict\";\nconst DOMException = require(\"../web-idl/DOMException\");\nconst defineGetter = require(\"../utils\").defineGetter;\nconst idlUtils = require(\"./generated/utils\");\nconst attrGenerated = require(\"./generated/Attr\");\nconst changeAttributeImpl = require(\"./attributes/Attr-impl\").changeAttributeImpl;\nconst getAttrImplQualifiedName = require(\"./attributes/Attr-impl\").getAttrImplQualifiedName;\n\n// https://dom.spec.whatwg.org/#namednodemap\n\nconst INTERNAL = Symbol(\"NamedNodeMap internal\");\n\n// TODO: use NamedPropertyTracker when https://github.com/tmpvar/jsdom/pull/1116 lands?\n\n// Don't emulate named getters for these properties.\n// Compiled later after NamedNodeMap is all set up.\nconst reservedNames = new Set();\n\nfunction NamedNodeMap() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\ndefineGetter(NamedNodeMap.prototype, \"length\", function () {\n  return this[INTERNAL].attributeList.length;\n});\n\nNamedNodeMap.prototype.item = function (index) {\n  if (arguments.length < 1) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.item\");\n  }\n\n  // Don't bother with full unsigned long long conversion. When we have better WebIDL support generally, revisit.\n  index = Number(index);\n\n  return this[index] || null;\n};\n\nNamedNodeMap.prototype.getNamedItem = function (name) {\n  if (arguments.length < 1) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.getNamedItem\");\n  }\n  name = String(name);\n\n  return idlUtils.wrapperForImpl(exports.getAttributeByName(this[INTERNAL].element, name));\n};\n\nNamedNodeMap.prototype.getNamedItemNS = function (namespace, localName) {\n  if (arguments.length < 2) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.getNamedItemNS\");\n  }\n  if (namespace === undefined || namespace === null) {\n    namespace = null;\n  } else {\n    namespace = String(namespace);\n  }\n  localName = String(localName);\n\n  return idlUtils.wrapperForImpl(exports.getAttributeByNameNS(this[INTERNAL].element, namespace, localName));\n};\n\nNamedNodeMap.prototype.setNamedItem = function (attr) {\n  if (!attrGenerated.is(attr)) {\n    throw new TypeError(\"First argument to NamedNodeMap.prototype.setNamedItem must be an Attr\");\n  }\n\n  return idlUtils.wrapperForImpl(exports.setAttribute(this[INTERNAL].element, idlUtils.implForWrapper(attr)));\n};\n\nNamedNodeMap.prototype.setNamedItemNS = function (attr) {\n  if (!attrGenerated.is(attr)) {\n    throw new TypeError(\"First argument to NamedNodeMap.prototype.setNamedItemNS must be an Attr\");\n  }\n\n  return idlUtils.wrapperForImpl(exports.setAttribute(this[INTERNAL].element, idlUtils.implForWrapper(attr)));\n};\n\nNamedNodeMap.prototype.removeNamedItem = function (name) {\n  if (arguments.length < 1) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.getNamedItem\");\n  }\n  name = String(name);\n\n  const attr = exports.removeAttributeByName(this[INTERNAL].element, name);\n\n  if (attr === null) {\n    throw new DOMException(DOMException.NOT_FOUND_ERR, \"Tried to remove an attribute that was not present\");\n  }\n\n  return idlUtils.wrapperForImpl(attr);\n};\n\nNamedNodeMap.prototype.removeNamedItemNS = function (namespace, localName) {\n  if (arguments.length < 2) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.removeNamedItemNS\");\n  }\n  if (namespace === undefined || namespace === null) {\n    namespace = null;\n  } else {\n    namespace = String(namespace);\n  }\n  localName = String(localName);\n\n  const attr = exports.removeAttributeByNameNS(this[INTERNAL].element, namespace, localName);\n\n  if (attr === null) {\n    throw new DOMException(DOMException.NOT_FOUND_ERR, \"Tried to remove an attribute that was not present\");\n  }\n\n  return idlUtils.wrapperForImpl(attr);\n};\n\nexports.NamedNodeMap = NamedNodeMap;\n\n{\n  let prototype = NamedNodeMap.prototype;\n  while (prototype) {\n    for (const name of Object.getOwnPropertyNames(prototype)) {\n      reservedNames.add(name);\n    }\n    prototype = Object.getPrototypeOf(prototype);\n  }\n}\n\nexports.createNamedNodeMap = function (element) {\n  const nnm = Object.create(NamedNodeMap.prototype);\n  nnm[INTERNAL] = {\n    element,\n    attributeList: [],\n    attributesByNameMap: new Map()\n  };\n  return nnm;\n};\n\n// The following three are for https://dom.spec.whatwg.org/#concept-element-attribute-has. We don't just have a\n// predicate tester since removing that kind of flexibility gives us the potential for better future optimizations.\n\nexports.hasAttribute = function (element, A) {\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  return attributeList.indexOf(A) !== -1;\n};\n\nexports.hasAttributeByName = function (element, name) {\n  const attributesNNM = element._attributes;\n  const attributesByNameMap = attributesNNM[INTERNAL].attributesByNameMap;\n\n  return attributesByNameMap.has(name);\n};\n\nexports.hasAttributeByNameNS = function (element, namespace, localName) {\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  return attributeList.some(attribute => {\n    return attribute._localName === localName && attribute._namespace === namespace;\n  });\n};\n\nexports.changeAttribute = function (element, attribute, value) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-change\n\n  // The partitioning here works around a particularly bad circular require problem. See\n  // https://github.com/tmpvar/jsdom/pull/1247#issuecomment-149060470\n  changeAttributeImpl(element, attribute, value);\n};\n\nexports.appendAttribute = function (element, attribute) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-append\n\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  // TODO mutation observer stuff\n\n  attributeList.push(attribute);\n  attribute._element = element;\n\n  // Sync target indexed properties\n  attributesNNM[attributeList.length - 1] = idlUtils.wrapperForImpl(attribute);\n\n  const name = getAttrImplQualifiedName(attribute);\n\n  // Sync target named properties\n  if (!reservedNames.has(name) && shouldNameBeInNNMProps(element, name)) {\n    Object.defineProperty(attributesNNM, name, {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: idlUtils.wrapperForImpl(attribute)\n    });\n  }\n\n  // Sync name cache\n  const cache = attributesNNM[INTERNAL].attributesByNameMap;\n  let entry = cache.get(name);\n  if (!entry) {\n    entry = [];\n    cache.set(name, entry);\n  }\n  entry.push(attribute);\n\n  // Run jsdom hooks; roughly correspond to spec's \"An attribute is set and an attribute is added.\"\n  element._attrModified(name, attribute._value, null);\n};\n\nexports.removeAttribute = function (element, attribute) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-remove\n\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  // TODO mutation observer stuff\n\n  for (let i = 0; i < attributeList.length; ++i) {\n    if (attributeList[i] === attribute) {\n      attributeList.splice(i, 1);\n      attribute._element = null;\n\n      // Sync target indexed properties\n      for (let j = i; j < attributeList.length; ++j) {\n        attributesNNM[j] = idlUtils.wrapperForImpl(attributeList[j]);\n      }\n      delete attributesNNM[attributeList.length];\n\n      const name = getAttrImplQualifiedName(attribute);\n\n      // Sync target named properties\n      if (!reservedNames.has(name) && shouldNameBeInNNMProps(element, name)) {\n        delete attributesNNM[name];\n      }\n\n      // Sync name cache\n      const cache = attributesNNM[INTERNAL].attributesByNameMap;\n      const entry = cache.get(name);\n      entry.splice(entry.indexOf(attribute), 1);\n      if (entry.length === 0) {\n        cache.delete(name);\n      }\n\n      // Run jsdom hooks; roughly correspond to spec's \"An attribute is removed.\"\n      element._attrModified(name, null, attribute._value);\n\n      return;\n    }\n  }\n};\n\nexports.replaceAttribute = function (element, oldAttr, newAttr) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-replace\n\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  // TODO mutation observer stuff\n\n  for (let i = 0; i < attributeList.length; ++i) {\n    if (attributeList[i] === oldAttr) {\n      attributeList.splice(i, 1, newAttr);\n      oldAttr._element = null;\n      newAttr._element = element;\n\n      // Sync target indexed properties\n      attributesNNM[i] = idlUtils.wrapperForImpl(newAttr);\n\n      const name = getAttrImplQualifiedName(newAttr);\n\n      // Sync target named properties\n      if (!reservedNames.has(name) && shouldNameBeInNNMProps(element, name)) {\n        attributesNNM[name] = newAttr;\n      }\n\n      // Sync name cache\n      const cache = attributesNNM[INTERNAL].attributesByNameMap;\n      let entry = cache.get(name);\n      if (!entry) {\n        entry = [];\n        cache.set(name, entry);\n      }\n      entry.splice(entry.indexOf(oldAttr), 1, newAttr);\n\n      // Run jsdom hooks; roughly correspond to spec's \"An attribute is set and an attribute is changed.\"\n      element._attrModified(name, newAttr._value, oldAttr._value);\n\n      return;\n    }\n  }\n};\n\nexports.getAttributeByName = function (element, name) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name\n\n  if (element._namespaceURI === \"http://www.w3.org/1999/xhtml\" &&\n      element._ownerDocument._parsingMode === \"html\") {\n    name = name.toLowerCase();\n  }\n\n  const cache = element._attributes[INTERNAL].attributesByNameMap;\n  const entry = cache.get(name);\n  if (!entry) {\n    return null;\n  }\n\n  return entry[0];\n};\n\nexports.getAttributeValue = function (element, name) {\n  const attr = exports.getAttributeByName(element, name);\n\n  if (!attr) {\n    return null;\n  }\n\n  return attr._value;\n};\n\nexports.getAttributeByNameNS = function (element, namespace, localName) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace\n\n  if (namespace === \"\") {\n    namespace = null;\n  }\n\n  const attributeList = element._attributes[INTERNAL].attributeList;\n  for (let i = 0; i < attributeList.length; ++i) {\n    const attr = attributeList[i];\n    if (attr._namespace === namespace && attr._localName === localName) {\n      return attr;\n    }\n  }\n\n  return null;\n};\n\nexports.getAttributeValueByNameNS = function (element, namespace, localName) {\n  const attr = exports.getAttributeByNameNS(element, namespace, localName);\n\n  if (!attr) {\n    return null;\n  }\n\n  return attr._value;\n};\n\nexports.setAttribute = function (element, attr) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-set\n\n  if (attr._element !== null && attr._element !== element) {\n    throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n  }\n\n  const oldAttr = exports.getAttributeByNameNS(element, attr._namespace, attr._localName);\n  if (oldAttr === attr) {\n    return attr;\n  }\n\n  if (oldAttr !== null) {\n    exports.replaceAttribute(element, oldAttr, attr);\n  } else {\n    exports.appendAttribute(element, attr);\n  }\n\n  return oldAttr;\n};\n\nexports.setAttributeValue = function (element, localName, value, prefix, namespace) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-set-value\n\n  if (prefix === undefined) {\n    prefix = null;\n  }\n  if (namespace === undefined) {\n    namespace = null;\n  }\n\n  const attribute = exports.getAttributeByNameNS(element, namespace, localName);\n  if (attribute === null) {\n    const newAttribute = attrGenerated.createImpl([], { namespace, namespacePrefix: prefix, localName, value });\n    exports.appendAttribute(element, newAttribute);\n    return;\n  }\n\n  exports.changeAttribute(element, attribute, value);\n};\n\nexports.removeAttributeByName = function (element, name) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name\n\n  const attr = exports.getAttributeByName(element, name);\n\n  if (attr !== null) {\n    exports.removeAttribute(element, attr);\n  }\n\n  return attr;\n};\n\nexports.removeAttributeByNameNS = function (element, namespace, localName) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace\n\n  const attr = exports.getAttributeByNameNS(element, namespace, localName);\n\n  if (attr !== null) {\n    exports.removeAttribute(element, attr);\n  }\n\n  return attr;\n};\n\nexports.copyAttributeList = function (sourceElement, destElement) {\n  // Needed by https://dom.spec.whatwg.org/#concept-node-clone\n\n  for (const sourceAttr of sourceElement._attributes[INTERNAL].attributeList) {\n    const destAttr = attrGenerated.createImpl([], {\n      namespace: sourceAttr._namespace,\n      namespacePrefix: sourceAttr._namespacePrefix,\n      localName: sourceAttr._localName,\n      value: sourceAttr._value\n    });\n\n    exports.appendAttribute(destElement, destAttr);\n  }\n};\n\nexports.attributeListsEqual = function (elementA, elementB) {\n  // Needed by https://dom.spec.whatwg.org/#concept-node-equals\n\n  const listA = elementA._attributes[INTERNAL].attributeList;\n  const listB = elementB._attributes[INTERNAL].attributeList;\n\n  if (listA.length !== listB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < listA.length; ++i) {\n    const attrA = listA[i];\n\n    if (!listB.some(attrB => equalsA(attrB))) {\n      return false;\n    }\n\n    function equalsA(attrB) {\n      return attrA._namespace === attrB._namespace && attrA._localName === attrB._localName &&\n             attrA._value === attrB._value;\n    }\n  }\n\n  return true;\n};\n\nexports.attributeNames = function (element) {\n  // Needed by https://dom.spec.whatwg.org/#dom-element-getattributenames\n\n  return element._attributes[INTERNAL].attributeList.map(getAttrImplQualifiedName);\n};\n\nexports.hasAttributes = function (element) {\n  // Needed by https://dom.spec.whatwg.org/#dom-element-hasattributes\n\n  return element._attributes[INTERNAL].attributeList.length > 0;\n};\n\nfunction shouldNameBeInNNMProps(element, name) {\n  if (element._ownerDocument._parsingMode === \"html\" && element._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n    return name.toLowerCase() === name;\n  }\n  return true;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Attr.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction Attr() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nAttr.prototype.toString = function () {\n  if (this === Attr.prototype) {\n    return \"[object AttrPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(Attr.prototype, \"namespaceURI\", {\n  get() {\n    return this[impl].namespaceURI;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"prefix\", {\n  get() {\n    return this[impl].prefix;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"localName\", {\n  get() {\n    return this[impl].localName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"name\", {\n  get() {\n    return this[impl].name;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"nodeName\", {\n  get() {\n    return this[impl].nodeName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"value\", {\n  get() {\n    return this[impl].value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].value = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"nodeValue\", {\n  get() {\n    return this[impl].nodeValue;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].nodeValue = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"textContent\", {\n  get() {\n    return this[impl].textContent;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].textContent = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"ownerElement\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ownerElement);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"specified\", {\n  get() {\n    return this[impl].specified;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Attr.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Attr.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Attr,\n  expose: {\n    Window: { Attr: Attr }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../attributes/Attr-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/attributes/Attr-impl.js":"\"use strict\";\n\nexports.implementation = class AttrImpl {\n  constructor(_, privateData) {\n    this._namespace = privateData.namespace !== undefined ? privateData.namespace : null;\n    this._namespacePrefix = privateData.namespacePrefix !== undefined ? privateData.namespacePrefix : null;\n    this._localName = privateData.localName;\n    this._value = privateData.value !== undefined ? privateData.value : \"\";\n    this._element = privateData.element !== undefined ? privateData.element : null;\n\n    this.specified = true;\n  }\n\n  get namespaceURI() {\n    return this._namespace;\n  }\n\n  get prefix() {\n    return this._namespacePrefix;\n  }\n\n  get localName() {\n    return this._localName;\n  }\n\n  get name() {\n    return exports.getAttrImplQualifiedName(this);\n  }\n\n  // Delegate to name\n  get nodeName() {\n    return this.name;\n  }\n\n  get value() {\n    return this._value;\n  }\n  set value(v) {\n    if (this._element === null) {\n      this._value = v;\n    } else {\n      exports.changeAttributeImpl(this._element, this, v);\n    }\n  }\n\n  // Delegate to value\n  get nodeValue() {\n    return this.value;\n  }\n  set nodeValue(v) {\n    this.value = v;\n  }\n\n  // Delegate to value\n  get textContent() {\n    return this.value;\n  }\n  set textContent(v) {\n    this.value = v;\n  }\n\n  get ownerElement() {\n    return this._element;\n  }\n};\n\nexports.changeAttributeImpl = function (element, attributeImpl, value) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-change\n\n  // TODO mutation observer stuff\n\n  const oldValue = attributeImpl._value;\n  attributeImpl._value = value;\n\n  // Run jsdom hooks; roughly correspond to spec's \"An attribute is set and an attribute is changed.\"\n  element._attrModified(exports.getAttrImplQualifiedName(attributeImpl), value, oldValue);\n};\n\nexports.getAttrImplQualifiedName = function (attributeImpl) {\n  // https://dom.spec.whatwg.org/#concept-attribute-qualified-name\n\n  if (attributeImpl._namespacePrefix === null) {\n    return attributeImpl._localName;\n  }\n\n  return attributeImpl._namespacePrefix + \":\" + attributeImpl._localName;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/post-message.js":"\"use strict\";\nconst isValidTargetOrigin = require(\"../utils\").isValidTargetOrigin;\nconst DOMException = require(\"../web-idl/DOMException\");\n\nmodule.exports = function (message, targetOrigin) {\n  if (arguments.length < 2) {\n    throw new TypeError(\"'postMessage' requires 2 arguments: 'message' and 'targetOrigin'\");\n  }\n\n  targetOrigin = String(targetOrigin);\n\n  if (!isValidTargetOrigin(targetOrigin)) {\n    throw new DOMException(DOMException.SYNTAX_ERR, \"Failed to execute 'postMessage' on 'Window': \" +\n      \"Invalid target origin '\" + targetOrigin + \"' in a call to 'postMessage'.\");\n  }\n\n  // TODO: targetOrigin === '/' - requires reference to source window\n  // See https://github.com/tmpvar/jsdom/pull/1140#issuecomment-111587499\n  if (targetOrigin !== \"*\" && targetOrigin !== this.origin) {\n    return;\n  }\n\n  // TODO: event.source - requires reference to source window\n  // TODO: event.origin - requires reference to source window\n  // TODO: event.ports\n  // TODO: event.data - structured clone message - requires cloning DOM nodes\n  const event = new this.MessageEvent(\"message\", {\n    data: message\n  });\n\n  event.initEvent(\"message\", false, false);\n\n  setTimeout(() => {\n    this.dispatchEvent(event);\n  }, 0);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/xmlhttprequest.js":"\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\nconst spawnSync = require(\"child_process\").spawnSync;\nconst URL = require(\"whatwg-url\").URL;\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst tough = require(\"tough-cookie\");\nconst parseContentType = require(\"content-type-parser\");\n\nconst xhrUtils = require(\"./xhr-utils\");\nconst DOMException = require(\"../web-idl/DOMException\");\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\nconst addConstants = require(\"../utils\").addConstants;\nconst documentBaseURLSerialized = require(\"./helpers/document-base-url\").documentBaseURLSerialized;\nconst idlUtils = require(\"./generated/utils\");\nconst Document = require(\"./generated/Document\");\nconst Blob = require(\"./generated/Blob\");\nconst domToHtml = require(\"../browser/domtohtml\").domToHtml;\n\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\n\nconst forbiddenRequestHeaders = new Set([\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"access-control-request-headers\",\n  \"access-control-request-method\",\n  \"connection\",\n  \"content-length\",\n  \"cookie\",\n  \"cookie2\",\n  \"date\",\n  \"dnt\",\n  \"expect\",\n  \"host\",\n  \"keep-alive\",\n  \"origin\",\n  \"referer\",\n  \"te\",\n  \"trailer\",\n  \"transfer-encoding\",\n  \"upgrade\",\n  \"via\"\n]);\nconst forbiddenResponseHeaders = new Set([\n  \"set-cookie\",\n  \"set-cookie2\"\n]);\nconst uniqueResponseHeaders = new Set([\n  \"content-type\",\n  \"content-length\",\n  \"user-agent\",\n  \"referer\",\n  \"host\",\n  \"authorization\",\n  \"proxy-authorization\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"from\",\n  \"location\",\n  \"max-forwards\"\n]);\nconst corsSafeResponseHeaders = new Set([\n  \"cache-control\",\n  \"content-language\",\n  \"content-type\",\n  \"expires\",\n  \"last-modified\",\n  \"pragma\"\n]);\n\n\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nconst XMLHttpRequestResponseType = new Set([\n  \"\",\n  \"arraybuffer\",\n  \"blob\",\n  \"document\",\n  \"json\",\n  \"text\"\n]);\n\nconst simpleHeaders = xhrUtils.simpleHeaders;\n\nconst redirectStatuses = new Set([301, 302, 303, 307, 308]);\n\nmodule.exports = function createXMLHttpRequest(window) {\n  const Event = window.Event;\n  const ProgressEvent = window.ProgressEvent;\n  const FormData = window.FormData;\n  const XMLHttpRequestEventTarget = window.XMLHttpRequestEventTarget;\n  const XMLHttpRequestUpload = window.XMLHttpRequestUpload;\n\n  class XMLHttpRequest extends XMLHttpRequestEventTarget {\n    constructor() {\n      super();\n      if (!(this instanceof XMLHttpRequest)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      this.upload = new XMLHttpRequestUpload();\n      this.upload._ownerDocument = window.document;\n\n      this[xhrSymbols.flag] = {\n        synchronous: false,\n        withCredentials: false,\n        mimeType: null,\n        auth: null,\n        method: undefined,\n        responseType: \"\",\n        requestHeaders: {},\n        referrer: this._ownerDocument.URL,\n        uri: \"\",\n        timeout: 0,\n        body: undefined,\n        formData: false,\n        preflight: false,\n        requestManager: this._ownerDocument._requestManager,\n        pool: this._ownerDocument._pool,\n        agentOptions: this._ownerDocument._agentOptions,\n        strictSSL: this._ownerDocument._strictSSL,\n        proxy: this._ownerDocument._proxy,\n        cookieJar: this._ownerDocument._cookieJar,\n        encoding: this._ownerDocument._encoding,\n        origin: this._ownerDocument.origin,\n        userAgent: this._ownerDocument._defaultView.navigator.userAgent\n      };\n\n      this[xhrSymbols.properties] = {\n        beforeSend: false,\n        send: false,\n        timeoutStart: 0,\n        timeoutId: 0,\n        timeoutFn: null,\n        client: null,\n        responseHeaders: {},\n        filteredResponseHeaders: [],\n        responseBuffer: null,\n        responseCache: null,\n        responseTextCache: null,\n        responseXMLCache: null,\n        responseURL: \"\",\n        readyState: XMLHttpRequest.UNSENT,\n        status: 0,\n        statusText: \"\",\n        error: \"\",\n        uploadComplete: true,\n        abortError: false,\n        cookieJar: this._ownerDocument._cookieJar\n      };\n      this.onreadystatechange = null;\n    }\n    get readyState() {\n      return this[xhrSymbols.properties].readyState;\n    }\n    get status() {\n      return this[xhrSymbols.properties].status;\n    }\n    get statusText() {\n      return this[xhrSymbols.properties].statusText;\n    }\n    get responseType() {\n      return this[xhrSymbols.flag].responseType;\n    }\n    set responseType(responseType) {\n      const flag = this[xhrSymbols.flag];\n      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (this.readyState === XMLHttpRequest.OPENED && flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n      if (!XMLHttpRequestResponseType.has(responseType)) {\n        responseType = \"\";\n      }\n      flag.responseType = responseType;\n    }\n    get response() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (properties.responseCache) {\n        return properties.responseCache;\n      }\n      let res = \"\";\n      switch (this.responseType) {\n        case \"\":\n        case \"text\": {\n          res = this.responseText;\n          break;\n        }\n        case \"arraybuffer\": {\n          if (!properties.responseBuffer) {\n            return null;\n          }\n          res = (new Uint8Array(properties.responseBuffer)).buffer;\n          break;\n        }\n        case \"blob\": {\n          if (!properties.responseBuffer) {\n            return null;\n          }\n          const contentType = getContentType(this);\n          res = Blob.create([[new Uint8Array(properties.responseBuffer)], {\n            type: contentType && contentType.toString() || \"\"\n          }]);\n          break;\n        }\n        case \"document\": {\n          res = this.responseXML;\n          break;\n        }\n        case \"json\": {\n          if (this.readyState !== XMLHttpRequest.DONE || !properties.responseBuffer) {\n            res = null;\n          }\n\n          const contentType = getContentType(this);\n          const fallbackEncoding = whatwgEncoding.labelToName(\n            contentType && contentType.get(\"charset\") || flag.encoding);\n          const jsonStr = whatwgEncoding.decode(properties.responseBuffer, fallbackEncoding);\n\n          try {\n            res = JSON.parse(jsonStr);\n          } catch (e) {\n            res = null;\n          }\n          break;\n        }\n      }\n      properties.responseCache = res;\n      return res;\n    }\n    get responseText() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (this.responseType !== \"\" && this.responseType !== \"text\") {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (this.readyState !== XMLHttpRequest.LOADING && this.readyState !== XMLHttpRequest.DONE) {\n        return \"\";\n      }\n      if (properties.responseTextCache) {\n        return properties.responseTextCache;\n      }\n      const responseBuffer = properties.responseBuffer;\n      if (!responseBuffer) {\n        return \"\";\n      }\n\n      const contentType = getContentType(this);\n      const fallbackEncoding = whatwgEncoding.labelToName(contentType && contentType.get(\"charset\") || flag.encoding);\n      const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n\n      properties.responseTextCache = res;\n      return res;\n    }\n    get responseXML() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (this.responseType !== \"\" && this.responseType !== \"document\") {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (this.readyState !== XMLHttpRequest.DONE) {\n        return null;\n      }\n      if (properties.responseXMLCache) {\n        return properties.responseXMLCache;\n      }\n      const responseBuffer = properties.responseBuffer;\n      if (!responseBuffer) {\n        return null;\n      }\n      const contentType = getContentType(this);\n      let isHTML = false;\n      let isXML = false;\n      if (contentType) {\n        isHTML = contentType.isHTML();\n        isXML = contentType.isXML();\n        if (!isXML && !isHTML) {\n          return null;\n        }\n      }\n\n      const encoding = whatwgEncoding.getBOMEncoding(responseBuffer) ||\n                       whatwgEncoding.labelToName(contentType && contentType.get(\"charset\") || flag.encoding);\n      const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n      if (!resText) {\n        return null;\n      }\n      if (this.responseType === \"\" && isHTML) {\n        return null;\n      }\n      const res = Document.create([], { core: window._core, options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: { setCookieSync: () => undefined, getCookieStringSync: () => \"\" },\n        encoding\n      } });\n      const resImpl = idlUtils.implForWrapper(res);\n      try {\n        resImpl._htmlToDom.appendHtmlToDocument(resText, resImpl);\n      } catch (e) {\n        properties.responseXMLCache = null;\n        return null;\n      }\n      res.close();\n      properties.responseXMLCache = res;\n      return res;\n    }\n\n    get responseURL() {\n      return this[xhrSymbols.properties].responseURL;\n    }\n\n    get timeout() {\n      return this[xhrSymbols.flag].timeout;\n    }\n    set timeout(val) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n      flag.timeout = val;\n      clearTimeout(properties.timeoutId);\n      if (val > 0 && properties.timeoutFn) {\n        properties.timeoutId = setTimeout(\n          properties.timeoutFn,\n          Math.max(0, val - ((new Date()).getTime() - properties.timeoutStart))\n        );\n      } else {\n        properties.timeoutFn = null;\n        properties.timeoutStart = 0;\n      }\n    }\n    get withCredentials() {\n      return this[xhrSymbols.flag].withCredentials;\n    }\n    set withCredentials(val) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED)) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      flag.withCredentials = val;\n    }\n\n    abort() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      // Terminate the request\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n\n      const client = properties.client;\n      if (client) {\n        client.abort();\n        properties.client = null;\n      }\n\n      if ((this.readyState === XMLHttpRequest.OPENED && properties.send) ||\n          this.readyState === XMLHttpRequest.HEADERS_RECEIVED ||\n          this.readyState === XMLHttpRequest.LOADING) {\n        // Run the request error steps for event abort\n        properties.readyState = XMLHttpRequest.DONE;\n        properties.send = false;\n\n        properties.status = 0;\n        properties.statusText = \"\";\n        properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n\n        if (flag.synchronous) {\n          throw new DOMException(DOMException.ABORT_ERR);\n        }\n\n        this.dispatchEvent(new Event(\"readystatechange\"));\n\n        // TODO: spec says this should only be checking upload complete flag?\n        if (!(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          properties.uploadComplete = true;\n\n          // TODO upload listener\n\n          this.upload.dispatchEvent(new ProgressEvent(\"abort\"));\n          if (properties.abortError) {\n            // TODO document what this is about (here and below)\n            this.upload.dispatchEvent(new ProgressEvent(\"error\"));\n          }\n          this.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n        }\n\n        this.dispatchEvent(new ProgressEvent(\"abort\"));\n        if (properties.abortError) {\n          this.dispatchEvent(new ProgressEvent(\"error\"));\n        }\n        this.dispatchEvent(new ProgressEvent(\"loadend\"));\n      }\n\n      if (this.readyState === XMLHttpRequest.DONE) {\n        properties.readyState = XMLHttpRequest.UNSENT;\n\n        properties.status = 0;\n        properties.statusText = \"\";\n        properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n      }\n    }\n    getAllResponseHeaders() {\n      const properties = this[xhrSymbols.properties];\n      const readyState = this.readyState;\n      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n        return \"\";\n      }\n      return Object.keys(properties.responseHeaders)\n        .filter(key => properties.filteredResponseHeaders.indexOf(key) === -1)\n        .map(key => [key, properties.responseHeaders[key]].join(\": \")).join(\"\\r\\n\");\n    }\n\n    getResponseHeader(header) {\n      const properties = this[xhrSymbols.properties];\n      const readyState = this.readyState;\n      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n        return null;\n      }\n      const lcHeader = toByteString(header).toLowerCase();\n      if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n        return null;\n      }\n      return getResponseHeader(this, lcHeader);\n    }\n\n    open(method, uri, asynchronous, user, password) {\n      if (!this._ownerDocument) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      const argumentCount = arguments.length;\n      if (argumentCount < 2) {\n        throw new TypeError(\"Not enought arguments\");\n      }\n      method = toByteString(method);\n      if (!tokenRegexp.test(method)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n      const upperCaseMethod = method.toUpperCase();\n      if (forbiddenRequestMethods.has(upperCaseMethod)) {\n        throw new DOMException(DOMException.SECURITY_ERR);\n      }\n\n      const client = properties.client;\n      if (client && typeof client.abort === \"function\") {\n        client.abort();\n      }\n\n      if (allowedRequestMethods.has(upperCaseMethod)) {\n        method = upperCaseMethod;\n      }\n      if (typeof asynchronous !== \"undefined\") {\n        flag.synchronous = !asynchronous;\n      } else {\n        flag.synchronous = false;\n      }\n      if (flag.responseType && flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n      if (flag.synchronous && flag.timeout) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n      flag.method = method;\n\n      let urlObj;\n      try {\n        urlObj = new URL(uri, documentBaseURLSerialized(this._ownerDocument));\n      } catch (e) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      if (user || (password && !urlObj.username)) {\n        flag.auth = {\n          user,\n          pass: password\n        };\n        urlObj.username = \"\";\n        urlObj.password = \"\";\n      }\n\n      flag.uri = urlObj.href;\n      flag.requestHeaders = {};\n      flag.preflight = false;\n\n      properties.send = false;\n      properties.requestBuffer = null;\n      properties.requestCache = null;\n      properties.abortError = false;\n      properties.responseURL = \"\";\n      readyStateChange(this, XMLHttpRequest.OPENED);\n    }\n\n    overrideMimeType(mime) {\n      const readyState = this.readyState;\n      if (readyState === XMLHttpRequest.LOADING || readyState === XMLHttpRequest.DONE) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (!mime) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n      mime = String(mime);\n      if (!parseContentType(mime)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n      this[xhrSymbols.flag].mimeType = mime;\n    }\n\n    send(body) {\n      if (!this._ownerDocument) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      properties.beforeSend = true;\n\n      try {\n        if (!flag.body &&\n            body !== undefined &&\n            body !== null &&\n            body !== \"\" &&\n            !(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          let contentType = null;\n          let encoding = null;\n          if (body instanceof FormData) {\n            flag.formData = true;\n            const formData = [];\n            for (const entry of idlUtils.implForWrapper(body)._entries) {\n              let val;\n              if (Blob.isImpl(entry.value)) {\n                const blob = entry.value;\n                val = {\n                  name: entry.name,\n                  value: blob._buffer,\n                  options: {\n                    filename: blob.name,\n                    contentType: blob.type,\n                    knownLength: blob.size\n                  }\n                };\n              } else {\n                val = entry;\n              }\n              formData.push(val);\n            }\n            flag.body = formData;\n            // TODO content type; what is the form boundary?\n          } else if (Blob.is(body)) {\n            const blob = idlUtils.implForWrapper(body);\n            flag.body = blob._buffer;\n            if (blob.type !== \"\") {\n              contentType = blob.type;\n            }\n          } else if (body instanceof ArrayBuffer) {\n            flag.body = new Buffer(new Uint8Array(body));\n          } else if (body instanceof Document.interface) {\n            if (body.childNodes.length === 0) {\n              throw new DOMException(DOMException.INVALID_STATE_ERR);\n            }\n            flag.body = domToHtml([body]);\n\n            encoding = \"UTF-8\";\n\n            const documentBodyParsingMode = idlUtils.implForWrapper(body)._parsingMode;\n            contentType = documentBodyParsingMode === \"html\" ? \"text/html\" : \"application/xml\";\n            contentType += \";charset=UTF-8\";\n          } else if (typeof body !== \"string\") {\n            flag.body = String(body);\n          } else {\n            flag.body = body;\n            contentType = \"text/plain;charset=UTF-8\";\n            encoding = \"UTF-8\";\n          }\n\n          const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n          if (contentType !== null && existingContentType === null) {\n            flag.requestHeaders[\"Content-Type\"] = contentType;\n          } else if (existingContentType !== null && encoding !== null) {\n            const parsed = parseContentType(existingContentType);\n            if (parsed) {\n              parsed.parameterList\n                .filter(v => v.key && v.key.toLowerCase() === \"charset\" &&\n                        whatwgEncoding.labelToName(v.value) !== \"UTF-8\")\n                .forEach(v => {\n                  v.value = \"UTF-8\";\n                });\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      } finally {\n        if (properties.beforeSend) {\n          properties.beforeSend = false;\n        } else {\n          throw new DOMException(DOMException.INVALID_STATE_ERR);\n        }\n      }\n\n      if (flag.synchronous) {\n        const flagStr = JSON.stringify(flag, function (k, v) {\n          if (this === flag && k === \"requestManager\") {\n            return null;\n          }\n          if (this === flag && k === \"pool\" && v) {\n            return { maxSockets: v.maxSockets };\n          }\n          return v;\n        });\n        const res = spawnSync(\n          process.execPath,\n          [syncWorkerFile],\n          { input: flagStr }\n        );\n        if (res.status !== 0) {\n          throw new Error(res.stderr.toString());\n        }\n        if (res.error) {\n          if (typeof res.error === \"string\") {\n            res.error = new Error(res.error);\n          }\n          throw res.error;\n        }\n        const response = JSON.parse(res.stdout.toString(), (k, v) => {\n          if (k === \"responseBuffer\" && v && v.data) {\n            return new Buffer(v.data);\n          }\n          if (k === \"cookieJar\" && v) {\n            return tough.CookieJar.deserializeSync(v, this._ownerDocument._cookieJar.store);\n          }\n          return v;\n        });\n        response.properties.readyState = XMLHttpRequest.LOADING;\n        this[xhrSymbols.properties] = response.properties;\n\n        if (response.properties.error) {\n          dispatchError(this);\n          throw new DOMException(DOMException.NETWORK_ERR, response.properties.error);\n        } else {\n          const responseBuffer = this[xhrSymbols.properties].responseBuffer;\n          const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n          const bufferLength = parseInt(contentLength) || responseBuffer.length;\n          const progressObj = { lengthComputable: false };\n          if (bufferLength !== 0) {\n            progressObj.total = bufferLength;\n            progressObj.loaded = bufferLength;\n            progressObj.lengthComputable = true;\n          }\n          this.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n          readyStateChange(this, XMLHttpRequest.DONE);\n          this.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n          this.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n        }\n      } else {\n        properties.send = true;\n\n        this.dispatchEvent(new ProgressEvent(\"loadstart\"));\n\n        const client = xhrUtils.createClient(this);\n\n        properties.client = client;\n\n        properties.origin = flag.origin;\n\n        client.on(\"error\", err => {\n          client.removeAllListeners();\n          properties.error = err;\n          dispatchError(this);\n        });\n\n        client.on(\"response\", res => receiveResponse(this, res));\n\n        client.on(\"redirect\", () => {\n          if (flag.preflight) {\n            properties.error = \"Redirect after preflight forbidden\";\n            dispatchError(this);\n            client.abort();\n            return;\n          }\n\n          const response = client.response;\n          const destUrlObj = new URL(response.request.headers.Referer);\n\n          const urlObj = new URL(response.request.uri.href);\n\n          if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n            properties.origin = \"null\";\n          }\n\n          response.request.headers.Origin = properties.origin;\n\n          if (flag.origin !== destUrlObj.origin &&\n              destUrlObj.protocol !== \"data:\") {\n            if (!validCORSHeaders(this, response, flag, properties, flag.origin)) {\n              return;\n            }\n            if (urlObj.username || urlObj.password || response.request.uri.href.match(/^https?:\\/\\/:@/)) {\n              properties.error = \"Userinfo forbidden in cors redirect\";\n              dispatchError(this);\n              return;\n            }\n          }\n        });\n        if (body !== undefined &&\n          body !== null &&\n          body !== \"\" &&\n          !(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          properties.uploadComplete = false;\n          setDispatchProgressEvents(this);\n        } else {\n          properties.uploadComplete = true;\n        }\n        if (this.timeout > 0) {\n          properties.timeoutStart = (new Date()).getTime();\n          properties.timeoutFn = () => {\n            client.abort();\n            if (!(this.readyState === XMLHttpRequest.UNSENT ||\n                (this.readyState === XMLHttpRequest.OPENED && !properties.send) ||\n                this.readyState === XMLHttpRequest.DONE)) {\n              properties.send = false;\n              let stateChanged = false;\n              if (!(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n                this.upload.dispatchEvent(new ProgressEvent(\"progress\"));\n                readyStateChange(this, XMLHttpRequest.DONE);\n                this.upload.dispatchEvent(new ProgressEvent(\"timeout\"));\n                this.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n                stateChanged = true;\n              }\n              this.dispatchEvent(new ProgressEvent(\"progress\"));\n              if (!stateChanged) {\n                readyStateChange(this, XMLHttpRequest.DONE);\n              }\n              this.dispatchEvent(new ProgressEvent(\"timeout\"));\n              this.dispatchEvent(new ProgressEvent(\"loadend\"));\n            }\n            properties.readyState = XMLHttpRequest.UNSENT;\n          };\n          properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n        }\n      }\n      flag.body = undefined;\n      flag.formData = false;\n    }\n\n    setRequestHeader(header, value) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (arguments.length !== 2) {\n        throw new TypeError(\"2 arguments required for setRequestHeader\");\n      }\n      header = toByteString(header);\n      value = toByteString(value);\n\n      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      value = normalizeHeaderValue(value);\n\n      if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      const lcHeader = header.toLowerCase();\n\n      if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n        return;\n      }\n\n      const keys = Object.keys(flag.requestHeaders);\n      let n = keys.length;\n      while (n--) {\n        const key = keys[n];\n        if (key.toLowerCase() === lcHeader) {\n          flag.requestHeaders[key] += \",\" + value;\n          return;\n        }\n      }\n      flag.requestHeaders[lcHeader] = value;\n    }\n\n    toString() {\n      return \"[object XMLHttpRequest]\";\n    }\n\n    get _ownerDocument() {\n      return idlUtils.implForWrapper(window.document);\n    }\n  }\n\n  addConstants(XMLHttpRequest, {\n    UNSENT: 0,\n    OPENED: 1,\n    HEADERS_RECEIVED: 2,\n    LOADING: 3,\n    DONE: 4\n  });\n\n  function readyStateChange(xhr, readyState) {\n    const properties = xhr[xhrSymbols.properties];\n    if (properties.readyState === readyState) {\n      return;\n    }\n\n    properties.readyState = readyState;\n\n    const readyStateChangeEvent = new Event(\"readystatechange\");\n    xhr.dispatchEvent(readyStateChangeEvent);\n  }\n\n  function receiveResponse(xhr, response) {\n    const properties = xhr[xhrSymbols.properties];\n    const flag = xhr[xhrSymbols.flag];\n\n    const statusCode = response.statusCode;\n\n    if (flag.preflight && redirectStatuses.has(statusCode)) {\n      properties.error = \"Redirect after preflight forbidden\";\n      dispatchError(this);\n      return;\n    }\n\n    let byteOffset = 0;\n\n    const headers = {};\n    const filteredResponseHeaders = [];\n    const headerMap = {};\n    const rawHeaders = response.rawHeaders;\n    const n = Number(rawHeaders.length);\n    for (let i = 0; i < n; i += 2) {\n      const k = rawHeaders[i];\n      const kl = k.toLowerCase();\n      const v = rawHeaders[i + 1];\n      if (uniqueResponseHeaders.has(kl)) {\n        if (headerMap[kl] !== undefined) {\n          delete headers[headerMap[kl]];\n        }\n        headers[k] = v;\n      } else if (headerMap[kl] !== undefined) {\n        headers[headerMap[kl]] += \", \" + v;\n      } else {\n        headers[k] = v;\n      }\n      headerMap[kl] = k;\n    }\n\n    const destUrlObj = new URL(response.request.uri.href);\n    if (properties.origin !== destUrlObj.origin &&\n        destUrlObj.protocol !== \"data:\") {\n      if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n        return;\n      }\n      const acehStr = response.headers[\"access-control-expose-headers\"];\n      const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n      for (const header in headers) {\n        const lcHeader = header.toLowerCase();\n        if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n          filteredResponseHeaders.push(header);\n        }\n      }\n    }\n\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n      if (forbiddenResponseHeaders.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n\n    properties.responseURL = destUrlObj.href;\n\n    properties.status = statusCode;\n    properties.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n\n    properties.responseHeaders = headers;\n    properties.filteredResponseHeaders = filteredResponseHeaders;\n\n    const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n    const bufferLength = parseInt(contentLength) || 0;\n    const progressObj = { lengthComputable: false };\n    let lastProgressReported;\n    if (bufferLength !== 0) {\n      progressObj.total = bufferLength;\n      progressObj.loaded = 0;\n      progressObj.lengthComputable = true;\n    }\n    properties.responseBuffer = new Buffer(0);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n    readyStateChange(xhr, XMLHttpRequest.HEADERS_RECEIVED);\n\n    // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n    // Content-Length).\n    response.on(\"data\", chunk => {\n      byteOffset += chunk.length;\n      progressObj.loaded = byteOffset;\n    });\n\n    properties.client.on(\"data\", chunk => {\n      properties.responseBuffer = Buffer.concat([properties.responseBuffer, chunk]);\n      properties.responseCache = null;\n      properties.responseTextCache = null;\n      properties.responseXMLCache = null;\n\n      if (properties.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n        properties.readyState = XMLHttpRequest.LOADING;\n      }\n      xhr.dispatchEvent(new Event(\"readystatechange\"));\n\n      if (progressObj.total !== progressObj.loaded || properties.responseBuffer.length === byteOffset) {\n        if (lastProgressReported !== progressObj.loaded) {\n          // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n          // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n          lastProgressReported = progressObj.loaded;\n          xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n        }\n      }\n    });\n    properties.client.on(\"end\", () => {\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n      properties.client = null;\n      xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n      readyStateChange(xhr, XMLHttpRequest.DONE);\n      xhr.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n      xhr.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n    });\n  }\n\n  function setDispatchProgressEvents(xhr) {\n    const properties = xhr[xhrSymbols.properties];\n    const client = properties.client;\n    const upload = xhr.upload;\n\n    let total = 0;\n    let lengthComputable = false;\n    const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n    if (length) {\n      total = length;\n      lengthComputable = true;\n    }\n    const initProgress = {\n      lengthComputable,\n      total,\n      loaded: 0\n    };\n    upload.dispatchEvent(new ProgressEvent(\"loadstart\", initProgress));\n\n    client.on(\"request\", req => {\n      req.on(\"response\", () => {\n        properties.uploadComplete = true;\n        const progress = {\n          lengthComputable,\n          total,\n          loaded: total\n        };\n        upload.dispatchEvent(new ProgressEvent(\"progress\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"load\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"loadend\", progress));\n      });\n    });\n  }\n\n  function dispatchError(xhr) {\n    const properties = xhr[xhrSymbols.properties];\n    readyStateChange(xhr, XMLHttpRequest.DONE);\n    if (!properties.uploadComplete) {\n      xhr.upload.dispatchEvent(new ProgressEvent(\"error\"));\n      xhr.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n    }\n    xhr.dispatchEvent(new ProgressEvent(\"error\"));\n    xhr.dispatchEvent(new ProgressEvent(\"loadend\"));\n    if (xhr._ownerDocument) {\n      const error = new Error(properties.error);\n      error.type = \"XMLHttpRequest\";\n\n      xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n    }\n  }\n\n  function validCORSHeaders(xhr, response, flag, properties, origin) {\n    const acaoStr = response.headers[\"access-control-allow-origin\"];\n    const acao = acaoStr ? acaoStr.trim() : null;\n    if (acao !== \"*\" && acao !== origin) {\n      properties.error = \"Cross origin \" + origin + \" forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n    const acacStr = response.headers[\"access-control-allow-credentials\"];\n    const acac = acacStr ? acacStr.trim() : null;\n    if (flag.withCredentials && acac !== \"true\") {\n      properties.error = \"Credentials forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n    const acahStr = response.headers[\"access-control-allow-headers\"];\n    const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n    const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n      const lcHeader = header.toLowerCase();\n      return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n    });\n    if (forbiddenHeaders.length > 0) {\n      properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n    return true;\n  }\n\n  function toByteString(value) {\n    value = String(value);\n    if (!/^[\\0-\\xFF]*$/.test(value)) {\n      throw new TypeError(\"invalid ByteString\");\n    }\n    return value;\n  }\n\n  function getContentType(xhr) {\n    const flag = xhr[xhrSymbols.flag];\n    return parseContentType(flag.mimeType || getResponseHeader(xhr, \"content-type\"));\n  }\n\n  function getResponseHeader(xhr, lcHeader) {\n    const properties = xhr[xhrSymbols.properties];\n    const keys = Object.keys(properties.responseHeaders);\n    let n = keys.length;\n    while (n--) {\n      const key = keys[n];\n      if (key.toLowerCase() === lcHeader) {\n        return properties.responseHeaders[key];\n      }\n    }\n    return null;\n  }\n\n  function normalizeHeaderValue(value) {\n    return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n  }\n\n  return XMLHttpRequest;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/xhr-utils.js":"\"use strict\";\n\nconst request = require(\"request\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst fs = require(\"fs\");\nconst URL = require(\"whatwg-url\").URL;\n\nconst utils = require(\"../utils\");\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nfunction wrapCookieJarForRequest(cookieJar) {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n}\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\n\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.simpleHeaders = simpleHeaders;\n\n// return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\nexports.createClient = function createClient(xhr) {\n  const flag = xhr[xhrSymbols.flag];\n  const properties = xhr[xhrSymbols.properties];\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n\n  const requestManager = flag.requestManager;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = { uri: urlObj };\n    const filePath = urlObj.pathname\n      .replace(/^file:\\/\\//, \"\")\n      .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n      .replace(/%20/g, \" \");\n\n    const client = new EventEmitter();\n\n    const readableStream = fs.createReadStream(filePath, { encoding: null });\n\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n\n    readableStream.on(\"error\", err => {\n      response.emit(\"error\", err);\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response));\n\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n\n    response.request = { uri: urlObj };\n\n    const client = new EventEmitter();\n\n    let buffer;\n    if (ucMethod === \"GET\") {\n      try {\n        const dataUrlContent = utils.parseDataUrl(uri);\n        buffer = dataUrlContent.buffer;\n        response.statusCode = 200;\n        response.rawHeaders = dataUrlContent.type ? [\"Content-Type\", dataUrlContent.type] : [];\n        response.headers = dataUrlContent.type ? { \"content-type\": dataUrlContent.type } : {};\n      } catch (err) {\n        process.nextTick(() => client.emit(\"error\", err));\n        return client;\n      }\n    } else {\n      buffer = new Buffer(\"\");\n      response.statusCode = 0;\n      response.rawHeaders = {};\n      response.headers = {};\n    }\n\n    client.abort = () => {\n      // do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n\n    return client;\n  }\n\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    pool: flag.pool,\n    agentOptions: flag.agentOptions,\n    strictSSL: flag.strictSSL\n  };\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  if (flag.proxy) {\n    options.proxy = flag.proxy;\n  }\n\n  const body = flag.body;\n  const hasBody = body !== undefined &&\n    body !== null &&\n    body !== \"\" &&\n    !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      const client = request(options);\n\n      if (hasBody && flag.formData) {\n        const form = client.form();\n        for (const entry of body) {\n          form.append(entry.name, entry.value, entry.options);\n        }\n      }\n\n      return client;\n    } catch (e) {\n      const client = new EventEmitter();\n      process.nextTick(() => client.emit(\"error\", e));\n      return client;\n    }\n  }\n\n  let client;\n\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders)\n    .filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0)) {\n    client = new EventEmitter();\n\n    const preflightRequestHeaders = [];\n    for (const header in requestHeaders) {\n      preflightRequestHeaders[header] = requestHeaders[header];\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    flag.preflight = true;\n\n    const preflightOptions = {\n      uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      agentOptions: flag.agentOptions,\n      strictSSL: flag.strictSSL\n    };\n\n    if (flag.proxy) {\n      preflightOptions.proxy = flag.proxy;\n    }\n\n    const preflightClient = request(preflightOptions);\n\n    preflightClient.on(\"response\", resp => {\n      if (resp.statusCode >= 200 && resp.statusCode <= 299) {\n        const realClient = doRequest();\n        realClient.on(\"response\", res => client.emit(\"response\", res));\n        realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n        realClient.on(\"end\", () => client.emit(\"end\"));\n        realClient.on(\"abort\", () => client.emit(\"abort\"));\n        realClient.on(\"request\", req => {\n          client.headers = realClient.headers;\n          client.emit(\"request\", req);\n        });\n        realClient.on(\"redirect\", () => {\n          client.response = realClient.response;\n          client.emit(\"redirect\");\n        });\n        realClient.on(\"error\", err => client.emit(\"error\", err));\n        client.abort = () => {\n          realClient.abort();\n        };\n      } else {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n      }\n    });\n\n    preflightClient.on(\"error\", err => client.emit(\"error\", err));\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n};\n\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/xmlhttprequest-symbols.js":"\"use strict\";\n\nexports.flag = Symbol(\"flag\");\nexports.properties = Symbol(\"properties\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Document.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Node = require(\"./Node.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst GlobalEventHandlers = require(\"./GlobalEventHandlers.js\");\nconst NonElementParentNode = require(\"./NonElementParentNode.js\");\nconst ParentNode = require(\"./ParentNode.js\");\n\nfunction Document() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n\n  iface.setup(this, args);\n}\nDocument.prototype = Object.create(Node.interface.prototype);\nDocument.prototype.constructor = Document;\n\nmixin(Document.prototype, GlobalEventHandlers.interface.prototype);\nGlobalEventHandlers.mixedInto.push(Document);\nmixin(Document.prototype, NonElementParentNode.interface.prototype);\nNonElementParentNode.mixedInto.push(Document);\nmixin(Document.prototype, ParentNode.interface.prototype);\nParentNode.mixedInto.push(Document);\n\nDocument.prototype.getElementsByTagName = function getElementsByTagName(localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getElementsByTagName' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].getElementsByTagName.apply(this[impl], args));\n};\n\nDocument.prototype.getElementsByTagNameNS = function getElementsByTagNameNS(namespace, localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'getElementsByTagNameNS' on 'Document': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return utils.tryWrapperForImpl(this[impl].getElementsByTagNameNS.apply(this[impl], args));\n};\n\nDocument.prototype.getElementsByClassName = function getElementsByClassName(classNames) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getElementsByClassName' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].getElementsByClassName.apply(this[impl], args));\n};\n\nDocument.prototype.createElement = function createElement(localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'createElement' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].createElement.apply(this[impl], args));\n};\n\nDocument.prototype.createElementNS = function createElementNS(namespace, qualifiedName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'createElementNS' on 'Document': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return utils.tryWrapperForImpl(this[impl].createElementNS.apply(this[impl], args));\n};\n\nDocument.prototype.createDocumentFragment = function createDocumentFragment() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].createDocumentFragment.apply(this[impl], args));\n};\n\nDocument.prototype.createTextNode = function createTextNode(data) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'createTextNode' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].createTextNode.apply(this[impl], args));\n};\n\nDocument.prototype.createCDATASection = function createCDATASection(data) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'createCDATASection' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].createCDATASection.apply(this[impl], args));\n};\n\nDocument.prototype.createComment = function createComment(data) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'createComment' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].createComment.apply(this[impl], args));\n};\n\nDocument.prototype.createProcessingInstruction = function createProcessingInstruction(target, data) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'createProcessingInstruction' on 'Document': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return utils.tryWrapperForImpl(this[impl].createProcessingInstruction.apply(this[impl], args));\n};\n\nDocument.prototype.importNode = function importNode(node) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'importNode' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"boolean\"](args[1]);\n  } else {\n    args[1] = false;\n  }\n  return utils.tryWrapperForImpl(this[impl].importNode.apply(this[impl], args));\n};\n\nDocument.prototype.adoptNode = function adoptNode(node) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'adoptNode' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].adoptNode.apply(this[impl], args));\n};\n\nDocument.prototype.createAttribute = function createAttribute(localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'createAttribute' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].createAttribute.apply(this[impl], args));\n};\n\nDocument.prototype.createAttributeNS = function createAttributeNS(namespace, qualifiedName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'createAttributeNS' on 'Document': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return utils.tryWrapperForImpl(this[impl].createAttributeNS.apply(this[impl], args));\n};\n\nDocument.prototype.createEvent = function createEvent(_interface) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'createEvent' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].createEvent.apply(this[impl], args));\n};\n\nDocument.prototype.createTreeWalker = function createTreeWalker(root) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'createTreeWalker' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"unsigned long\"](args[1]);\n  } else {\n    args[1] = 4294967295;\n  }\n  if (args[2] === null || args[2] === undefined) {\n    args[2] = null;\n  } else {\n  }\n  return utils.tryWrapperForImpl(this[impl].createTreeWalker.apply(this[impl], args));\n};\n\nDocument.prototype.getElementsByName = function getElementsByName(elementName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getElementsByName' on 'Document': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].getElementsByName.apply(this[impl], args));\n};\n\nDocument.prototype.open = function open() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  } else {\n    args[0] = \"text/html\";\n  }\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"DOMString\"](args[1]);\n  } else {\n    args[1] = \"\";\n  }\n  return utils.tryWrapperForImpl(this[impl].open.apply(this[impl], args));\n};\n\nDocument.prototype.close = function close() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].close.apply(this[impl], args);\n};\n\nDocument.prototype.write = function write() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  return this[impl].write.apply(this[impl], args);\n};\n\nDocument.prototype.writeln = function writeln() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  return this[impl].writeln.apply(this[impl], args);\n};\n\nDocument.prototype.hasFocus = function hasFocus() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].hasFocus.apply(this[impl], args);\n};\n\nDocument.prototype.toString = function () {\n  if (this === Document.prototype) {\n    return \"[object DocumentPrototype]\";\n  }\n  return Node.interface.prototype.toString.call(this);\n};\nObject.defineProperty(Document.prototype, \"implementation\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].implementation);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"URL\", {\n  get() {\n    return this[impl].URL;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"documentURI\", {\n  get() {\n    return this[impl].documentURI;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"compatMode\", {\n  get() {\n    return this[impl].compatMode;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"characterSet\", {\n  get() {\n    return this[impl].characterSet;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"charset\", {\n  get() {\n    return this[impl].charset;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"inputEncoding\", {\n  get() {\n    return this[impl].inputEncoding;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"contentType\", {\n  get() {\n    return this[impl].contentType;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"doctype\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].doctype);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"documentElement\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].documentElement);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"referrer\", {\n  get() {\n    return this[impl].referrer;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"cookie\", {\n  get() {\n    return this[impl].cookie;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].cookie = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"lastModified\", {\n  get() {\n    return this[impl].lastModified;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"readyState\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].readyState);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"title\", {\n  get() {\n    return this[impl].title;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].title = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"body\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].body);\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    }\n    this[impl].body = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"head\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].head);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"images\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].images);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"embeds\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].embeds);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"plugins\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].plugins);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"links\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].links);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"forms\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].forms);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"scripts\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].scripts);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"currentScript\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].currentScript);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"defaultView\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].defaultView);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"activeElement\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].activeElement);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"onreadystatechange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onreadystatechange);\n  },\n  set(V) {\n    this[impl].onreadystatechange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"anchors\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].anchors);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"applets\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].applets);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"styleSheets\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].styleSheets);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"hidden\", {\n  get() {\n    return this[impl].hidden;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"visibilityState\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].visibilityState);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Document.prototype, \"onvisibilitychange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onvisibilitychange);\n  },\n  set(V) {\n    this[impl].onvisibilitychange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Document.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Document.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Node._internalSetup(obj);\n\n    Object.defineProperty(obj, \"location\", {\n      get() {\n        return utils.tryWrapperForImpl(obj[impl].location);\n      },\n      set(V) {\n        this.location.href = V;\n      },\n      enumerable: true,\n      configurable: false\n    });\n    \n    \n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Document,\n  expose: {\n    Window: { Document: Document }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/Document-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Node.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst EventTarget = require(\"./EventTarget.js\");\nconst impl = utils.implSymbol;\n\nfunction Node() {\n  throw new TypeError(\"Illegal constructor\");\n}\nNode.prototype = Object.create(EventTarget.interface.prototype);\nNode.prototype.constructor = Node;\n\n\nNode.prototype.hasChildNodes = function hasChildNodes() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].hasChildNodes.apply(this[impl], args);\n};\n\nNode.prototype.normalize = function normalize() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].normalize.apply(this[impl], args);\n};\n\nNode.prototype.cloneNode = function cloneNode() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"boolean\"](args[0]);\n  } else {\n    args[0] = false;\n  }\n  return utils.tryWrapperForImpl(this[impl].cloneNode.apply(this[impl], args));\n};\n\nNode.prototype.isEqualNode = function isEqualNode(otherNode) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'isEqualNode' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  }\n  return this[impl].isEqualNode.apply(this[impl], args);\n};\n\nNode.prototype.compareDocumentPosition = function compareDocumentPosition(other) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'compareDocumentPosition' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].compareDocumentPosition.apply(this[impl], args);\n};\n\nNode.prototype.contains = function contains(other) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'contains' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  }\n  return this[impl].contains.apply(this[impl], args);\n};\n\nNode.prototype.insertBefore = function insertBefore(node, child) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'insertBefore' on 'Node': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[1] === null || args[1] === undefined) {\n    args[1] = null;\n  } else {\n  }\n  return utils.tryWrapperForImpl(this[impl].insertBefore.apply(this[impl], args));\n};\n\nNode.prototype.appendChild = function appendChild(node) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'appendChild' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].appendChild.apply(this[impl], args));\n};\n\nNode.prototype.replaceChild = function replaceChild(node, child) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'replaceChild' on 'Node': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].replaceChild.apply(this[impl], args));\n};\n\nNode.prototype.removeChild = function removeChild(child) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'removeChild' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].removeChild.apply(this[impl], args));\n};\n\nNode.prototype.toString = function () {\n  if (this === Node.prototype) {\n    return \"[object NodePrototype]\";\n  }\n  return EventTarget.interface.prototype.toString.call(this);\n};\nObject.defineProperty(Node, \"ELEMENT_NODE\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"ELEMENT_NODE\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"ATTRIBUTE_NODE\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"ATTRIBUTE_NODE\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"TEXT_NODE\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"TEXT_NODE\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"CDATA_SECTION_NODE\", {\n  value: 4,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"CDATA_SECTION_NODE\", {\n  value: 4,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"ENTITY_REFERENCE_NODE\", {\n  value: 5,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"ENTITY_REFERENCE_NODE\", {\n  value: 5,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"ENTITY_NODE\", {\n  value: 6,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"ENTITY_NODE\", {\n  value: 6,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"PROCESSING_INSTRUCTION_NODE\", {\n  value: 7,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"PROCESSING_INSTRUCTION_NODE\", {\n  value: 7,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"COMMENT_NODE\", {\n  value: 8,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"COMMENT_NODE\", {\n  value: 8,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_NODE\", {\n  value: 9,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_NODE\", {\n  value: 9,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_TYPE_NODE\", {\n  value: 10,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_TYPE_NODE\", {\n  value: 10,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_FRAGMENT_NODE\", {\n  value: 11,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_FRAGMENT_NODE\", {\n  value: 11,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"NOTATION_NODE\", {\n  value: 12,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"NOTATION_NODE\", {\n  value: 12,\n  enumerable: true\n});\n\nObject.defineProperty(Node.prototype, \"nodeType\", {\n  get() {\n    return this[impl].nodeType;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"nodeName\", {\n  get() {\n    return this[impl].nodeName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"baseURI\", {\n  get() {\n    return this[impl].baseURI;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"ownerDocument\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ownerDocument);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"parentNode\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].parentNode);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"parentElement\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].parentElement);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"childNodes\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].childNodes);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"firstChild\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].firstChild);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"lastChild\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].lastChild);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"previousSibling\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].previousSibling);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"nextSibling\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].nextSibling);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"nodeValue\", {\n  get() {\n    return this[impl].nodeValue;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this[impl].nodeValue = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"textContent\", {\n  get() {\n    return this[impl].textContent;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this[impl].textContent = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_DISCONNECTED\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_DISCONNECTED\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_PRECEDING\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_PRECEDING\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_FOLLOWING\", {\n  value: 4,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_FOLLOWING\", {\n  value: 4,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_CONTAINS\", {\n  value: 8,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_CONTAINS\", {\n  value: 8,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_CONTAINED_BY\", {\n  value: 16,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_CONTAINED_BY\", {\n  value: 16,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\", {\n  value: 32,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\", {\n  value: 32,\n  enumerable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Node.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Node.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    EventTarget._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Node,\n  expose: {\n    Window: { Node: Node }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/Node-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/Node-impl.js":"\"use strict\";\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\n\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst simultaneousIterators = require(\"../../utils\").simultaneousIterators;\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst createLiveNodeList = require(\"../node-list\").createLive;\nconst updateNodeList = require(\"../node-list\").update;\nconst updateHTMLCollection = require(\"../html-collection\").update;\nconst documentBaseURLSerialized = require(\"../helpers/document-base-url\").documentBaseURLSerialized;\nconst cloneNode = require(\"../node\").clone;\nconst attributes = require(\"../attributes\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE ||\n    node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE ||\n    node.nodeType === NODE_TYPE.NOTATION_NODE ||\n//  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n    node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId ||\n          a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n          a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super();\n\n    domSymbolTree.initialize(this);\n\n    this._core = privateData.core;\n    this._ownerDocument = privateData.ownerDocument;\n\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n  }\n\n  get nodeValue() {\n    if (this.nodeType === NODE_TYPE.TEXT_NODE ||\n      this.nodeType === NODE_TYPE.COMMENT_NODE ||\n      this.nodeType === NODE_TYPE.CDATA_SECTION_NODE ||\n      this.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE) {\n      return this._data;\n    }\n\n    return null;\n  }\n\n  set nodeValue(value) {\n    if (this.nodeType === NODE_TYPE.TEXT_NODE ||\n      this.nodeType === NODE_TYPE.COMMENT_NODE ||\n      this.nodeType === NODE_TYPE.CDATA_SECTION_NODE ||\n      this.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE) {\n      this.replaceData(0, this.length, value);\n    }\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = createLiveNodeList(this, () => domSymbolTree.childrenToArray(this));\n    } else {\n      updateNodeList(this._childNodesList);\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  insertBefore(newChildImpl, refChildImpl) {\n    // TODO branding\n    if (!newChildImpl || !(newChildImpl instanceof NodeImpl)) {\n      throw new TypeError(\"First argument to Node.prototype.insertBefore must be a Node\");\n    }\n    if (refChildImpl !== null && !(refChildImpl instanceof NodeImpl)) {\n      throw new TypeError(\"Second argument to Node.prototype.insertBefore must be a Node or null or undefined\");\n    }\n\n    // DocumentType must be implicitly adopted\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      newChildImpl._ownerDocument = this._ownerDocument;\n    }\n\n    if (newChildImpl.nodeType && newChildImpl.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR);\n    }\n\n    if (this._ownerDocument !== newChildImpl._ownerDocument) {\n      // adopt the node when it's not in this document\n      this._ownerDocument.adoptNode(newChildImpl);\n    } else {\n      // search for parents matching the newChild\n      for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n        if (ancestor === newChildImpl) {\n          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR);\n        }\n      }\n    }\n\n    // fragments are merged into the element (except parser-created fragments in <template>)\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while ((grandChildImpl = domSymbolTree.firstChild(newChildImpl))) {\n        newChildImpl.removeChild(grandChildImpl);\n        this.insertBefore(grandChildImpl, refChildImpl);\n      }\n    } else if (newChildImpl === refChildImpl) {\n      return newChildImpl;\n    } else {\n      const oldParentImpl = domSymbolTree.parent(newChildImpl);\n      // if the newChild is already in the tree elsewhere, remove it first\n      if (oldParentImpl) {\n        oldParentImpl.removeChild(newChildImpl);\n      }\n\n      if (refChildImpl === null) {\n        domSymbolTree.appendChild(this, newChildImpl);\n      } else {\n        if (domSymbolTree.parent(refChildImpl) !== this) {\n          throw new DOMException(DOMException.NOT_FOUND_ERR);\n        }\n\n        domSymbolTree.insertBefore(refChildImpl, newChildImpl);\n      }\n\n      this._modified();\n\n      if (this._attached && newChildImpl._attach) {\n        newChildImpl._attach();\n      }\n\n      this._descendantAdded(this, newChildImpl);\n    }\n\n    return newChildImpl;\n  } // raises(DOMException);\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      updateHTMLCollection(this._childrenList);\n    }\n    if (this._childNodesList) {\n      updateNodeList(this._childNodesList);\n    }\n    this._clearMemoizedQueries();\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  replaceChild(node, child) {\n    if (arguments.length < 2) {\n      throw new TypeError(\"Not enough arguments to Node.prototype.replaceChild\");\n    }\n    // TODO branding\n    if (!node || !(node instanceof NodeImpl)) {\n      throw new TypeError(\"First argument to Node.prototype.replaceChild must be a Node\");\n    }\n    if (!child || !(child instanceof NodeImpl)) {\n      throw new TypeError(\"Second argument to Node.prototype.replaceChild must be a Node\");\n    }\n\n    this.insertBefore(node, child);\n    return this.removeChild(child);\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  removeChild(/* Node */ oldChildImpl) {\n    if (!oldChildImpl || domSymbolTree.parent(oldChildImpl) !== this) {\n      throw new DOMException(DOMException.NOT_FOUND_ERR);\n    }\n\n    const oldPreviousSibling = oldChildImpl.previousSibling;\n    domSymbolTree.remove(oldChildImpl);\n    this._modified();\n    oldChildImpl._detach();\n    this._descendantRemoved(this, oldChildImpl);\n    if (this._ownerDocument) {\n      this._ownerDocument._runRemovingSteps(oldChildImpl, this, oldPreviousSibling);\n    }\n    return oldChildImpl;\n  } // raises(DOMException);\n\n  appendChild(newChild) {\n    if (!(\"nodeType\" in newChild)) {\n      throw new TypeError(\"First argument to Node.prototype.appendChild must be a Node\");\n    }\n\n    return this.insertBefore(newChild, null);\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  normalize() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        continue;\n      }\n\n      const prevChild = domSymbolTree.previousSibling(child);\n\n      if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE && child.nodeType === NODE_TYPE.TEXT_NODE) {\n        // merge text nodes\n        prevChild.appendData(child.nodeValue);\n        this.removeChild(child);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(otherImpl) {\n    // Let reference be the context object.\n    const reference = this;\n\n    if (!(otherImpl instanceof NodeImpl)) {\n      throw new Error(\"Comparing position against non-Node values is not allowed\");\n    }\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    const result = domSymbolTree.compareTreePosition(reference, otherImpl);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  contains(other) {\n    if (!(other instanceof NodeImpl)) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  cloneNode(deep) {\n    deep = Boolean(deep);\n\n    return cloneNode(this._core, this, undefined, deep);\n  }\n\n  get textContent() {\n    let text;\n    switch (this.nodeType) {\n      case NODE_TYPE.COMMENT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE:\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.TEXT_NODE:\n        return this.nodeValue;\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        text = \"\";\n        for (const child of domSymbolTree.treeIterator(this)) {\n          if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            text += child.nodeValue;\n          }\n        }\n        return text;\n\n      default:\n        return null;\n    }\n  }\n\n  set textContent(txt) {\n    switch (this.nodeType) {\n      case NODE_TYPE.COMMENT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE:\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.TEXT_NODE:\n        this.nodeValue = String(txt);\n        return;\n    }\n\n    let child = domSymbolTree.firstChild(this);\n    while (child) {\n      this.removeChild(child);\n      child = domSymbolTree.firstChild(this);\n    }\n\n    if (txt !== \"\" && txt !== null) {\n      this.appendChild(this._ownerDocument.createTextNode(txt));\n    }\n  }\n\n  toString() {\n    const wrapper = idlUtils.wrapperForImpl(this);\n    return `[object ${wrapper.constructor.name}]`;\n  }\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/node-document-position.js":"\"use strict\";\n\nmodule.exports = Object.freeze({\n  DOCUMENT_POSITION_DISCONNECTED: 1,\n  DOCUMENT_POSITION_PRECEDING: 2,\n  DOCUMENT_POSITION_FOLLOWING: 4,\n  DOCUMENT_POSITION_CONTAINS: 8,\n  DOCUMENT_POSITION_CONTAINED_BY: 16,\n  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32\n});\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/node-list.js":"\"use strict\";\nconst lengthFromProperties = require(\"../utils\").lengthFromProperties;\nconst idlUtils = require(\"./generated/utils\");\n\nconst privates = Symbol(\"NodeList internal slots\");\n\nclass NodeList {\n  constructor(secret, config) {\n    if (secret !== privates) {\n      throw new TypeError(\"Invalid constructor\");\n    }\n\n    if (config.nodes) {\n      this[privates] = {\n        isLive: false,\n        length: config.nodes.length\n      };\n\n      for (let i = 0; i < config.nodes.length; ++i) {\n        this[i] = config.nodes[i];\n      }\n    } else {\n      this[privates] = {\n        isLive: true,\n        element: config.element,\n        query: config.query,\n        snapshot: undefined,\n        length: 0,\n        version: -1\n      };\n      updateNodeList(this);\n    }\n  }\n\n  get length() {\n    updateNodeList(this);\n    return this[privates].length;\n  }\n\n  item(index) {\n    updateNodeList(this);\n    return this[index] || null;\n  }\n\n  // TODO reimplement this in webidl2js so these become more per-spec\n  * keys() {\n    updateNodeList(this);\n    const length = this[privates].length;\n    for (let i = 0; i < length; ++i) {\n      yield i;\n    }\n  }\n\n  * entries() {\n    updateNodeList(this);\n    const length = this[privates].length;\n    for (let i = 0; i < length; ++i) {\n      yield [i, this[i]];\n    }\n  }\n\n  forEach(callback) {\n    const thisArg = arguments[1]; // TODO Node v6: use default arguments\n    let values = Array.from(this);\n    let i = 0;\n    while (i < values.length) {\n      callback.call(thisArg, values[i], i, this);\n      values = Array.from(this);\n      ++i;\n    }\n  }\n}\n\nNodeList.prototype[Symbol.iterator] = NodeList.prototype.values = Array.prototype[Symbol.iterator];\n\nfunction updateNodeList(nodeList) {\n  if (nodeList[privates].isLive) {\n    if (nodeList[privates].version < nodeList[privates].element._version) {\n      nodeList[privates].snapshot = nodeList[privates].query();\n      resetNodeListTo(nodeList, nodeList[privates].snapshot);\n      nodeList[privates].version = nodeList[privates].element._version;\n    }\n  } else {\n    nodeList[privates].length = lengthFromProperties(nodeList);\n  }\n}\n\nfunction resetNodeListTo(nodeList, nodes) {\n  const startingLength = lengthFromProperties(nodeList);\n  for (let i = 0; i < startingLength; ++i) {\n    delete nodeList[i];\n  }\n\n  for (let i = 0; i < nodes.length; ++i) {\n    const wrapper = idlUtils.wrapperForImpl(nodes[i]);\n    nodeList[i] = wrapper ? wrapper : nodes[i];\n  }\n  nodeList[privates].length = nodes.length;\n}\n\nmodule.exports = function (core) {\n  core.NodeList = NodeList;\n};\n\nmodule.exports.createLive = function (element, query) {\n  return new NodeList(privates, { element, query });\n};\n\nmodule.exports.createStatic = function (nodes) {\n  return new NodeList(privates, { nodes });\n};\n\nmodule.exports.update = updateNodeList;\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/node.js":"\"use strict\";\nconst attributes = require(\"./attributes\");\nconst cloningSteps = require(\"./helpers/internal-constants\").cloningSteps;\nconst domSymbolTree = require(\"./helpers/internal-constants\").domSymbolTree;\nconst NODE_TYPE = require(\"./node-type\");\nconst orderedSetParser = require(\"./helpers/ordered-set-parser\");\nconst createHTMLCollection = require(\"./html-collection\").create;\nconst domTokenListContains = require(\"./dom-token-list\").contains;\n\nmodule.exports.clone = function (core, node, document, cloneChildren) {\n  if (document === undefined) {\n    document = node._ownerDocument;\n  }\n\n  let copy;\n  switch (node.nodeType) {\n    case NODE_TYPE.DOCUMENT_NODE:\n      // TODO: just use Document when we eliminate the difference between Document and HTMLDocument.\n      if (node.contentType === \"text/html\") { // need to differentiate due to parsing mode\n        copy = document.implementation.createHTMLDocument();\n        copy.removeChild(copy.documentElement); // ;_;\n      } else {\n        copy = document.implementation.createDocument(\"\", \"\", null);\n      }\n      document = copy;\n      break;\n\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      copy = document.implementation.createDocumentType(node.name, node.publicId, node.systemId);\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      copy = document._createElementWithCorrectElementInterface(node._localName, node._namespaceURI);\n      copy._namespaceURI = node._namespaceURI;\n      copy._prefix = node._prefix;\n      copy._localName = node._localName;\n      attributes.copyAttributeList(node, copy);\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n      copy = document.createTextNode(node._data);\n      break;\n\n    case NODE_TYPE.CDATA_SECTION_NODE:\n      copy = document.createCDATASection(node._data);\n      break;\n\n    case NODE_TYPE.COMMENT_NODE:\n      copy = document.createComment(node._data);\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      copy = document.createProcessingInstruction(node.target, node._data);\n      break;\n\n    case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      copy = document.createDocumentFragment();\n      break;\n  }\n\n  if (node[cloningSteps]) {\n    node[cloningSteps](copy, node, document, cloneChildren);\n  }\n\n  if (cloneChildren) {\n    for (const child of domSymbolTree.childrenIterator(node)) {\n      const childCopy = module.exports.clone(core, child, document, true);\n      copy.appendChild(childCopy);\n    }\n  }\n\n  return copy;\n};\n\n// For the following, memoization is not applied here since the memoized results are stored on `this`.\n\nmodule.exports.listOfElementsWithClassNames = (classNames, root) => {\n  // https://dom.spec.whatwg.org/#concept-getElementsByClassName\n\n  const classes = orderedSetParser(classNames);\n\n  if (classes.size === 0) {\n    return createHTMLCollection(root, () => []);\n  }\n\n  return createHTMLCollection(root, () => {\n    const isQuirksMode = root._ownerDocument.compatMode === \"BackCompat\";\n\n    return domSymbolTree.treeToArray(root, { filter(node) {\n      if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n        return false;\n      }\n\n      for (const className of classes) {\n        if (!domTokenListContains(node.classList, className, { caseInsensitive: isQuirksMode })) {\n          return false;\n        }\n      }\n\n      return true;\n    } });\n  });\n};\n\nmodule.exports.listOfElementsWithQualifiedName = (qualifiedName, root) => {\n  // https://dom.spec.whatwg.org/#concept-getelementsbytagname\n\n  if (qualifiedName === \"*\") {\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        return node.nodeType === NODE_TYPE.ELEMENT_NODE && node !== root;\n      } });\n    });\n  }\n\n  if (root._ownerDocument._parsingMode === \"html\") {\n    const lowerQualifiedName = qualifiedName.toLowerCase();\n\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        if (node._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n          return node._qualifiedName === lowerQualifiedName;\n        }\n\n        return node._qualifiedName === qualifiedName;\n      } });\n    });\n  }\n\n  return createHTMLCollection(root, () => {\n    return domSymbolTree.treeToArray(root, { filter(node) {\n      if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n        return false;\n      }\n\n      return node._qualifiedName === qualifiedName;\n    } });\n  });\n};\n\nmodule.exports.listOfElementsWithNamespaceAndLocalName = (namespace, localName, root) => {\n  // https://dom.spec.whatwg.org/#concept-getelementsbytagnamens\n\n  if (namespace === \"\") {\n    namespace = null;\n  }\n\n  if (namespace === \"*\" && localName === \"*\") {\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        return node.nodeType === NODE_TYPE.ELEMENT_NODE && node !== root;\n      } });\n    });\n  }\n\n  if (namespace === \"*\") {\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        return node._localName === localName;\n      } });\n    });\n  }\n\n  if (localName === \"*\") {\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        return node._namespaceURI === namespace;\n      } });\n    });\n  }\n\n  return createHTMLCollection(root, () => {\n    return domSymbolTree.treeToArray(root, { filter(node) {\n      if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n        return false;\n      }\n\n      return node._localName === localName && node._namespaceURI === namespace;\n    } });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/ordered-set-parser.js":"\"use strict\";\n\nmodule.exports = function orderedSetParser(input) {\n  return new Set(input.split(/[\\t\\n\\f\\r ]+/).filter(Boolean));\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/dom-token-list.js":"\"use strict\";\n\nconst DOMException = require(\"../web-idl/DOMException\");\nconst orderedSetParser = require(\"./helpers/ordered-set-parser\");\n\n// https://dom.spec.whatwg.org/#domtokenlist\n\nconst INTERNAL = Symbol(\"DOMTokenList internal\");\n\nclass DOMTokenList {\n  constructor() {\n    throw new TypeError(\"Illegal constructor\");\n  }\n\n  item(index) {\n    const length = this.length;\n    return length <= index || index < 0 ? null : this[index];\n  }\n\n  contains(token) {\n    token = String(token);\n    return indexOf(this, token) !== -1;\n  }\n\n  replace(token, newToken) {\n    token = String(token);\n    newToken = String(newToken);\n    validateTokens(token, newToken);\n    const tokenIndex = indexOf(this, token);\n    if (tokenIndex === -1) {\n      return;\n    }\n    const newTokenIndex = indexOf(this, newToken);\n    if (newTokenIndex !== -1) {\n      spliceLite(this, newTokenIndex, 1);\n    }\n    this[INTERNAL].tokens[tokenIndex] = newToken;\n    update(this);\n  }\n\n  add(/* tokens... */) {\n    for (let i = 0; i < arguments.length; i++) {\n      const token = String(arguments[i]);\n      validateTokens(token);\n\n      if (indexOf(this, token) === -1) {\n        push(this, token);\n      }\n    }\n    update(this);\n  }\n\n  remove(/* tokens... */) {\n    for (let i = 0; i < arguments.length; i++) {\n      const token = String(arguments[i]);\n      validateTokens(token);\n\n      const index = indexOf(this, token);\n      if (index !== -1) {\n        spliceLite(this, index, 1);\n      }\n    }\n    update(this);\n  }\n\n  // if force is true, this behaves like add\n  // if force is false, this behaves like remove\n  // if force is undefined, this behaves as one would expect toggle to\n  // always returns whether classList contains token after toggling\n  toggle(token, force) {\n    token = String(token);\n    force = force === undefined ? undefined : Boolean(force);\n\n    validateTokens(token);\n\n    const index = indexOf(this, token);\n\n    if (index !== -1) {\n      if (force === false || force === undefined) {\n        spliceLite(this, index, 1);\n        update(this);\n        return false;\n      }\n\n      return true;\n    }\n\n    if (force === false) {\n      return false;\n    }\n\n    push(this, token);\n    update(this);\n    return true;\n  }\n\n  get length() {\n    return this[INTERNAL].tokens.length;\n  }\n\n  get value() {\n    return serialize(this);\n  }\n\n  set value(v) {\n    this[INTERNAL].element.setAttribute(this[INTERNAL].attribute, v);\n  }\n\n  toString() {\n    return serialize(this);\n  }\n}\n\nfunction serialize(list) {\n  const value = list[INTERNAL].element.getAttribute(list[INTERNAL].attribute);\n  return value === null ? \"\" : value;\n}\n\nfunction validateTokens(/* tokens... */) {\n  for (let i = 0; i < arguments.length; i++) {\n    const token = String(arguments[i]);\n    if (token === \"\") {\n      throw new DOMException(DOMException.SYNTAX_ERR, \"The token provided must not be empty.\");\n    }\n  }\n  for (let i = 0; i < arguments.length; i++) {\n    const token = String(arguments[i]);\n    if (/\\s/.test(token)) {\n      const whitespaceMsg = \"The token provided contains HTML space characters, which are not valid in tokens.\";\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR, whitespaceMsg);\n    }\n  }\n}\n\nfunction update(list) {\n  const attribute = list[INTERNAL].attribute;\n  list[INTERNAL].element.setAttribute(attribute, list[INTERNAL].tokens.join(\" \"));\n}\n\n// calls indexOf on internal array\nfunction indexOf(dtl, token) {\n  return dtl[INTERNAL].tokens.indexOf(token);\n}\n\n// calls push on internal array, then manually adds indexed property to dtl\nfunction push(dtl, token) {\n  const len = dtl[INTERNAL].tokens.push(token);\n  dtl[len - 1] = token;\n\n  return len;\n}\n\n// calls splice on internal array then rewrites indexed properties of dtl\n// does not allow items to be added, only removed, so splice-lite\nfunction spliceLite(dtl, start, deleteCount) {\n  const tokens = dtl[INTERNAL].tokens;\n  const removedTokens = tokens.splice(start, deleteCount);\n\n  // remove indexed properties from list\n  const re = /^\\d+$/;\n\n  for (const prop in dtl) {\n    if (re.test(prop)) {\n      delete dtl[prop];\n    }\n  }\n\n  // copy indexed properties from internal array\n  const len = tokens.length;\n\n  for (let i = 0; i < len; i++) {\n    dtl[i] = tokens[i];\n  }\n\n  return removedTokens;\n}\n\nexports.DOMTokenList = DOMTokenList;\n\n// set dom token list without running update steps\nexports.reset = function resetDOMTokenList(list, value) {\n  const tokens = list[INTERNAL].tokens;\n\n  spliceLite(list, 0, tokens.length);\n\n  if (value) {\n    for (const token of orderedSetParser(value)) {\n      push(list, token);\n    }\n  }\n};\n\nexports.create = function createDOMTokenList(element, attribute) {\n  const list = Object.create(DOMTokenList.prototype);\n\n  list[INTERNAL] = {\n    element,\n    attribute,\n    tokens: []\n  };\n\n  exports.reset(list, element.getAttribute(attribute));\n\n  return list;\n};\n\nexports.contains = function domTokenListContains(list, token, options) {\n  const caseInsensitive = options && options.caseInsensitive;\n\n  if (!caseInsensitive) {\n    return indexOf(list, token) !== -1;\n  }\n\n  const tokens = list[INTERNAL].tokens;\n  const lowerToken = token.toLowerCase();\n  for (let i = 0; i < tokens.length; ++i) {\n    if (tokens[i].toLowerCase() === lowerToken) {\n      return true;\n    }\n  }\n  return false;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/GlobalEventHandlers.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction GlobalEventHandlers() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nGlobalEventHandlers.prototype.toString = function () {\n  if (this === GlobalEventHandlers.prototype) {\n    return \"[object GlobalEventHandlersPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(GlobalEventHandlers.prototype, \"onabort\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onabort);\n  },\n  set(V) {\n    this[impl].onabort = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onautocomplete\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onautocomplete);\n  },\n  set(V) {\n    this[impl].onautocomplete = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onautocompleteerror\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onautocompleteerror);\n  },\n  set(V) {\n    this[impl].onautocompleteerror = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onblur\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onblur);\n  },\n  set(V) {\n    this[impl].onblur = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"oncancel\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].oncancel);\n  },\n  set(V) {\n    this[impl].oncancel = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"oncanplay\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].oncanplay);\n  },\n  set(V) {\n    this[impl].oncanplay = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"oncanplaythrough\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].oncanplaythrough);\n  },\n  set(V) {\n    this[impl].oncanplaythrough = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onchange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onchange);\n  },\n  set(V) {\n    this[impl].onchange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onclick\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onclick);\n  },\n  set(V) {\n    this[impl].onclick = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onclose\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onclose);\n  },\n  set(V) {\n    this[impl].onclose = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"oncontextmenu\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].oncontextmenu);\n  },\n  set(V) {\n    this[impl].oncontextmenu = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"oncuechange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].oncuechange);\n  },\n  set(V) {\n    this[impl].oncuechange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondblclick\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondblclick);\n  },\n  set(V) {\n    this[impl].ondblclick = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondrag\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondrag);\n  },\n  set(V) {\n    this[impl].ondrag = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondragend\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondragend);\n  },\n  set(V) {\n    this[impl].ondragend = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondragenter\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondragenter);\n  },\n  set(V) {\n    this[impl].ondragenter = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondragexit\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondragexit);\n  },\n  set(V) {\n    this[impl].ondragexit = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondragleave\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondragleave);\n  },\n  set(V) {\n    this[impl].ondragleave = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondragover\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondragover);\n  },\n  set(V) {\n    this[impl].ondragover = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondragstart\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondragstart);\n  },\n  set(V) {\n    this[impl].ondragstart = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondrop\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondrop);\n  },\n  set(V) {\n    this[impl].ondrop = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ondurationchange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ondurationchange);\n  },\n  set(V) {\n    this[impl].ondurationchange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onemptied\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onemptied);\n  },\n  set(V) {\n    this[impl].onemptied = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onended\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onended);\n  },\n  set(V) {\n    this[impl].onended = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onerror\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onerror);\n  },\n  set(V) {\n    this[impl].onerror = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onfocus\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onfocus);\n  },\n  set(V) {\n    this[impl].onfocus = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"oninput\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].oninput);\n  },\n  set(V) {\n    this[impl].oninput = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"oninvalid\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].oninvalid);\n  },\n  set(V) {\n    this[impl].oninvalid = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onkeydown\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onkeydown);\n  },\n  set(V) {\n    this[impl].onkeydown = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onkeypress\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onkeypress);\n  },\n  set(V) {\n    this[impl].onkeypress = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onkeyup\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onkeyup);\n  },\n  set(V) {\n    this[impl].onkeyup = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onload\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onload);\n  },\n  set(V) {\n    this[impl].onload = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onloadeddata\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onloadeddata);\n  },\n  set(V) {\n    this[impl].onloadeddata = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onloadedmetadata\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onloadedmetadata);\n  },\n  set(V) {\n    this[impl].onloadedmetadata = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onloadstart\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onloadstart);\n  },\n  set(V) {\n    this[impl].onloadstart = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onmousedown\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onmousedown);\n  },\n  set(V) {\n    this[impl].onmousedown = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onmouseenter\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onmouseenter);\n  },\n  set(V) {\n    this[impl].onmouseenter = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onmouseleave\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onmouseleave);\n  },\n  set(V) {\n    this[impl].onmouseleave = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onmousemove\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onmousemove);\n  },\n  set(V) {\n    this[impl].onmousemove = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onmouseout\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onmouseout);\n  },\n  set(V) {\n    this[impl].onmouseout = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onmouseover\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onmouseover);\n  },\n  set(V) {\n    this[impl].onmouseover = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onmouseup\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onmouseup);\n  },\n  set(V) {\n    this[impl].onmouseup = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onwheel\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onwheel);\n  },\n  set(V) {\n    this[impl].onwheel = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onpause\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onpause);\n  },\n  set(V) {\n    this[impl].onpause = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onplay\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onplay);\n  },\n  set(V) {\n    this[impl].onplay = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onplaying\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onplaying);\n  },\n  set(V) {\n    this[impl].onplaying = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onprogress\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onprogress);\n  },\n  set(V) {\n    this[impl].onprogress = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onratechange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onratechange);\n  },\n  set(V) {\n    this[impl].onratechange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onreset\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onreset);\n  },\n  set(V) {\n    this[impl].onreset = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onresize\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onresize);\n  },\n  set(V) {\n    this[impl].onresize = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onscroll\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onscroll);\n  },\n  set(V) {\n    this[impl].onscroll = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onseeked\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onseeked);\n  },\n  set(V) {\n    this[impl].onseeked = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onseeking\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onseeking);\n  },\n  set(V) {\n    this[impl].onseeking = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onselect\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onselect);\n  },\n  set(V) {\n    this[impl].onselect = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onshow\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onshow);\n  },\n  set(V) {\n    this[impl].onshow = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onsort\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onsort);\n  },\n  set(V) {\n    this[impl].onsort = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onstalled\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onstalled);\n  },\n  set(V) {\n    this[impl].onstalled = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onsubmit\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onsubmit);\n  },\n  set(V) {\n    this[impl].onsubmit = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onsuspend\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onsuspend);\n  },\n  set(V) {\n    this[impl].onsuspend = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ontimeupdate\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ontimeupdate);\n  },\n  set(V) {\n    this[impl].ontimeupdate = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"ontoggle\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ontoggle);\n  },\n  set(V) {\n    this[impl].ontoggle = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onvolumechange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onvolumechange);\n  },\n  set(V) {\n    this[impl].onvolumechange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(GlobalEventHandlers.prototype, \"onwaiting\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onwaiting);\n  },\n  set(V) {\n    this[impl].onwaiting = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(GlobalEventHandlers.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(GlobalEventHandlers.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: GlobalEventHandlers,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/GlobalEventHandlers-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/GlobalEventHandlers-impl.js":"\"use strict\";\n\nclass GlobalEventHandlersImpl { }\n\nmodule.exports = {\n  implementation: GlobalEventHandlersImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/NonElementParentNode.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction NonElementParentNode() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nNonElementParentNode.prototype.getElementById = function getElementById(elementId) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getElementById' on 'NonElementParentNode': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].getElementById.apply(this[impl], args));\n};\n\nNonElementParentNode.prototype.toString = function () {\n  if (this === NonElementParentNode.prototype) {\n    return \"[object NonElementParentNodePrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(NonElementParentNode.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(NonElementParentNode.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: NonElementParentNode,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/NonElementParentNode-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/NonElementParentNode-impl.js":"\"use strict\";\n\nclass NonElementParentNodeImpl {\n\n}\n\nmodule.exports = {\n  implementation: NonElementParentNodeImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ParentNode.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction ParentNode() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nParentNode.prototype.querySelector = function querySelector(selectors) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'querySelector' on 'ParentNode': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].querySelector.apply(this[impl], args));\n};\n\nParentNode.prototype.querySelectorAll = function querySelectorAll(selectors) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'querySelectorAll' on 'ParentNode': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].querySelectorAll.apply(this[impl], args));\n};\n\nParentNode.prototype.toString = function () {\n  if (this === ParentNode.prototype) {\n    return \"[object ParentNodePrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(ParentNode.prototype, \"children\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].children);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ParentNode.prototype, \"firstElementChild\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].firstElementChild);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ParentNode.prototype, \"lastElementChild\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].lastElementChild);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ParentNode.prototype, \"childElementCount\", {\n  get() {\n    return this[impl].childElementCount;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(ParentNode.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(ParentNode.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: ParentNode,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/ParentNode-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/ParentNode-impl.js":"\"use strict\";\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst nwmatcher = require(\"nwmatcher/src/nwmatcher-noqsa\");\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst NODE_TYPE = require(\"../node-type\");\nconst createHTMLCollection = require(\"../html-collection\").create;\nconst updateHTMLCollection = require(\"../html-collection\").update;\nconst memoizeQuery = require(\"../../utils\").memoizeQuery;\nconst createStaticNodeList = require(\"../node-list\").createStatic;\n\n// nwmatcher gets `document.documentElement` at creation-time, so we have to initialize lazily, since in the initial\n// stages of Document initialization, there is no documentElement present yet.\nfunction addNwmatcher(parentNode) {\n  const document = parentNode._ownerDocument;\n\n  if (!document._nwmatcher) {\n    document._nwmatcher = nwmatcher({ document });\n    document._nwmatcher.configure({ UNIQUE_ID: false });\n  }\n\n  return document._nwmatcher;\n}\n\nclass ParentNodeImpl {\n  get children() {\n    if (!this._childrenList) {\n      this._childrenList = createHTMLCollection(this, () => {\n        return domSymbolTree.childrenToArray(this, { filter(node) {\n          return node.nodeType === NODE_TYPE.ELEMENT_NODE;\n        } });\n      });\n    } else {\n      updateHTMLCollection(this._childrenList);\n    }\n    return this._childrenList;\n  }\n\n  get firstElementChild() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        return child;\n      }\n    }\n\n    return null;\n  }\n\n  get lastElementChild() {\n    for (const child of domSymbolTree.childrenIterator(this, { reverse: true })) {\n      if (child.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        return child;\n      }\n    }\n\n    return null;\n  }\n\n  get childElementCount() {\n    return this.children.length;\n  }\n}\n\nParentNodeImpl.prototype.querySelector = memoizeQuery(function (selectors) {\n  const matcher = addNwmatcher(this);\n\n  try {\n    return matcher.first(selectors, idlUtils.wrapperForImpl(this));\n  } catch (e) {\n    throw new DOMException(DOMException.SYNTAX_ERR, e.message);\n  }\n});\n\nParentNodeImpl.prototype.querySelectorAll = memoizeQuery(function (selectors) {\n  const matcher = addNwmatcher(this);\n\n  let list;\n  try {\n    list = matcher.select(selectors, idlUtils.wrapperForImpl(this));\n  } catch (e) {\n    throw new DOMException(DOMException.SYNTAX_ERR, e.message);\n  }\n\n  return createStaticNodeList(list);\n});\n\nmodule.exports = {\n  implementation: ParentNodeImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/Document-impl.js":"\"use strict\";\n\nconst CookieJar = require(\"tough-cookie\").CookieJar;\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst isNodeImpl = require(\"../generated/Node\").isImpl;\n\nconst NODE_TYPE = require(\"../node-type\");\nconst memoizeQuery = require(\"../../utils\").memoizeQuery;\nconst firstChildWithHTMLLocalName = require(\"../helpers/traversal\").firstChildWithHTMLLocalName;\nconst firstChildWithHTMLLocalNames = require(\"../helpers/traversal\").firstChildWithHTMLLocalNames;\nconst firstDescendantWithHTMLLocalName = require(\"../helpers/traversal\").firstDescendantWithHTMLLocalName;\nconst whatwgURL = require(\"whatwg-url\");\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst stripAndCollapseASCIIWhitespace = require(\"../helpers/strings\").stripAndCollapseASCIIWhitespace;\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst HtmlToDom = require(\"../../browser/htmltodom\").HtmlToDom;\nconst History = require(\"../generated/History\");\nconst Location = require(\"../generated/Location\");\nconst createHTMLCollection = require(\"../html-collection\").create;\nconst idlUtils = require(\"../generated/utils\");\nconst validateName = require(\"../helpers/validate-names\").name;\nconst validateAndExtract = require(\"../helpers/validate-names\").validateAndExtract;\nconst resourceLoader = require(\"../../browser/resource-loader\");\n\nconst clone = require(\"../node\").clone;\nconst generatedAttr = require(\"../generated/Attr\");\nconst listOfElementsWithQualifiedName = require(\"../node\").listOfElementsWithQualifiedName;\nconst listOfElementsWithNamespaceAndLocalName = require(\"../node\").listOfElementsWithNamespaceAndLocalName;\nconst listOfElementsWithClassNames = require(\"../node\").listOfElementsWithClassNames;\nconst Comment = require(\"../generated/Comment\");\nconst ProcessingInstruction = require(\"../generated/ProcessingInstruction\");\nconst CDATASection = require(\"../generated/CDATASection\");\nconst Text = require(\"../generated/Text\");\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\nconst DOMImplementation = require(\"../generated/DOMImplementation\");\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\nconst HTMLElement = require(\"../generated/HTMLElement\");\nconst HTMLUnknownElement = require(\"../generated/HTMLUnknownElement\");\nconst TreeWalker = require(\"../generated/TreeWalker\");\n\nconst CustomEvent = require(\"../generated/CustomEvent\");\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\nconst Event = require(\"../generated/Event\");\nconst FocusEvent = require(\"../generated/FocusEvent\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent\");\nconst KeyboardEvent = require(\"../generated/KeyboardEvent\");\nconst MessageEvent = require(\"../generated/MessageEvent\");\nconst MouseEvent = require(\"../generated/MouseEvent\");\nconst PopStateEvent = require(\"../generated/PopStateEvent\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst TouchEvent = require(\"../generated/TouchEvent\");\nconst UIEvent = require(\"../generated/UIEvent\");\n\nfunction clearChildNodes(node) {\n  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction setInnerHTML(document, node, html) {\n  // Clear the children first:\n  if (node._templateContents) {\n    clearChildNodes(node._templateContents);\n  } else {\n    clearChildNodes(node);\n  }\n\n  if (html !== \"\") {\n    if (node.nodeName === \"#document\") {\n      document._htmlToDom.appendHtmlToDocument(html, node);\n    } else {\n      document._htmlToDom.appendHtmlToElement(html, node);\n    }\n  }\n}\n\nclass ResourceQueue {\n  constructor(paused) {\n    this.paused = Boolean(paused);\n  }\n\n  push(callback) {\n    const q = this;\n    const item = {\n      prev: q.tail,\n      check() {\n        if (!q.paused && !this.prev && this.fired) {\n          callback(this.err, this.data, this.response);\n          if (this.next) {\n            this.next.prev = null;\n            this.next.check();\n          } else { // q.tail===this\n            q.tail = null;\n          }\n        }\n      }\n    };\n    if (q.tail) {\n      q.tail.next = item;\n    }\n    q.tail = item;\n    return (err, data, response) => {\n      item.fired = 1;\n      item.err = err;\n      item.data = data;\n      item.response = response;\n      item.check();\n    };\n  }\n\n  resume() {\n    if (!this.paused) {\n      return;\n    }\n    this.paused = false;\n\n    let head = this.tail;\n    while (head && head.prev) {\n      head = head.prev;\n    }\n    if (head) {\n      head.check();\n    }\n  }\n}\n\nclass RequestManager {\n  constructor() {\n    this.openedRequests = [];\n  }\n\n  add(req) {\n    this.openedRequests.push(req);\n  }\n\n  remove(req) {\n    const idx = this.openedRequests.indexOf(req);\n    if (idx !== -1) {\n      this.openedRequests.splice(idx, 1);\n    }\n  }\n\n  close() {\n    for (const openedRequest of this.openedRequests) {\n      openedRequest.abort();\n    }\n    this.openedRequests = [];\n  }\n\n  size() {\n    return this.openedRequests.length;\n  }\n}\n\nfunction pad(number) {\n  if (number < 10) {\n    return \"0\" + number;\n  }\n  return number;\n}\n\nfunction toLastModifiedString(date) {\n  return pad(date.getMonth() + 1) +\n    \"/\" + pad(date.getDate()) +\n    \"/\" + date.getFullYear() +\n    \" \" + pad(date.getHours()) +\n    \":\" + pad(date.getMinutes()) +\n    \":\" + pad(date.getSeconds());\n}\n\nconst nonInheritedTags = new Set([\n  \"article\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"address\", \"dt\",\n  \"dd\", \"figure\", \"figcaption\", \"main\", \"em\", \"strong\", \"small\", \"s\", \"cite\", \"dfn\", \"abbr\",\n  \"ruby\", \"rt\", \"rp\", \"code\", \"var\", \"samp\", \"kbd\", \"i\", \"b\", \"u\", \"mark\", \"bdi\", \"bdo\", \"wbr\"\n]);\n\nconst eventInterfaceTable = {\n  customevent: CustomEvent,\n  errorevent: ErrorEvent,\n  event: Event,\n  events: Event,\n  focusevent: FocusEvent,\n  hashchangeevent: HashChangeEvent,\n  htmlevents: Event,\n  keyboardevent: KeyboardEvent,\n  messageevent: MessageEvent,\n  mouseevent: MouseEvent,\n  mouseevents: MouseEvent,\n  popstateevent: PopStateEvent,\n  progressevent: ProgressEvent,\n  svgevents: Event,\n  touchevent: TouchEvent,\n  uievent: UIEvent,\n  uievents: UIEvent\n};\n\nclass DocumentImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._ownerDocument = this;\n    this.nodeType = NODE_TYPE.DOCUMENT_NODE;\n    if (!privateData.options) {\n      privateData.options = {};\n    }\n    if (!privateData.options.parsingMode) {\n      privateData.options.parsingMode = \"xml\";\n    }\n\n    this._parsingMode = privateData.options.parsingMode;\n    this._htmlToDom = new HtmlToDom(privateData.core, privateData.options.parser, privateData.options.parsingMode);\n\n    this._implementation = DOMImplementation.createImpl([], {\n      core: this._core,\n      ownerDocument: this\n    });\n\n    this._defaultView = privateData.options.defaultView || null;\n    this._global = privateData.options.global;\n    this._documentElement = null;\n    this._ids = Object.create(null);\n    this._attached = true;\n    this._currentScript = null;\n    this._cookieJar = privateData.options.cookieJar;\n    if (this._cookieJar === undefined) {\n      this._cookieJar = new CookieJar(null, { looseMode: true });\n    }\n\n    this._contentType = privateData.options.contentType;\n    this._encoding = privateData.options.encoding;\n\n    const urlOption = privateData.options.url === undefined ? \"about:blank\" : privateData.options.url;\n    const parsed = whatwgURL.parseURL(urlOption);\n    if (parsed === \"failure\") {\n      throw new TypeError(`Could not parse \"${urlOption}\" as a URL`);\n    }\n\n    this._URL = parsed;\n    this._origin = whatwgURL.serializeURLToUnicodeOrigin(parsed);\n\n    this._location = Location.createImpl([], { relevantDocument: this });\n    this._history = History.createImpl([], {\n      window: this._defaultView,\n      document: this,\n      actAsIfLocationReloadCalled: () => this._location.reload()\n    });\n\n    if (privateData.options.cookie) {\n      const cookies = Array.isArray(privateData.options.cookie) ?\n        privateData.options.cookie : [privateData.options.cookie];\n      const document = this;\n\n      cookies.forEach(cookieStr => {\n        document._cookieJar.setCookieSync(cookieStr, document.URL, { ignoreError: true });\n      });\n    }\n\n    this._activeNodeIterators = [];\n    this._activeNodeIteratorsMax = privateData.options.concurrentNodeIterators === undefined ?\n                                  10 :\n                                  Number(privateData.options.concurrentNodeIterators);\n\n    if (isNaN(this._activeNodeIteratorsMax)) {\n      throw new TypeError(\"The 'concurrentNodeIterators' option must be a Number\");\n    }\n\n    if (this._activeNodeIteratorsMax < 0) {\n      throw new RangeError(\"The 'concurrentNodeIterators' option must be a non negative Number\");\n    }\n\n    this._referrer = privateData.options.referrer || \"\";\n    this._lastModified = toLastModifiedString(privateData.options.lastModified || new Date());\n    this._queue = new ResourceQueue(privateData.options.deferClose);\n    this._customResourceLoader = privateData.options.resourceLoader;\n    this._pool = privateData.options.pool;\n    this._agentOptions = privateData.options.agentOptions;\n    this._strictSSL = privateData.options.strictSSL;\n    this._proxy = privateData.options.proxy;\n    this._requestManager = new RequestManager();\n    this.readyState = \"loading\";\n\n    this._lastFocusedElement = null;\n\n    // Add level2 features\n    this.implementation._addFeature(\"core\", \"2.0\");\n    this.implementation._addFeature(\"html\", \"2.0\");\n    this.implementation._addFeature(\"xhtml\", \"2.0\");\n    this.implementation._addFeature(\"xml\", \"2.0\");\n  }\n\n  _defaultElementBuilder(document, tagName) {\n    if (nonInheritedTags.has(tagName.toLowerCase())) {\n      return HTMLElement.create([], {\n        core: this._core,\n        ownerDocument: this,\n        localName: tagName\n      });\n    }\n    return HTMLUnknownElement.create([], {\n      core: this._core,\n      ownerDocument: this,\n      localName: tagName\n    });\n  }\n\n  get contentType() {\n    return this._contentType || (this._parsingMode === \"xml\" ? \"application/xml\" : \"text/html\");\n  }\n  get compatMode() {\n    return this._parsingMode === \"xml\" || this.doctype ? \"CSS1Compat\" : \"BackCompat\";\n  }\n  get charset() {\n    return this._encoding;\n  }\n  get characterSet() {\n    return this._encoding;\n  }\n  get inputEncoding() {\n    return this._encoding;\n  }\n  get doctype() {\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        return childNode;\n      }\n    }\n    return null;\n  }\n  get URL() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n  get documentURI() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n  get origin() {\n    return this._origin;\n  }\n  get location() {\n    return this._defaultView ? this._location : null;\n  }\n  get documentElement() {\n    if (this._documentElement) {\n      return this._documentElement;\n    }\n\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        this._documentElement = childNode;\n        return childNode;\n      }\n    }\n\n    return null;\n  }\n\n  get implementation() {\n    return this._implementation;\n  }\n  set implementation(implementation) {\n    this._implementation = implementation;\n  }\n\n  get defaultView() {\n    return this._defaultView;\n  }\n\n  get currentScript() {\n    return this._currentScript;\n  }\n\n  get activeElement() {\n    if (this._lastFocusedElement) {\n      return this._lastFocusedElement;\n    }\n\n    return this.body;\n  }\n\n  hasFocus() {\n    return Boolean(this._lastFocusedElement);\n  }\n\n  toString() {\n    return \"[object HTMLDocument]\";\n  }\n\n  _createElementWithCorrectElementInterface(name, namespace) {\n    // https://dom.spec.whatwg.org/#concept-element-interface\n    // TODO: eventually we should re-write the element-builder system to be namespace aware, but for now it is not.\n    const builder = this._elementBuilders[name.toLowerCase()] || this._defaultElementBuilder.bind(this);\n    const elem = builder(this, name, namespace);\n    return idlUtils.implForWrapper(elem);\n  }\n\n  appendChild(/* Node */ arg) {\n    if (this.documentElement && arg.nodeType === NODE_TYPE.ELEMENT_NODE) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR);\n    }\n    return super.appendChild(arg);\n  }\n\n  removeChild(/* Node */ arg) {\n    const ret = super.removeChild(arg);\n    if (arg === this._documentElement) {\n      this._documentElement = null;// force a recalculation\n    }\n    return ret;\n  }\n\n  _descendantRemoved(parent, child) {\n    if (child.tagName === \"STYLE\") {\n      const index = this.styleSheets.indexOf(child.sheet);\n      if (index > -1) {\n        this.styleSheets.splice(index, 1);\n      }\n    }\n  }\n\n  write() {\n    let text = \"\";\n    for (let i = 0; i < arguments.length; ++i) {\n      text += String(arguments[i]);\n    }\n\n    if (this._parsingMode === \"xml\") {\n      throw new DOMException(DOMException.INVALID_STATE_ERR, \"Cannot use document.write on XML documents\");\n    }\n\n    if (this._writeAfterElement) {\n      // If called from an script element directly (during the first tick),\n      // the new elements are inserted right after that element.\n      const tempDiv = this.createElement(\"div\");\n      setInnerHTML(this, tempDiv, text);\n\n      let child = tempDiv.firstChild;\n      let previous = this._writeAfterElement;\n      const parent = this._writeAfterElement.parentNode;\n\n      while (child) {\n        const node = child;\n        child = child.nextSibling;\n        parent.insertBefore(node, previous.nextSibling);\n        previous = node;\n      }\n    } else if (this.readyState === \"loading\") {\n      // During page loading, document.write appends to the current element\n      // Find the last child that has been added to the document.\n      let node = this;\n      while (node.lastChild && node.lastChild.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        node = node.lastChild;\n      }\n      setInnerHTML(this, node, text);\n    } else if (text) {\n      setInnerHTML(this, this, text);\n    }\n  }\n\n  writeln() {\n    const args = [];\n    for (let i = 0; i < arguments.length; ++i) {\n      args.push(arguments[i]);\n    }\n    args.push(\"\\n\");\n    this.write.apply(this, args);\n  }\n\n  getElementById(id) {\n    // return the first element\n    return this._ids[id] && this._ids[id].length > 0 ? this._ids[id][0] : null;\n  }\n\n  get referrer() {\n    return this._referrer || \"\";\n  }\n  get lastModified() {\n    return this._lastModified;\n  }\n  get images() {\n    return this.getElementsByTagName(\"IMG\");\n  }\n  get embeds() {\n    return this.getElementsByTagName(\"EMBED\");\n  }\n  get plugins() {\n    return this.embeds;\n  }\n  get links() {\n    return createHTMLCollection(this, () => domSymbolTree.treeToArray(this, { filter(node) {\n      return (node._localName === \"a\" || node._localName === \"area\") &&\n             node.hasAttribute(\"href\") &&\n             node._namespaceURI === \"http://www.w3.org/1999/xhtml\";\n    } }));\n  }\n  get forms() {\n    return this.getElementsByTagName(\"FORM\");\n  }\n  get scripts() {\n    return this.getElementsByTagName(\"SCRIPT\");\n  }\n  get anchors() {\n    return createHTMLCollection(this, () => domSymbolTree.treeToArray(this, { filter(node) {\n      return node._localName === \"a\" &&\n             node.hasAttribute(\"name\") &&\n             node._namespaceURI === \"http://www.w3.org/1999/xhtml\";\n    } }));\n  }\n  get applets() {\n    return this.getElementsByTagName(\"APPLET\");\n  }\n  open() {\n    let child = domSymbolTree.firstChild(this);\n    while (child) {\n      this.removeChild(child);\n      child = domSymbolTree.firstChild(this);\n    }\n    this._documentElement = null;\n    this._modified();\n    return this;\n  }\n  close() {\n    this._queue.resume();\n\n    // Set the readyState to 'complete' once all resources are loaded.\n    // As a side-effect the document's load-event will be dispatched.\n    resourceLoader.enqueue(this, null, function () {\n      this.readyState = \"complete\";\n      const ev = this.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"DOMContentLoaded\", false, false);\n      this.dispatchEvent(ev);\n    })(null, true);\n  }\n\n  getElementsByName(elementName) {\n    // TODO: should be NodeList, should be memoized\n    return createHTMLCollection(this, () => domSymbolTree.treeToArray(this, { filter(node) {\n      return node.getAttribute && node.getAttribute(\"name\") === elementName;\n    } }));\n  }\n\n  get title() {\n    // TODO SVG\n\n    const titleElement = firstDescendantWithHTMLLocalName(this, \"title\");\n    let value = titleElement !== null ? titleElement.textContent : \"\";\n    value = stripAndCollapseASCIIWhitespace(value);\n    return value;\n  }\n\n  set title(val) {\n    // TODO SVG\n\n    const titleElement = firstDescendantWithHTMLLocalName(this, \"title\");\n    const headElement = this.head;\n\n    if (titleElement === null && headElement === null) {\n      return;\n    }\n\n    let element;\n    if (titleElement !== null) {\n      element = titleElement;\n    } else {\n      element = this.createElement(\"title\");\n      headElement.appendChild(element);\n    }\n\n    element.textContent = val;\n  }\n\n  get head() {\n    return this.documentElement ? firstChildWithHTMLLocalName(this.documentElement, \"head\") : null;\n  }\n\n  get body() {\n    const documentElement = this.documentElement;\n    if (!documentElement || documentElement._localName !== \"html\" ||\n        documentElement._namespaceURI !== \"http://www.w3.org/1999/xhtml\") {\n      return null;\n    }\n\n    return firstChildWithHTMLLocalNames(this.documentElement, new Set([\"body\", \"frameset\"]));\n  }\n\n  set body(value) {\n    if (!HTMLElement.isImpl(value)) {\n      throw new TypeError(\"Argument must be a HTMLElement\");\n    }\n    if (value._namespaceURI !== \"http://www.w3.org/1999/xhtml\" ||\n        (value._localName !== \"body\" && value._localName !== \"frameset\")) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, \"Cannot set the body to a non-body/frameset element\");\n    }\n\n    const bodyElement = this.body;\n    if (value === bodyElement) {\n      return;\n    }\n\n    if (bodyElement !== null) {\n      bodyElement.parentNode.replaceChild(value, bodyElement);\n      return;\n    }\n\n    const documentElement = this.documentElement;\n    if (documentElement === null) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,\n        \"Cannot set the body when there is no document element\");\n    }\n\n    documentElement.appendChild(value);\n  }\n\n  _runRemovingSteps(oldNode, oldParent, oldPreviousSibling) {\n    const listeners = DocumentImpl._removingSteps;\n    for (let i = 0; i < listeners.length; ++i) {\n      listeners[i](this, oldNode, oldParent, oldPreviousSibling);\n    }\n  }\n\n  createEvent(type) {\n    const typeLower = type.toLowerCase();\n    const eventWrapper = eventInterfaceTable[typeLower] || null;\n\n    if (!eventWrapper) {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR,\n        \"The provided event type (\\\"\" + type + \"\\\") is invalid\");\n    }\n\n    const impl = eventWrapper.createImpl([\"\"]);\n    impl._initializedFlag = false;\n    return impl;\n  }\n\n  createProcessingInstruction(target, data) {\n    validateName(target);\n\n    if (data.indexOf(\"?>\") !== -1) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n        \"Processing instruction data cannot contain the string \\\"?>\\\"\");\n    }\n\n    return ProcessingInstruction.createImpl([], {\n      core: this._core,\n      ownerDocument: this,\n      target,\n      data\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-createcdatasection\n  createCDATASection(data) {\n    if (this._parsingMode === \"html\") {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR,\n        \"Cannot create CDATA sections in HTML documents\");\n    }\n\n    if (data.indexOf(\"]]>\") !== -1) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n        \"CDATA section data cannot contain the string \\\"]]>\\\"\");\n    }\n\n    return CDATASection.createImpl([], {\n      core: this._core,\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createTextNode(data) {\n    return Text.createImpl([], {\n      core: this._core,\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createComment(data) {\n    return Comment.createImpl([], {\n      core: this._core,\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createElement(localName) {\n    validateName(localName);\n    if (this._parsingMode === \"html\") {\n      localName = localName.toLowerCase();\n    }\n\n    const element = this._createElementWithCorrectElementInterface(localName, \"http://www.w3.org/1999/xhtml\");\n    element._namespaceURI = \"http://www.w3.org/1999/xhtml\";\n    element._localName = localName;\n\n    return element;\n  }\n\n  createElementNS(namespace, qualifiedName) {\n    namespace = namespace !== null ? String(namespace) : namespace;\n\n    const extracted = validateAndExtract(namespace, qualifiedName);\n\n    const element = this._createElementWithCorrectElementInterface(extracted.localName, extracted.namespace);\n    element._namespaceURI = extracted.namespace;\n    element._prefix = extracted.prefix;\n    element._localName = extracted.localName;\n\n    return element;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], { ownerDocument: this });\n  }\n\n  createAttribute(localName) {\n    validateName(localName);\n\n    if (this._parsingMode === \"html\") {\n      localName = localName.toLowerCase();\n    }\n\n    return generatedAttr.createImpl([], { localName });\n  }\n\n  createAttributeNS(namespace, name) {\n    if (namespace === undefined) {\n      namespace = null;\n    }\n    namespace = namespace !== null ? String(namespace) : namespace;\n\n    const extracted = validateAndExtract(namespace, name);\n    return generatedAttr.createImpl([], {\n      namespace: extracted.namespace,\n      namespacePrefix: extracted.prefix,\n      localName: extracted.localName\n    });\n  }\n\n  // TODO: Add callback interface support to `webidl2js`\n  createTreeWalker(root, whatToShow, filter) {\n    if (!isNodeImpl(root)) {\n      throw new TypeError(\"First argument to createTreeWalker must be a Node\");\n    }\n\n    return TreeWalker.createImpl([], {\n      root,\n      whatToShow,\n      filter\n    });\n  }\n\n  importNode(node, deep) {\n    if (!isNodeImpl(node)) {\n      throw new TypeError(\"First argument to importNode must be a Node\");\n    }\n    deep = Boolean(deep);\n\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR, \"Cannot import a document node\");\n    }\n\n    return clone(this._core, node, this, deep);\n  }\n\n  adoptNode(node) {\n    if (!isNodeImpl(node)) {\n      throw new TypeError(\"First argument to adoptNode must be a Node\");\n    }\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR, \"Cannot adopt a document node\");\n    }\n    // TODO: Determine correct way to detect a shadow root\n    // See also https://github.com/w3c/webcomponents/issues/182\n\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n    node._ownerDocument = this;\n    for (const descendant of domSymbolTree.treeIterator(node)) {\n      descendant._ownerDocument = this;\n    }\n\n    return node;\n  }\n\n  get cookie() {\n    return this._cookieJar.getCookieStringSync(this.URL, { http: false });\n  }\n  set cookie(cookieStr) {\n    cookieStr = String(cookieStr);\n    this._cookieJar.setCookieSync(cookieStr, this.URL, {\n      http: false,\n      ignoreError: true\n    });\n  }\n\n  get styleSheets() {\n    if (!this._styleSheets) {\n      this._styleSheets = new this._core.StyleSheetList();\n    }\n\n    // TODO: each style and link element should register its sheet on creation\n    // and remove it on removal.\n    return this._styleSheets;\n  }\n\n  get hidden() {\n    return true;\n  }\n\n  get visibilityState() {\n    return \"prerender\";\n  }\n}\n\nidlUtils.mixin(DocumentImpl.prototype, ParentNodeImpl.prototype);\n\nDocumentImpl._removingSteps = [];\n\nDocumentImpl.prototype._elementBuilders = Object.create(null);\n\nDocumentImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\n\nDocumentImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\n\nDocumentImpl.prototype.getElementsByClassName = memoizeQuery(function getElementsByClassName(classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nmodule.exports = {\n  implementation: DocumentImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/traversal.js":"\"use strict\";\nconst domSymbolTree = require(\"./internal-constants\").domSymbolTree;\n\n// All these operate on and return impls, not wrappers!\n\nexports.closest = (e, localName) => {\n  while (e) {\n    if (e.localName === localName) {\n      return e;\n    }\n    e = domSymbolTree.parent(e);\n  }\n\n  return null;\n};\n\nexports.childrenByHTMLLocalName = (parent, localName) => {\n  return domSymbolTree.childrenToArray(parent, { filter(node) {\n    return node._localName === localName && node._namespaceURI === \"http://www.w3.org/1999/xhtml\";\n  } });\n};\n\nexports.descendantsByHTMLLocalName = (parent, localName) => {\n  return domSymbolTree.treeToArray(parent, { filter(node) {\n    return node._localName === localName && node._namespaceURI === \"http://www.w3.org/1999/xhtml\" && node !== parent;\n  } });\n};\n\nexports.childrenByHTMLLocalNames = (parent, localNamesSet) => {\n  return domSymbolTree.childrenToArray(parent, { filter(node) {\n    return localNamesSet.has(node._localName) && node._namespaceURI === \"http://www.w3.org/1999/xhtml\";\n  } });\n};\n\nexports.descendantsByHTMLLocalNames = (parent, localNamesSet) => {\n  return domSymbolTree.treeToArray(parent, { filter(node) {\n    return localNamesSet.has(node._localName) &&\n           node._namespaceURI === \"http://www.w3.org/1999/xhtml\" &&\n           node !== parent;\n  } });\n};\n\nexports.firstChildWithHTMLLocalName = (parent, localName) => {\n  const iterator = domSymbolTree.childrenIterator(parent);\n  for (const child of iterator) {\n    if (child._localName === localName && child._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n      return child;\n    }\n  }\n  return null;\n};\n\nexports.firstChildWithHTMLLocalNames = (parent, localNamesSet) => {\n  const iterator = domSymbolTree.childrenIterator(parent);\n  for (const child of iterator) {\n    if (localNamesSet.has(child._localName) && child._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n      return child;\n    }\n  }\n  return null;\n};\n\nexports.firstDescendantWithHTMLLocalName = (parent, localName) => {\n  const iterator = domSymbolTree.treeIterator(parent);\n  for (const descendant of iterator) {\n    if (descendant._localName === localName && descendant._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n      return descendant;\n    }\n  }\n  return null;\n};\n\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/strings.js":"\"use strict\";\n\n// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\nexports.stripAndCollapseASCIIWhitespace = s => {\n  return s.replace(/[ \\t\\n\\f\\r]+/g, \" \").replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/browser/htmltodom.js":"\"use strict\";\n\nconst parse5 = require(\"parse5\");\nconst sax = require(\"sax\");\nconst attributes = require(\"../living/attributes\");\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst locationInfo = require(\"../living/helpers/internal-constants\").locationInfo;\n\nclass HtmlToDom {\n  constructor(core, parser, parsingMode) {\n    if (!parser) {\n      if (parsingMode === \"xml\") {\n        parser = sax;\n      } else {\n        parser = parse5;\n      }\n    }\n\n    this.core = core;\n    this.parser = parser;\n    this.parsingMode = parsingMode;\n\n    if (parser.DefaultHandler) {\n      this.parserType = \"htmlparser2\";\n    } else if (parser.Parser && parser.TreeAdapters) {\n      this.parserType = \"parse5v1\";\n    } else if (parser.moduleName === \"HTML5\") {\n      this.parserType = \"html5\";\n    } else if (parser.parser) {\n      this.parserType = \"sax\";\n    }\n  }\n\n  appendHtmlToElement(html, element) {\n    if (typeof html !== \"string\") {\n      html = String(html);\n    }\n\n    return this[\"_parseWith\" + this.parserType](html, true, element);\n  }\n\n  appendHtmlToDocument(html, element) {\n    if (typeof html !== \"string\") {\n      html = String(html);\n    }\n\n    return this[\"_parseWith\" + this.parserType](html, false, element);\n  }\n\n  _parseWithhtmlparser2(html, fragment, element) {\n    const handler = new this.parser.DefaultHandler();\n    // Check if document is XML\n    const isXML = this.parsingMode === \"xml\";\n    const parserInstance = new this.parser.Parser(handler, {\n      xmlMode: isXML,\n      lowerCaseTags: !isXML,\n      lowerCaseAttributeNames: !isXML,\n      decodeEntities: true\n    });\n\n    parserInstance.includeLocation = false;\n    parserInstance.parseComplete(html);\n\n    const parsed = handler.dom;\n    for (let i = 0; i < parsed.length; i++) {\n      setChild(this.core, element, parsed[i]);\n    }\n\n    return element;\n  }\n\n  _parseWithparse5v1(html, fragment, element) {\n    if (this.parsingMode === \"xml\") {\n      throw new Error(\"Can't parse XML with parse5, please use htmlparser2 instead.\");\n    }\n\n    const htmlparser2Adapter = this.parser.TreeAdapters.htmlparser2;\n    let dom;\n    if (fragment) {\n      const instance = new this.parser.Parser(htmlparser2Adapter);\n      const parentElement = htmlparser2Adapter.createElement(element.tagName.toLowerCase(), element.namespaceURI, []);\n      dom = instance.parseFragment(html, parentElement);\n    } else {\n      const instance = new this.parser.Parser(htmlparser2Adapter, { locationInfo: true });\n      dom = instance.parse(html);\n    }\n\n    const parsed = dom.children;\n    for (let i = 0; i < parsed.length; i++) {\n      setChild(this.core, element, parsed[i]);\n    }\n\n    return element;\n  }\n\n  _parseWithhtml5(html, fragment, element) {\n    if (element.nodeType === 9) {\n      new this.parser.Parser({ document: element }).parse(html);\n    } else {\n      const p = new this.parser.Parser({ document: element.ownerDocument });\n      p.parse_fragment(html, element);\n    }\n  }\n\n  _parseWithsax(html, fragment, element) {\n    const SaxParser = this.parser.parser;\n    const parser = new SaxParser(/* strict = */true, { xmlns: true });\n    parser.noscript = false;\n    parser.looseCase = \"toString\";\n    const openStack = [element];\n    parser.ontext = text => {\n      setChild(this.core, openStack[openStack.length - 1], {\n        type: \"text\",\n        data: text\n      });\n    };\n    parser.onopentag = arg => {\n      const attrValues = {};\n      const attrPrefixes = {};\n      const attrNamespaces = {};\n      Object.keys(arg.attributes).forEach(key => {\n        const localName = arg.attributes[key].local;\n        attrValues[localName] = arg.attributes[key].value;\n        attrPrefixes[localName] = arg.attributes[key].prefix || null;\n        attrNamespaces[localName] = arg.attributes[key].uri || null;\n      });\n\n      if (arg.local === \"script\" && arg.uri === \"http://www.w3.org/1999/xhtml\") {\n        openStack.push({\n          type: \"tag\",\n          name: arg.local,\n          prefix: arg.prefix,\n          namespace: arg.uri,\n          attribs: attrValues,\n          \"x-attribsPrefix\": attrPrefixes,\n          \"x-attribsNamespace\": attrNamespaces\n        });\n      } else {\n        const elem = setChild(this.core, openStack[openStack.length - 1], {\n          type: \"tag\",\n          name: arg.local,\n          prefix: arg.prefix,\n          namespace: arg.uri,\n          attribs: attrValues,\n          \"x-attribsPrefix\": attrPrefixes,\n          \"x-attribsNamespace\": attrNamespaces\n        });\n        openStack.push(elem);\n      }\n    };\n    parser.onclosetag = () => {\n      const elem = openStack.pop();\n      if (elem.constructor.name === \"Object\") { // we have an empty script tag\n        setChild(this.core, openStack[openStack.length - 1], elem);\n      }\n    };\n    parser.onscript = scriptText => {\n      const tag = openStack.pop();\n      tag.children = [{ type: \"text\", data: scriptText }];\n      const elem = setChild(this.core, openStack[openStack.length - 1], tag);\n      openStack.push(elem);\n    };\n    parser.oncomment = comment => {\n      setChild(this.core, openStack[openStack.length - 1], {\n        type: \"comment\",\n        data: comment\n      });\n    };\n    parser.onprocessinginstruction = pi => {\n      setChild(this.core, openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"?\" + pi.name,\n        data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n      });\n    };\n    parser.ondoctype = dt => {\n      setChild(this.core, openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"!doctype\",\n        data: \"!doctype \" + dt\n      });\n\n      const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n      let result;\n      while ((result = entityMatcher.exec(dt))) {\n        // TODO Node v6 const [, name, value] = result;\n        const name = result[1];\n        const value = result[2];\n        if (!(name in parser.ENTITIES)) {\n          parser.ENTITIES[name] = value;\n        }\n      }\n    };\n\n    parser.onerror = err => {\n      throw err;\n    };\n    parser.write(html).close();\n  }\n}\n\n// utility function for forgiving parser\nfunction setChild(core, parentImpl, node) {\n  const currentDocument = parentImpl && parentImpl._ownerDocument || parentImpl;\n\n  let newNode;\n  let isTemplateContents = false;\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n      break;\n\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        const data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        if (node[\"x-name\"] !== undefined) { // parse5 supports doctypes directly\n          newNode = createDocumentTypeInternal(core, currentDocument,\n            node[\"x-name\"] || \"\",\n            node[\"x-publicId\"] || \"\",\n            node[\"x-systemId\"] || \"\");\n        } else {\n          newNode = parseDocType(core, currentDocument, \"<\" + node.data + \">\");\n        }\n      }\n      break;\n  }\n\n  if (!newNode) {\n    return null;\n  }\n\n  newNode[locationInfo] = node.__location;\n\n  if (node.attribs) {\n    Object.keys(node.attribs).forEach(localName => {\n      const value = node.attribs[localName];\n      let prefix =\n        node[\"x-attribsPrefix\"] &&\n        Object.prototype.hasOwnProperty.call(node[\"x-attribsPrefix\"], localName) &&\n        node[\"x-attribsPrefix\"][localName] || null;\n      const namespace =\n        node[\"x-attribsNamespace\"] &&\n        Object.prototype.hasOwnProperty.call(node[\"x-attribsNamespace\"], localName) &&\n        node[\"x-attribsNamespace\"][localName] || null;\n      if (prefix === \"xmlns\" && localName === \"\") {\n         // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n        localName = prefix;\n        prefix = null;\n      }\n      attributes.setAttributeValue(newNode, localName, value, prefix, namespace);\n    });\n  }\n\n  if (node.children) {\n    for (let c = 0; c < node.children.length; c++) {\n      setChild(core, newNode, node.children[c]);\n    }\n  }\n\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n\n  return newNode;\n}\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(core, doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(core, doc, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentTypeInternal(core, doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentTypeInternal(core, doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n  return createDocumentTypeInternal(core, doc, \"html\", \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(core, ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], { core, ownerDocument, name, publicId, systemId });\n}\n\nexports.HtmlToDom = HtmlToDom;\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/DocumentType.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Node = require(\"./Node.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst ChildNode = require(\"./ChildNode.js\");\n\nfunction DocumentType() {\n  throw new TypeError(\"Illegal constructor\");\n}\nDocumentType.prototype = Object.create(Node.interface.prototype);\nDocumentType.prototype.constructor = DocumentType;\n\nmixin(DocumentType.prototype, ChildNode.interface.prototype);\nChildNode.mixedInto.push(DocumentType);\n\nDocumentType.prototype.toString = function () {\n  if (this === DocumentType.prototype) {\n    return \"[object DocumentTypePrototype]\";\n  }\n  return Node.interface.prototype.toString.call(this);\n};\nObject.defineProperty(DocumentType.prototype, \"name\", {\n  get() {\n    return this[impl].name;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(DocumentType.prototype, \"publicId\", {\n  get() {\n    return this[impl].publicId;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(DocumentType.prototype, \"systemId\", {\n  get() {\n    return this[impl].systemId;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(DocumentType.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(DocumentType.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Node._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: DocumentType,\n  expose: {\n    Window: { DocumentType: DocumentType }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/DocumentType-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ChildNode.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction ChildNode() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nChildNode.prototype.remove = function remove() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].remove.apply(this[impl], args);\n};\n\nChildNode.prototype.toString = function () {\n  if (this === ChildNode.prototype) {\n    return \"[object ChildNodePrototype]\";\n  }\n  return this[impl].toString();\n};\n\nChildNode.prototype[Symbol.unscopables] = {\n  \"remove\": true\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(ChildNode.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(ChildNode.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: ChildNode,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/ChildNode-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/ChildNode-impl.js":"\"use strict\";\n\nclass ChildNodeImpl {\n  remove() {\n    if (!this.parentNode) {\n      return;\n    }\n\n    this.parentNode.removeChild(this);\n  }\n}\n\nmodule.exports = {\n  implementation: ChildNodeImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/DocumentType-impl.js":"\"use strict\";\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\n\nconst NODE_TYPE = require(\"../node-type\");\n\nclass DocumentTypeImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this.nodeType = NODE_TYPE.DOCUMENT_TYPE_NODE;\n\n    this.name = privateData.name;\n    this.publicId = privateData.publicId;\n    this.systemId = privateData.systemId;\n  }\n}\n\nidlUtils.mixin(DocumentTypeImpl.prototype, ChildNodeImpl.prototype);\n\nmodule.exports = {\n  implementation: DocumentTypeImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/History.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction History() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nHistory.prototype.go = function go() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"long\"](args[0]);\n  } else {\n    args[0] = 0;\n  }\n  return this[impl].go.apply(this[impl], args);\n};\n\nHistory.prototype.back = function back() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].back.apply(this[impl], args);\n};\n\nHistory.prototype.forward = function forward() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].forward.apply(this[impl], args);\n};\n\nHistory.prototype.pushState = function pushState(data, title) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'pushState' on 'History': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"any\"](args[0]);\n  args[1] = conversions[\"DOMString\"](args[1]);\n  if (args[2] === null || args[2] === undefined) {\n    args[2] = null;\n  } else {\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"DOMString\"](args[2]);\n  } else {\n    args[2] = undefined;\n  }\n  }\n  return this[impl].pushState.apply(this[impl], args);\n};\n\nHistory.prototype.replaceState = function replaceState(data, title) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'replaceState' on 'History': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"any\"](args[0]);\n  args[1] = conversions[\"DOMString\"](args[1]);\n  if (args[2] === null || args[2] === undefined) {\n    args[2] = null;\n  } else {\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"DOMString\"](args[2]);\n  } else {\n    args[2] = undefined;\n  }\n  }\n  return this[impl].replaceState.apply(this[impl], args);\n};\n\nHistory.prototype.toString = function () {\n  if (this === History.prototype) {\n    return \"[object HistoryPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(History.prototype, \"length\", {\n  get() {\n    return this[impl].length;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(History.prototype, \"state\", {\n  get() {\n    return this[impl].state;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(History.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(History.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: History,\n  expose: {\n    Window: { History: History }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../window/History-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/window/History-impl.js":"\"use strict\";\nconst DOMException = require(\"../../web-idl/DOMException.js\");\nconst documentBaseURLSerialized = require(\"../helpers/document-base-url.js\").documentBaseURLSerialized;\nconst parseURLToResultingURLRecord = require(\"../helpers/document-base-url.js\").parseURLToResultingURLRecord;\nconst traverseHistory = require(\"./navigation.js\").traverseHistory;\n\nexports.implementation = class HistoryImpl {\n  constructor(args, privateData) {\n    this._window = privateData.window;\n    this._document = privateData.document;\n    this._actAsIfLocationReloadCalled = privateData.actAsIfLocationReloadCalled;\n    this._state = null;\n    this._latestEntry = null;\n\n    this._historyTraversalQueue = new Set();\n  }\n\n  _guardAgainstInactiveDocuments() {\n    if (!this._window) {\n      throw new DOMException(DOMException.SECURITY_ERR,\n        \"History object is associated with a document that is not fully active.\");\n    }\n  }\n\n  get length() {\n    this._guardAgainstInactiveDocuments();\n\n    return this._window._sessionHistory.length;\n  }\n\n  get state() {\n    this._guardAgainstInactiveDocuments();\n\n    return this._state;\n  }\n\n  go(delta) {\n    this._guardAgainstInactiveDocuments();\n\n    if (delta === 0) {\n      this._actAsIfLocationReloadCalled();\n    } else {\n      this._queueHistoryTraversalTask(() => {\n        const newIndex = this._window._currentSessionHistoryEntryIndex + delta;\n        if (newIndex < 0 || newIndex >= this._window._sessionHistory.length) {\n          return;\n        }\n\n        const specifiedEntry = this._window._sessionHistory[newIndex];\n\n        // Not implemented: unload a document guard\n\n        // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n        // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n        this._queueHistoryTraversalTask(() => traverseHistory(this._window, specifiedEntry));\n      });\n    }\n  }\n\n  back() {\n    this.go(-1);\n  }\n\n  forward() {\n    this.go(+1);\n  }\n\n  pushState(data, title, url) {\n    this._sharedPushAndReplaceState(data, title, url, \"pushState\");\n  }\n  replaceState(data, title, url) {\n    this._sharedPushAndReplaceState(data, title, url, \"replaceState\");\n  }\n\n  _sharedPushAndReplaceState(data, title, url, methodName) {\n    this._guardAgainstInactiveDocuments();\n\n    // TODO structured clone data\n\n    let newURL;\n    if (url !== null) {\n      // Not implemented: use of entry settings object's API base URL. Instead we just use the document base URL. The\n      // difference matters in the case of cross-frame calls.\n      newURL = parseURLToResultingURLRecord(url, this._document);\n\n      if (newURL === \"failure\") {\n        throw new DOMException(DOMException.SECURITY_ERR, `Could not parse url argument \"${url}\" to ${methodName} ` +\n          `against base URL \"${documentBaseURLSerialized(this._document)}\".`);\n      }\n\n      if (newURL.scheme !== this._document._URL.scheme ||\n          newURL.username !== this._document._URL.username ||\n          newURL.password !== this._document._URL.password ||\n          newURL.host !== this._document._URL.host ||\n          newURL.port !== this._document._URL.port ||\n          newURL.cannotBeABaseURL !== this._document._URL.cannotBeABaseURL) {\n        throw new DOMException(DOMException.SECURITY_ERR, `${methodName} cannot update history to a URL which ` +\n          `differs in components other than in path, query, or fragment.`);\n      }\n\n      // Not implemented: origin check (seems to only apply to documents with weird origins, e.g. sandboxed ones)\n    } else {\n      newURL = this._window._sessionHistory[this._window._currentSessionHistoryEntryIndex].url;\n    }\n\n    if (methodName === \"pushState\") {\n      this._window._sessionHistory.splice(this._window._currentSessionHistoryEntryIndex + 1, Infinity);\n\n      this._clearHistoryTraversalTasks();\n\n      this._window._sessionHistory.push({\n        document: this._document,\n        stateObject: data,\n        title,\n        url: newURL\n      });\n      this._window._currentSessionHistoryEntryIndex = this._window._sessionHistory.length - 1;\n    } else {\n      const currentEntry = this._window._sessionHistory[this._window._currentSessionHistoryEntryIndex];\n      currentEntry.stateObject = data;\n      currentEntry.title = title;\n      currentEntry.url = newURL;\n    }\n\n    this._document._URL = newURL;\n    this._state = data; // TODO clone again!! O_o\n    this._latestEntry = this._window._sessionHistory[this._window._currentSessionHistoryEntryIndex];\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  _clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/window/navigation.js":"\"use strict\";\nconst whatwgURL = require(\"whatwg-url\");\nconst arrayEqual = require(\"array-equal\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst idlUtils = require(\"../generated/utils\");\n\nexports.traverseHistory = (window, specifiedEntry, flags) => {\n  // Not spec compliant, just minimal. Lots of missing steps.\n\n  if (flags === undefined) {\n    flags = {};\n  }\n  const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n\n  const document = idlUtils.implForWrapper(window._document);\n\n  const currentEntry = window._sessionHistory[window._currentSessionHistoryEntryIndex];\n\n  if (currentEntry.title === undefined) {\n    currentEntry.title = document.title;\n  }\n\n  document._URL = specifiedEntry.url;\n\n  let hashChanged = false;\n  let oldURL;\n  let newURL;\n  if (specifiedEntry.url.fragment !== currentEntry.url.fragment) {\n    hashChanged = true;\n    oldURL = currentEntry.url;\n    newURL = specifiedEntry.url;\n  }\n\n  const state = specifiedEntry.stateObject; // TODO structured clone\n  document._history._state = state;\n\n  const stateChanged = specifiedEntry.document._history._latestEntry !== specifiedEntry;\n  specifiedEntry.document._history._latestEntry = specifiedEntry;\n\n  if (nonBlockingEvents) {\n    window.setTimeout(fireEvents, 0);\n  } else {\n    fireEvents();\n  }\n\n  function fireEvents() {\n    if (stateChanged) {\n      window.dispatchEvent(PopStateEvent.create([\"popstate\", {\n        bubbles: true,\n        cancelable: false,\n        state\n      }]));\n    }\n\n    if (hashChanged) {\n      window.dispatchEvent(HashChangeEvent.create([\"hashchange\", {\n        bubbles: true,\n        cancelable: false,\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      }]));\n    }\n  }\n\n  window._currentSessionHistoryEntryIndex = window._sessionHistory.indexOf(specifiedEntry);\n};\n\nexports.navigate = (window, newURL) => {\n  // This is NOT a spec-compliant implementation of navigation in any way. It implements a few selective steps that\n  // are nice for jsdom users, regarding hash changes. We could maybe implement javascript: URLs in the future, but\n  // the rest is too hard.\n\n  const document = idlUtils.implForWrapper(window._document);\n\n  const currentURL = document._URL;\n\n  if (newURL.scheme !== currentURL.scheme ||\n      newURL.username !== currentURL.username ||\n      newURL.password !== currentURL.password ||\n      newURL.host !== currentURL.host ||\n      newURL.port !== currentURL.port ||\n      !arrayEqual(newURL.path, currentURL.path) ||\n      newURL.query !== currentURL.query ||\n      // Omitted per spec: url.fragment !== this._url.fragment ||\n      newURL.cannotBeABaseURL !== currentURL.cannotBeABaseURL) {\n    notImplemented(\"navigation (except hash changes)\", window);\n    return;\n  }\n\n  if (newURL.fragment !== currentURL.fragment) {\n    // https://html.spec.whatwg.org/#scroll-to-fragid\n\n    window._sessionHistory.splice(window._currentSessionHistoryEntryIndex + 1, Infinity);\n\n    document._history._clearHistoryTraversalTasks();\n\n    const newEntry = { document, url: newURL };\n    window._sessionHistory.push(newEntry);\n    exports.traverseHistory(window, newEntry, { nonBlockingEvents: true });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HashChangeEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Event = require(\"./Event.js\");\nconst impl = utils.implSymbol;\nconst convertHashChangeEventInit = require(\"./HashChangeEventInit\").convert;\n\nfunction HashChangeEvent(type) {\n  if (!this || this[impl] || !(this instanceof HashChangeEvent)) {\n    throw new TypeError(\"Failed to construct 'HashChangeEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'HashChangeEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertHashChangeEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nHashChangeEvent.prototype = Object.create(Event.interface.prototype);\nHashChangeEvent.prototype.constructor = HashChangeEvent;\n\n\nHashChangeEvent.prototype.toString = function () {\n  if (this === HashChangeEvent.prototype) {\n    return \"[object HashChangeEventPrototype]\";\n  }\n  return Event.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HashChangeEvent.prototype, \"oldURL\", {\n  get() {\n    return this[impl].oldURL;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HashChangeEvent.prototype, \"newURL\", {\n  get() {\n    return this[impl].newURL;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HashChangeEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HashChangeEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Event._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HashChangeEvent,\n  expose: {\n    Window: { HashChangeEvent: HashChangeEvent },\n    Worker: { HashChangeEvent: HashChangeEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/HashChangeEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HashChangeEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventInit = require(\"./EventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"newURL\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    }\n\n    key = \"oldURL\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/HashChangeEvent-impl.js":"\"use strict\";\n\nconst EventImpl = require(\"./Event-impl\").implementation;\n\nclass HashChangeEventImpl extends EventImpl {\n\n}\n\nmodule.exports = {\n  implementation: HashChangeEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/PopStateEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Event = require(\"./Event.js\");\nconst impl = utils.implSymbol;\nconst convertPopStateEventInit = require(\"./PopStateEventInit\").convert;\n\nfunction PopStateEvent(type) {\n  if (!this || this[impl] || !(this instanceof PopStateEvent)) {\n    throw new TypeError(\"Failed to construct 'PopStateEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'PopStateEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertPopStateEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nPopStateEvent.prototype = Object.create(Event.interface.prototype);\nPopStateEvent.prototype.constructor = PopStateEvent;\n\n\nPopStateEvent.prototype.toString = function () {\n  if (this === PopStateEvent.prototype) {\n    return \"[object PopStateEventPrototype]\";\n  }\n  return Event.interface.prototype.toString.call(this);\n};\nObject.defineProperty(PopStateEvent.prototype, \"state\", {\n  get() {\n    return this[impl].state;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(PopStateEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(PopStateEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Event._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: PopStateEvent,\n  expose: {\n    Window: { PopStateEvent: PopStateEvent },\n    Worker: { PopStateEvent: PopStateEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/PopStateEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/PopStateEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventInit = require(\"./EventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"state\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"any\"](value);\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/PopStateEvent-impl.js":"\"use strict\";\nconst EventImpl = require(\"./Event-impl.js\").implementation;\n\nexports.implementation = class PopStateEventImpl extends EventImpl {};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Location.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction Location() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nLocation.prototype.assign = function assign(url) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'assign' on 'Location': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  return this[impl].assign.apply(this[impl], args);\n};\n\nLocation.prototype.replace = function replace(url) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'replace' on 'Location': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  return this[impl].replace.apply(this[impl], args);\n};\n\nLocation.prototype.reload = function reload() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].reload.apply(this[impl], args);\n};\nObject.defineProperty(Location.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nLocation.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this[impl].href;;\n};\n\nObject.defineProperty(Location.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Location.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Location.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Location.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Location.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Location.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Location.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Location.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Location.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Location.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Object.defineProperty(obj, \"valueOf\", {\n      value: function valueOf() { return this; },\n      enumerable: true\n    });\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Location,\n  expose: {\n    Window: { Location: Location }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../window/Location-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/window/Location-impl.js":"\"use strict\";\nconst whatwgURL = require(\"whatwg-url\");\nconst documentBaseURL = require(\"../helpers/document-base-url.js\").documentBaseURL;\nconst parseURLToResultingURLRecord = require(\"../helpers/document-base-url.js\").parseURLToResultingURLRecord;\nconst DOMException = require(\"../../web-idl/DOMException.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst navigate = require(\"./navigation.js\").navigate;\n\n// Not implemented: use of entry settings object's API base URL in href setter, assign, and replace. Instead we just\n// use the document base URL. The difference matters in the case of cross-frame calls.\n\nexports.implementation = class LocationImpl {\n  constructor(args, privateData) {\n    this._relevantDocument = privateData.relevantDocument;\n    this.url = null;\n  }\n\n  get _url() {\n    return this._relevantDocument._URL;\n  }\n\n  _locationObjectSetterNavigate(url) {\n    // Not implemented: extra steps here to determine replacement flag, since they are not applicable to our\n    // rudimentary \"navigation\" implementation.\n\n    return this._locationObjectNavigate(url);\n  }\n\n  _locationObjectNavigate(url/* , { replacement = false } = {} */) {\n    // Not implemented: the setup for calling navigate, which doesn't apply to our stub navigate anyway.\n    // Not implemented: using the replacement flag.\n\n    navigate(this._relevantDocument._defaultView, url);\n  }\n\n  toString() {\n    return this.href;\n  }\n\n  get href() {\n    return whatwgURL.serializeURL(this._url);\n  }\n  set href(v) {\n    const newURL = whatwgURL.parseURL(v, { baseURL: documentBaseURL(this._relevantDocument) });\n    if (newURL === \"failure\") {\n      throw new TypeError(`Could not parse \"${v}\" as a URL`);\n    }\n\n    this._locationObjectSetterNavigate(newURL);\n  }\n\n  get origin() {\n    return whatwgURL.serializeURLToUnicodeOrigin(this._url);\n  }\n\n  get protocol() {\n    return this._url.scheme + \":\";\n  }\n  set protocol(v) {\n    const copyURL = Object.assign({}, this._url);\n\n    const possibleFailure = whatwgURL.basicURLParse(v + \":\", { url: copyURL, stateOverride: \"scheme start\" });\n    if (possibleFailure === \"failure\") {\n      throw new TypeError(`Could not parse the URL after setting the procol to \"${v}\"`);\n    }\n\n    if (copyURL.scheme !== \"http\" && copyURL.scheme !== \"https\") {\n      return;\n    }\n\n    this._locationObjectSetterNavigate(copyURL);\n  }\n\n  get host() {\n    const url = this._url;\n\n    if (url.host === null) {\n      return \"\";\n    }\n    if (url.port === null) {\n      return whatwgURL.serializeHost(url.host);\n    }\n\n    return whatwgURL.serializeHost(url.host) + \":\" + whatwgURL.serializeInteger(url.port);\n  }\n  set host(v) {\n    const copyURL = Object.assign({}, this._url);\n\n    if (copyURL.cannotBeABaseURL) {\n      return;\n    }\n\n    whatwgURL.basicURLParse(v, { url: copyURL, stateOverride: \"host\" });\n\n    this._locationObjectSetterNavigate(copyURL);\n  }\n\n  get hostname() {\n    if (this._url.host === null) {\n      return \"\";\n    }\n\n    return whatwgURL.serializeHost(this._url.host);\n  }\n  set hostname(v) {\n    const copyURL = Object.assign({}, this._url);\n\n    if (copyURL.cannotBeABaseURL) {\n      return;\n    }\n\n    whatwgURL.basicURLParse(v, { url: copyURL, stateOverride: \"hostname\" });\n\n    this._locationObjectSetterNavigate(copyURL);\n  }\n\n  get port() {\n    if (this._url.port === null) {\n      return \"\";\n    }\n\n    return whatwgURL.serializeInteger(this._url.port);\n  }\n  set port(v) {\n    const copyURL = Object.assign({}, this._url);\n\n    if (copyURL.host === null || copyURL.cannotBeABaseURL || copyURL.scheme === \"file\") {\n      return;\n    }\n\n    whatwgURL.basicURLParse(v, { url: copyURL, stateOverride: \"port\" });\n\n    this._locationObjectSetterNavigate(copyURL);\n  }\n\n  get pathname() {\n    const url = this._url;\n\n    if (url.cannotBeABaseURL) {\n      return url.path[0];\n    }\n\n    return \"/\" + url.path.join(\"/\");\n  }\n  set pathname(v) {\n    const copyURL = Object.assign({}, this._url);\n\n    if (copyURL.cannotBeABaseURL) {\n      return;\n    }\n\n    copyURL.path = [];\n    whatwgURL.basicURLParse(v, { url: copyURL, stateOverride: \"path start\" });\n\n    this._locationObjectSetterNavigate(copyURL);\n  }\n\n  get search() {\n    if (this._url.query === null || this._url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + this._url.query;\n  }\n  set search(v) {\n    const copyURL = Object.assign({}, this._url);\n\n    if (v === \"\") {\n      copyURL.query = null;\n    } else {\n      const input = v[0] === \"?\" ? v.substring(1) : v;\n      copyURL.query = \"\";\n      whatwgURL.basicURLParse(input, {\n        url: copyURL,\n        stateOverride: \"query\",\n        encodingOverride: this._relevantDocument.charset\n      });\n    }\n\n    this._locationObjectSetterNavigate(copyURL);\n  }\n\n  get hash() {\n    if (this._url.fragment === null || this._url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + this._url.fragment;\n  }\n  set hash(v) {\n    const copyURL = Object.assign({}, this._url);\n\n    if (copyURL.scheme === \"javascript\") {\n      return;\n    }\n\n    if (v === \"\") {\n      copyURL.fragment = null;\n    } else {\n      const input = v[0] === \"#\" ? v.substring(1) : v;\n      copyURL.fragment = \"\";\n      whatwgURL.basicURLParse(input, { url: copyURL, stateOverride: \"fragment\" });\n    }\n\n    this._locationObjectSetterNavigate(copyURL);\n  }\n\n  assign(url) {\n    // Should be entry settings object; oh well\n    const parsedURL = parseURLToResultingURLRecord(url, this._relevantDocument);\n\n    if (parsedURL === \"failure\") {\n      throw new DOMException(DOMException.SYNTAX_ERR, `Could not resolve the given string \"${url}\" relative to the ` +\n        `base URL \"${this._relevantDocument.URL}\"`);\n    }\n\n    this._locationObjectNavigate(parsedURL);\n  }\n\n  replace(url) {\n    // Should be entry settings object; oh well\n    const parsedURL = parseURLToResultingURLRecord(url, this._relevantDocument);\n\n    if (parsedURL === \"failure\") {\n      throw new DOMException(DOMException.SYNTAX_ERR, `Could not resolve the given string \"${url}\" relative to the ` +\n        `base URL \"${this._relevantDocument.URL}\"`);\n    }\n\n    this._locationObjectNavigate(parsedURL, { replacement: true });\n  }\n\n  reload() {\n    notImplemented(\"location.reload()\", this._relevantDocument._defaultView);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/validate-names.js":"\"use strict\";\nconst xnv = require(\"xml-name-validator\");\nconst DOMException = require(\"../../web-idl/DOMException\");\n\n// https://dom.spec.whatwg.org/#validate\n\nexports.name = function (name) {\n  const result = xnv.name(name);\n  if (!result.success) {\n    throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n      \"\\\"\" + name + \"\\\" did not match the Name production: \" + result.error);\n  }\n};\n\nexports.qname = function (qname) {\n  exports.name(qname);\n\n  const result = xnv.qname(qname);\n  if (!result.success) {\n    throw new DOMException(DOMException.NAMESPACE_ERR,\n      \"\\\"\" + qname + \"\\\" did not match the QName production: \" + result.error);\n  }\n};\n\nexports.validateAndExtract = function (namespace, qualifiedName) {\n  if (namespace === \"\") {\n    namespace = null;\n  }\n\n  exports.qname(qualifiedName);\n\n  let prefix = null;\n  let localName = qualifiedName;\n\n  const colonIndex = qualifiedName.indexOf(\":\");\n  if (colonIndex !== -1) {\n    prefix = qualifiedName.substring(0, colonIndex);\n    localName = qualifiedName.substring(colonIndex + 1);\n  }\n\n  if (prefix !== null && namespace === null) {\n    throw new DOMException(DOMException.NAMESPACE_ERR,\n      \"A namespace was given but a prefix was also extracted from the qualifiedName\");\n  }\n\n  if (prefix === \"xml\" && namespace !== \"http://www.w3.org/XML/1998/namespace\") {\n    throw new DOMException(DOMException.NAMESPACE_ERR,\n      \"A prefix of \\\"xml\\\" was given but the namespace was not the XML namespace\");\n  }\n\n  if ((qualifiedName === \"xmlns\" || prefix === \"xmlns\") && namespace !== \"http://www.w3.org/2000/xmlns/\") {\n    throw new DOMException(DOMException.NAMESPACE_ERR,\n      \"A prefix or qualifiedName of \\\"xmlns\\\" was given but the namespace was not the XMLNS namespace\");\n  }\n\n  if (namespace === \"http://www.w3.org/2000/xmlns/\" && qualifiedName !== \"xmlns\" && prefix !== \"xmlns\") {\n    throw new DOMException(DOMException.NAMESPACE_ERR,\n      \"The XMLNS namespace was given but neither the prefix nor qualifiedName was \\\"xmlns\\\"\");\n  }\n\n  return { namespace, prefix, localName };\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/browser/resource-loader.js":"\"use strict\";\n\nconst parseContentType = require(\"content-type-parser\");\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst parseDataUrl = require(\"../utils\").parseDataUrl;\nconst fs = require(\"fs\");\nconst request = require(\"request\");\nconst documentBaseURLSerialized = require(\"../living/helpers/document-base-url\").documentBaseURLSerialized;\nconst NODE_TYPE = require(\"../living/node-type\");\n\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\nconst URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nfunction createResourceLoadHandler(element, resourceUrl, document, loadCallback) {\n  if (loadCallback === undefined) {\n    loadCallback = () => {\n      // do nothing\n    };\n  }\n  return (err, data, response) => {\n    const ev = document.createEvent(\"HTMLEvents\");\n\n    if (!err) {\n      try {\n        loadCallback.call(element, data, resourceUrl, response);\n        ev.initEvent(\"load\", false, false);\n      } catch (e) {\n        err = e;\n      }\n    }\n\n    if (err) {\n      if (!err.isAbortError) {\n        ev.initEvent(\"error\", false, false);\n        ev.error = err;\n        element.dispatchEvent(ev);\n\n        const error = new Error(`Could not load ${element.localName}: \"${resourceUrl}\"`);\n        error.detail = err;\n        error.type = \"resource loading\";\n\n        document._defaultView._virtualConsole.emit(\"jsdomError\", error);\n      }\n    } else {\n      element.dispatchEvent(ev);\n    }\n  };\n}\n\nexports.readFile = function (filePath, options, callback) {\n  const readableStream = fs.createReadStream(filePath);\n\n  let data = new Buffer(0);\n\n  readableStream.on(\"error\", callback);\n\n  readableStream.on(\"data\", chunk => {\n    data = Buffer.concat([data, chunk]);\n  });\n\n  const defaultEncoding = options.defaultEncoding;\n  const detectMetaCharset = options.detectMetaCharset;\n\n  readableStream.on(\"end\", () => {\n    // Not passing default encoding means binary\n    if (defaultEncoding) {\n      const encoding = detectMetaCharset ? sniffHTMLEncoding(data, { defaultEncoding }) :\n                       whatwgEncoding.getBOMEncoding(data) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(data, encoding);\n      callback(null, decoded, { headers: { \"content-type\": \"text/plain;charset=\" + encoding } });\n    } else {\n      callback(null, data);\n    }\n  });\n\n  return {\n    abort() {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nfunction readDataUrl(dataUrl, options, callback) {\n  const defaultEncoding = options.defaultEncoding;\n  try {\n    const data = parseDataUrl(dataUrl);\n    // If default encoding does not exist, pass on binary data.\n    if (defaultEncoding) {\n      const contentType = parseContentType(data.type) || parseContentType(\"text/plain\");\n      const sniffOptions = {\n        transportLayerEncodingLabel: contentType.get(\"charset\"),\n        defaultEncoding\n      };\n\n      const encoding = options.detectMetaCharset ? sniffHTMLEncoding(data.buffer, sniffOptions) :\n                       whatwgEncoding.getBOMEncoding(data.buffer) ||\n                       whatwgEncoding.labelToName(contentType.get(\"charset\")) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(data.buffer, encoding);\n\n      contentType.set(\"charset\", encoding);\n      data.type = contentType.toString();\n\n      callback(null, decoded, { headers: { \"content-type\": data.type } });\n    } else {\n      callback(null, data.buffer, { headers: { \"content-type\": data.type } });\n    }\n  } catch (err) {\n    callback(err, null);\n  }\n  return null;\n}\n\n// NOTE: request wraps tough-cookie cookie jar\n// (see: https://github.com/request/request/blob/master/lib/cookies.js).\n// Therefore, to pass our cookie jar to the request, we need to create\n// request's wrapper and monkey patch it with our jar.\nfunction wrapCookieJarForRequest(cookieJar) {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n}\n\nfunction fetch(urlObj, options, callback) {\n  if (urlObj.protocol === \"data:\") {\n    return readDataUrl(urlObj.href, options, callback);\n  } else if (urlObj.hostname) {\n    return exports.download(urlObj, options, callback);\n  }\n  const filePath = urlObj.pathname\n    .replace(/^file:\\/\\//, \"\")\n    .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n    .replace(/%20/g, \" \");\n  return exports.readFile(filePath, options, callback);\n}\n\nexports.enqueue = function (element, resourceUrl, callback) {\n  const document = element.nodeType === NODE_TYPE.DOCUMENT_NODE ? element : element._ownerDocument;\n\n  if (document._queue) {\n    const loadHandler = createResourceLoadHandler(element, resourceUrl || document.URL, document, callback);\n    return document._queue.push(loadHandler);\n  }\n\n  return () => {\n    // do nothing in queue-less documents\n  };\n};\n\nexports.download = function (url, options, callback) {\n  const requestOptions = {\n    pool: options.pool,\n    agent: options.agent,\n    agentOptions: options.agentOptions,\n    agentClass: options.agentClass,\n    strictSSL: options.strictSSL,\n    gzip: true,\n    jar: wrapCookieJarForRequest(options.cookieJar),\n    encoding: null,\n    headers: {\n      \"User-Agent\": options.userAgent,\n      \"Accept-Language\": \"en\",\n      Accept: options.accept || \"*/*\"\n    }\n  };\n  if (options.referrer && !IS_BROWSER) {\n    requestOptions.headers.referer = options.referrer;\n  }\n  if (options.proxy) {\n    requestOptions.proxy = options.proxy;\n  }\n  Object.assign(requestOptions.headers, options.headers);\n\n  const defaultEncoding = options.defaultEncoding;\n  const detectMetaCharset = options.detectMetaCharset;\n\n  const req = request(url, requestOptions, (error, response, bufferData) => {\n    if (!error) {\n      // If default encoding does not exist, pass on binary data.\n      if (defaultEncoding) {\n        const contentType = parseContentType(response.headers[\"content-type\"]) || parseContentType(\"text/plain\");\n        const sniffOptions = {\n          transportLayerEncodingLabel: contentType.get(\"charset\"),\n          defaultEncoding\n        };\n\n        const encoding = detectMetaCharset ? sniffHTMLEncoding(bufferData, sniffOptions) :\n                        whatwgEncoding.getBOMEncoding(bufferData) ||\n                        whatwgEncoding.labelToName(contentType.get(\"charset\")) || defaultEncoding;\n        const decoded = whatwgEncoding.decode(bufferData, encoding);\n\n        contentType.set(\"charset\", encoding);\n        response.headers[\"content-type\"] = contentType.toString();\n\n        callback(null, decoded, response);\n      } else {\n        callback(null, bufferData, response);\n      }\n    } else {\n      callback(error, null, response);\n    }\n  });\n  return {\n    abort() {\n      req.abort();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nexports.load = function (element, urlString, options, callback) {\n  const document = element._ownerDocument;\n  const documentImpl = document.implementation;\n\n  if (!documentImpl._hasFeature(\"FetchExternalResources\", element.tagName.toLowerCase())) {\n    return;\n  }\n\n  if (documentImpl._hasFeature(\"SkipExternalResources\", urlString)) {\n    return;\n  }\n\n  const urlObj = URL.parse(urlString);\n  const enqueued = exports.enqueue(element, urlString, callback);\n  const customLoader = document._customResourceLoader;\n  const requestManager = document._requestManager;\n  const cookieJar = document._cookieJar;\n\n  options.accept = element._accept;\n  options.cookieJar = cookieJar;\n  options.referrer = document.URL;\n  options.pool = document._pool;\n  options.agentOptions = document._agentOptions;\n  options.strictSSL = document._strictSSL;\n  options.proxy = document._proxy;\n  options.userAgent = document._defaultView.navigator.userAgent;\n\n  let req = null;\n  function wrappedEnqueued() {\n    if (req && requestManager) {\n      requestManager.remove(req);\n    }\n    // do not trigger if the window is closed\n    if (element._ownerDocument && element._ownerDocument.defaultView.document) {\n      enqueued.apply(this, arguments);\n    }\n  }\n  if (typeof customLoader === \"function\") {\n    req = customLoader({\n      element,\n      url: urlObj,\n      cookie: cookieJar.getCookieStringSync(urlObj, { http: true }),\n      baseUrl: documentBaseURLSerialized(document),\n      defaultFetch(fetchCallback) {\n        return fetch(urlObj, options, fetchCallback);\n      }\n    },\n    wrappedEnqueued);\n  } else {\n    req = fetch(urlObj, options, wrappedEnqueued);\n  }\n  if (req && requestManager) {\n    requestManager.add(req);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Comment.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst CharacterData = require(\"./CharacterData.js\");\nconst impl = utils.implSymbol;\n\nfunction Comment() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  } else {\n    args[0] = \"\";\n  }\n\n  iface.setup(this, args);\n}\nComment.prototype = Object.create(CharacterData.interface.prototype);\nComment.prototype.constructor = Comment;\n\n\nComment.prototype.toString = function () {\n  if (this === Comment.prototype) {\n    return \"[object CommentPrototype]\";\n  }\n  return CharacterData.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Comment.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Comment.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    CharacterData._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Comment,\n  expose: {\n    Window: { Comment: Comment }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/Comment-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/CharacterData.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Node = require(\"./Node.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst ChildNode = require(\"./ChildNode.js\");\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode.js\");\n\nfunction CharacterData() {\n  throw new TypeError(\"Illegal constructor\");\n}\nCharacterData.prototype = Object.create(Node.interface.prototype);\nCharacterData.prototype.constructor = CharacterData;\n\nmixin(CharacterData.prototype, ChildNode.interface.prototype);\nChildNode.mixedInto.push(CharacterData);\nmixin(CharacterData.prototype, NonDocumentTypeChildNode.interface.prototype);\nNonDocumentTypeChildNode.mixedInto.push(CharacterData);\n\nCharacterData.prototype.substringData = function substringData(offset, count) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'substringData' on 'CharacterData': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"unsigned long\"](args[0]);\n  args[1] = conversions[\"unsigned long\"](args[1]);\n  return this[impl].substringData.apply(this[impl], args);\n};\n\nCharacterData.prototype.appendData = function appendData(data) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'appendData' on 'CharacterData': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].appendData.apply(this[impl], args);\n};\n\nCharacterData.prototype.insertData = function insertData(offset, data) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'insertData' on 'CharacterData': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"unsigned long\"](args[0]);\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return this[impl].insertData.apply(this[impl], args);\n};\n\nCharacterData.prototype.deleteData = function deleteData(offset, count) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'deleteData' on 'CharacterData': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"unsigned long\"](args[0]);\n  args[1] = conversions[\"unsigned long\"](args[1]);\n  return this[impl].deleteData.apply(this[impl], args);\n};\n\nCharacterData.prototype.replaceData = function replaceData(offset, count, data) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 3) {\n    throw new TypeError(\"Failed to execute 'replaceData' on 'CharacterData': 3 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"unsigned long\"](args[0]);\n  args[1] = conversions[\"unsigned long\"](args[1]);\n  args[2] = conversions[\"DOMString\"](args[2]);\n  return this[impl].replaceData.apply(this[impl], args);\n};\n\nCharacterData.prototype.toString = function () {\n  if (this === CharacterData.prototype) {\n    return \"[object CharacterDataPrototype]\";\n  }\n  return Node.interface.prototype.toString.call(this);\n};\nObject.defineProperty(CharacterData.prototype, \"data\", {\n  get() {\n    return this[impl].data;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].data = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(CharacterData.prototype, \"length\", {\n  get() {\n    return this[impl].length;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(CharacterData.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(CharacterData.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Node._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: CharacterData,\n  expose: {\n    Window: { CharacterData: CharacterData }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/CharacterData-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/NonDocumentTypeChildNode.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction NonDocumentTypeChildNode() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nNonDocumentTypeChildNode.prototype.toString = function () {\n  if (this === NonDocumentTypeChildNode.prototype) {\n    return \"[object NonDocumentTypeChildNodePrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(NonDocumentTypeChildNode.prototype, \"previousElementSibling\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].previousElementSibling);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NonDocumentTypeChildNode.prototype, \"nextElementSibling\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].nextElementSibling);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(NonDocumentTypeChildNode.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(NonDocumentTypeChildNode.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: NonDocumentTypeChildNode,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/NonDocumentTypeChildNode-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/NonDocumentTypeChildNode-impl.js":"\"use strict\";\n\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst NODE_TYPE = require(\"../node-type\");\n\nclass NonDocumentTypeChildNodeImpl {\n  get nextElementSibling() {\n    for (const sibling of domSymbolTree.nextSiblingsIterator(this)) {\n      if (sibling.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        return sibling;\n      }\n    }\n    return null;\n  }\n\n  get previousElementSibling() {\n    for (const sibling of domSymbolTree.previousSiblingsIterator(this)) {\n      if (sibling.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        return sibling;\n      }\n    }\n    return null;\n  }\n}\n\nmodule.exports = {\n  implementation: NonDocumentTypeChildNodeImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/CharacterData-impl.js":"\"use strict\";\n\nconst idlUtils = require(\"../generated/utils\");\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\nconst NonDocumentTypeChildNodeImpl = require(\"./NonDocumentTypeChildNode-impl\").implementation;\nconst DOMException = require(\"../../web-idl/DOMException\");\n\nclass CharacterDataImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._data = privateData.data;\n  }\n\n  get data() {\n    return this._data;\n  }\n  set data(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  }\n\n  substringData(offset, count) {\n    const length = this.length;\n\n    if (offset > length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n\n    if (offset + count > length) {\n      return this._data.substring(offset);\n    }\n\n    return this._data.substring(offset, offset + count);\n  }\n\n  appendData(data) {\n    this.replaceData(this.length, 0, data);\n  }\n\n  insertData(offset, data) {\n    this.replaceData(offset, 0, data);\n  }\n\n  deleteData(offset, count) {\n    this.replaceData(offset, count, \"\");\n  }\n\n  replaceData(offset, count, data) {\n    const length = this.length;\n\n    if (offset > length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n\n    if (offset + count > length) {\n      count = length - offset;\n    }\n\n    const start = this._data.substring(0, offset);\n    const end = this._data.substring(offset + count);\n\n    this._data = start + data + end;\n\n    // TODO: range stuff\n  }\n}\n\nidlUtils.mixin(CharacterDataImpl.prototype, NonDocumentTypeChildNodeImpl.prototype);\nidlUtils.mixin(CharacterDataImpl.prototype, ChildNodeImpl.prototype);\n\nmodule.exports = {\n  implementation: CharacterDataImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/Comment-impl.js":"\"use strict\";\n\nconst CharacterDataImpl = require(\"./CharacterData-impl\").implementation;\n\nconst NODE_TYPE = require(\"../node-type\");\n\nclass CommentImpl extends CharacterDataImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this.nodeType = NODE_TYPE.COMMENT_NODE;\n  }\n}\n\nmodule.exports = {\n  implementation: CommentImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ProcessingInstruction.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst CharacterData = require(\"./CharacterData.js\");\nconst impl = utils.implSymbol;\n\nfunction ProcessingInstruction() {\n  throw new TypeError(\"Illegal constructor\");\n}\nProcessingInstruction.prototype = Object.create(CharacterData.interface.prototype);\nProcessingInstruction.prototype.constructor = ProcessingInstruction;\n\n\nProcessingInstruction.prototype.toString = function () {\n  if (this === ProcessingInstruction.prototype) {\n    return \"[object ProcessingInstructionPrototype]\";\n  }\n  return CharacterData.interface.prototype.toString.call(this);\n};\nObject.defineProperty(ProcessingInstruction.prototype, \"target\", {\n  get() {\n    return this[impl].target;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(ProcessingInstruction.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(ProcessingInstruction.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    CharacterData._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: ProcessingInstruction,\n  expose: {\n    Window: { ProcessingInstruction: ProcessingInstruction }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/ProcessingInstruction-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/ProcessingInstruction-impl.js":"\"use strict\";\n\nconst CharacterDataImpl = require(\"./CharacterData-impl\").implementation;\n\nconst NODE_TYPE = require(\"../node-type\");\n\nclass ProcessingInstructionImpl extends CharacterDataImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this.nodeType = NODE_TYPE.PROCESSING_INSTRUCTION_NODE;\n    this._target = privateData.target;\n  }\n\n  get target() {\n    return this._target;\n  }\n}\n\nmodule.exports = {\n  implementation: ProcessingInstructionImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/CDATASection.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Text = require(\"./Text.js\");\nconst impl = utils.implSymbol;\n\nfunction CDATASection() {\n  throw new TypeError(\"Illegal constructor\");\n}\nCDATASection.prototype = Object.create(Text.interface.prototype);\nCDATASection.prototype.constructor = CDATASection;\n\n\nCDATASection.prototype.toString = function () {\n  if (this === CDATASection.prototype) {\n    return \"[object CDATASectionPrototype]\";\n  }\n  return Text.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(CDATASection.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(CDATASection.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Text._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: CDATASection,\n  expose: {\n    Window: { CDATASection: CDATASection }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/CDATASection-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Text.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst CharacterData = require(\"./CharacterData.js\");\nconst impl = utils.implSymbol;\n\nfunction Text() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  } else {\n    args[0] = \"\";\n  }\n\n  iface.setup(this, args);\n}\nText.prototype = Object.create(CharacterData.interface.prototype);\nText.prototype.constructor = Text;\n\n\nText.prototype.splitText = function splitText(offset) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'splitText' on 'Text': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"unsigned long\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].splitText.apply(this[impl], args));\n};\n\nText.prototype.toString = function () {\n  if (this === Text.prototype) {\n    return \"[object TextPrototype]\";\n  }\n  return CharacterData.interface.prototype.toString.call(this);\n};\nObject.defineProperty(Text.prototype, \"wholeText\", {\n  get() {\n    return this[impl].wholeText;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Text.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Text.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    CharacterData._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Text,\n  expose: {\n    Window: { Text: Text }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/Text-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/Text-impl.js":"\"use strict\";\n\nconst CharacterDataImpl = require(\"./CharacterData-impl\").implementation;\n\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst NODE_TYPE = require(\"../node-type\");\n\nclass TextImpl extends CharacterDataImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this.nodeType = NODE_TYPE.TEXT_NODE;\n  }\n\n  splitText(offset) {\n    offset >>>= 0;\n\n    const length = this.length;\n\n    if (offset > length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n\n    const count = length - offset;\n    const newData = this.substringData(offset, count);\n\n    const newNode = this._ownerDocument.createTextNode(newData);\n\n    const parent = domSymbolTree.parent(this);\n\n    if (parent !== null) {\n      parent.insertBefore(newNode, this.nextSibling);\n    }\n\n    this.replaceData(offset, count, \"\");\n\n    return newNode;\n\n    // TODO: range stuff\n  }\n\n  get wholeText() {\n    let wholeText = this.textContent;\n    let next;\n    let current = this;\n    while ((next = domSymbolTree.previousSibling(current)) && next.nodeType === NODE_TYPE.TEXT_NODE) {\n      wholeText = next.textContent + wholeText;\n      current = next;\n    }\n    current = this;\n    while ((next = domSymbolTree.nextSibling(current)) && next.nodeType === NODE_TYPE.TEXT_NODE) {\n      wholeText += next.textContent;\n      current = next;\n    }\n    return wholeText;\n  }\n}\n\nmodule.exports = {\n  implementation: TextImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/CDATASection-impl.js":"\"use strict\";\n\nconst TextImpl = require(\"./Text-impl\").implementation;\nconst NODE_TYPE = require(\"../node-type\");\n\nclass CDATASectionImpl extends TextImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this.nodeType = NODE_TYPE.CDATA_SECTION_NODE;\n  }\n}\n\nmodule.exports = {\n  implementation: CDATASectionImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/DocumentFragment.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Node = require(\"./Node.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst ParentNode = require(\"./ParentNode.js\");\n\nfunction DocumentFragment() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n\n  iface.setup(this, args);\n}\nDocumentFragment.prototype = Object.create(Node.interface.prototype);\nDocumentFragment.prototype.constructor = DocumentFragment;\n\nmixin(DocumentFragment.prototype, ParentNode.interface.prototype);\nParentNode.mixedInto.push(DocumentFragment);\n\nDocumentFragment.prototype.toString = function () {\n  if (this === DocumentFragment.prototype) {\n    return \"[object DocumentFragmentPrototype]\";\n  }\n  return Node.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(DocumentFragment.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(DocumentFragment.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Node._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: DocumentFragment,\n  expose: {\n    Window: { DocumentFragment: DocumentFragment }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/DocumentFragment-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/DocumentFragment-impl.js":"\"use strict\";\n\nconst idlUtils = require(\"../generated/utils\");\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nconst NODE_TYPE = require(\"../node-type\");\n\nclass DocumentFragmentImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this.nodeType = NODE_TYPE.DOCUMENT_FRAGMENT_NODE;\n  }\n}\n\nidlUtils.mixin(DocumentFragmentImpl.prototype, ParentNodeImpl.prototype);\n\nmodule.exports = {\n  implementation: DocumentFragmentImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/DOMImplementation.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction DOMImplementation() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nDOMImplementation.prototype.createDocumentType = function createDocumentType(qualifiedName, publicId, systemId) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 3) {\n    throw new TypeError(\"Failed to execute 'createDocumentType' on 'DOMImplementation': 3 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"DOMString\"](args[1]);\n  args[2] = conversions[\"DOMString\"](args[2]);\n  return utils.tryWrapperForImpl(this[impl].createDocumentType.apply(this[impl], args));\n};\n\nDOMImplementation.prototype.createDocument = function createDocument(namespace, qualifiedName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'createDocument' on 'DOMImplementation': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1], { treatNullAsEmptyString: true });\n  if (args[2] === null || args[2] === undefined) {\n    args[2] = null;\n  } else {\n  }\n  return utils.tryWrapperForImpl(this[impl].createDocument.apply(this[impl], args));\n};\n\nDOMImplementation.prototype.createHTMLDocument = function createHTMLDocument() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  return utils.tryWrapperForImpl(this[impl].createHTMLDocument.apply(this[impl], args));\n};\n\nDOMImplementation.prototype.hasFeature = function hasFeature() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].hasFeature.apply(this[impl], args);\n};\n\nDOMImplementation.prototype.toString = function () {\n  if (this === DOMImplementation.prototype) {\n    return \"[object DOMImplementationPrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(DOMImplementation.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(DOMImplementation.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: DOMImplementation,\n  expose: {\n    Window: { DOMImplementation: DOMImplementation }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/DOMImplementation-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/DOMImplementation-impl.js":"\"use strict\";\n\nconst vm = require(\"vm\");\nconst validateNames = require(\"../helpers/validate-names\");\nconst DocumentType = require(\"../generated/DocumentType\");\nconst Document = require(\"../generated/Document\");\n\nclass DOMImplementationImpl {\n  constructor(args, privateData) {\n    this.core = privateData.core;\n    this._ownerDocument = privateData.ownerDocument;\n    this._features = Object.create(null);\n  }\n\n  hasFeature() {\n    return true;\n  }\n\n  createDocumentType(qualifiedName, publicId, systemId) {\n    validateNames.qname(qualifiedName);\n\n    return DocumentType.createImpl([], {\n      core: this.core,\n      ownerDocument: this._ownerDocument,\n      name: qualifiedName,\n      publicId,\n      systemId\n    });\n  }\n\n  createDocument(namespace, qualifiedName, doctype) {\n    namespace = namespace !== null ? String(namespace) : namespace;\n    qualifiedName = qualifiedName === null ? \"\" : String(qualifiedName);\n    if (doctype === undefined) {\n      doctype = null;\n    }\n\n    const document = Document.createImpl([], {\n      core: this.core,\n      options: { parsingMode: \"xml\", encoding: \"UTF-8\" }\n    });\n\n    let element = null;\n    if (qualifiedName !== \"\") {\n      element = document.createElementNS(namespace, qualifiedName);\n    }\n\n    if (doctype !== null) {\n      document.appendChild(doctype);\n    }\n\n    if (element !== null) {\n      document.appendChild(element);\n    }\n\n    return document;\n  }\n\n  createHTMLDocument(title) {\n    // Let doc be a new document that is an HTML document.\n    // Set doc's content type to \"text/html\".\n    const document = Document.createImpl([], {\n      core: this.core,\n      options: { parsingMode: \"html\", encoding: \"UTF-8\" }\n    });\n\n    // Create a doctype, with \"html\" as its name and with its node document set\n    // to doc. Append the newly created node to doc.\n    const doctype = DocumentType.createImpl([], {\n      core: this.core,\n      ownerDocument: this,\n      name: \"html\",\n      publicId: \"\",\n      systemId: \"\"\n    });\n\n    document.appendChild(doctype);\n\n    // Create an html element in the HTML namespace, and append it to doc.\n    const htmlElement = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"html\");\n    document.appendChild(htmlElement);\n\n    // Create a head element in the HTML namespace, and append it to the html\n    // element created in the previous step.\n    const headElement = document.createElement(\"head\");\n    htmlElement.appendChild(headElement);\n\n    // If the title argument is not omitted:\n    if (title !== undefined) {\n      // Create a title element in the HTML namespace, and append it to the head\n      // element created in the previous step.\n      const titleElement = document.createElement(\"title\");\n      headElement.appendChild(titleElement);\n\n      // Create a Text node, set its data to title (which could be the empty\n      // string), and append it to the title element created in the previous step.\n      titleElement.appendChild(document.createTextNode(title));\n    }\n\n    // Create a body element in the HTML namespace, and append it to the html\n    // element created in the earlier step.\n    htmlElement.appendChild(document.createElement(\"body\"));\n\n    // doc's origin is an alias to the origin of the context object's associated\n    // document, and doc's effective script origin is an alias to the effective\n    // script origin of the context object's associated document.\n\n    return document;\n  }\n\n  _removeFeature(feature, version) {\n    feature = feature.toLowerCase();\n    if (this._features[feature]) {\n      if (version) {\n        const versions = this._features[feature];\n        for (let j = 0; j < versions.length; j++) {\n          if (versions[j] === version) {\n            versions.splice(j, 1);\n            return;\n          }\n        }\n      } else {\n        delete this._features[feature];\n      }\n    }\n  }\n\n  _addFeature(feature, version) {\n    feature = feature.toLowerCase();\n\n    if (version) {\n      if (!this._features[feature]) {\n        this._features[feature] = [];\n      }\n\n      if (version instanceof Array) {\n        Array.prototype.push.apply(this._features[feature], version);\n      } else {\n        this._features[feature].push(version);\n      }\n\n      if (feature === \"processexternalresources\" &&\n          (version === \"script\" || (version.indexOf && version.indexOf(\"script\") !== -1)) &&\n          !vm.isContext(this._ownerDocument._global)) {\n        vm.createContext(this._ownerDocument._global);\n        this._ownerDocument._defaultView._globalProxy = vm.runInContext(\"this\", this._ownerDocument._global);\n        this._ownerDocument._defaultView = this._ownerDocument._defaultView._globalProxy;\n      }\n    }\n  }\n\n  _hasFeature(feature, version) {\n    feature = feature ? feature.toLowerCase() : \"\";\n    const versions = this._features[feature] || false;\n\n    if (!version && versions.length && versions.length > 0) {\n      return true;\n    } else if (typeof versions === \"string\") {\n      return versions === version;\n    } else if (versions.indexOf && versions.length > 0) {\n      for (let i = 0; i < versions.length; i++) {\n        const found = versions[i] instanceof RegExp ? versions[i].test(version) : versions[i] === version;\n        if (found) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return false;\n  }\n}\n\nmodule.exports = {\n  implementation: DOMImplementationImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Element = require(\"./Element.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst ElementCSSInlineStyle = require(\"./ElementCSSInlineStyle.js\");\nconst GlobalEventHandlers = require(\"./GlobalEventHandlers.js\");\nconst ElementContentEditable = require(\"./ElementContentEditable.js\");\n\nfunction HTMLElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLElement.prototype = Object.create(Element.interface.prototype);\nHTMLElement.prototype.constructor = HTMLElement;\n\nmixin(HTMLElement.prototype, ElementCSSInlineStyle.interface.prototype);\nElementCSSInlineStyle.mixedInto.push(HTMLElement);\nmixin(HTMLElement.prototype, GlobalEventHandlers.interface.prototype);\nGlobalEventHandlers.mixedInto.push(HTMLElement);\nmixin(HTMLElement.prototype, ElementContentEditable.interface.prototype);\nElementContentEditable.mixedInto.push(HTMLElement);\n\nHTMLElement.prototype.click = function click() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].click.apply(this[impl], args);\n};\n\nHTMLElement.prototype.focus = function focus() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].focus.apply(this[impl], args);\n};\n\nHTMLElement.prototype.blur = function blur() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].blur.apply(this[impl], args);\n};\n\nHTMLElement.prototype.toString = function () {\n  if (this === HTMLElement.prototype) {\n    return \"[object HTMLElementPrototype]\";\n  }\n  return Element.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLElement.prototype, \"title\", {\n  get() {\n    const value = this.getAttribute(\"title\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"title\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"lang\", {\n  get() {\n    const value = this.getAttribute(\"lang\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"lang\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"dir\", {\n  get() {\n    const value = this.getAttribute(\"dir\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"dir\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"hidden\", {\n  get() {\n    return this.hasAttribute(\"hidden\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"hidden\", \"\");\n  } else {\n    this.removeAttribute(\"hidden\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"tabIndex\", {\n  get() {\n    return this[impl].tabIndex;\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this[impl].tabIndex = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"accessKey\", {\n  get() {\n    const value = this.getAttribute(\"accessKey\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"accessKey\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"offsetParent\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].offsetParent);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"offsetTop\", {\n  get() {\n    return this[impl].offsetTop;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"offsetLeft\", {\n  get() {\n    return this[impl].offsetLeft;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"offsetWidth\", {\n  get() {\n    return this[impl].offsetWidth;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLElement.prototype, \"offsetHeight\", {\n  get() {\n    return this[impl].offsetHeight;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Element._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLElement,\n  expose: {\n    Window: { HTMLElement: HTMLElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Element.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Node = require(\"./Node.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst ChildNode = require(\"./ChildNode.js\");\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode.js\");\nconst ParentNode = require(\"./ParentNode.js\");\n\nfunction Element() {\n  throw new TypeError(\"Illegal constructor\");\n}\nElement.prototype = Object.create(Node.interface.prototype);\nElement.prototype.constructor = Element;\n\nmixin(Element.prototype, ChildNode.interface.prototype);\nChildNode.mixedInto.push(Element);\nmixin(Element.prototype, NonDocumentTypeChildNode.interface.prototype);\nNonDocumentTypeChildNode.mixedInto.push(Element);\nmixin(Element.prototype, ParentNode.interface.prototype);\nParentNode.mixedInto.push(Element);\n\nElement.prototype.hasAttributes = function hasAttributes() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].hasAttributes.apply(this[impl], args);\n};\n\nElement.prototype.getAttributeNames = function getAttributeNames() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].getAttributeNames.apply(this[impl], args));\n};\n\nElement.prototype.getAttribute = function getAttribute(qualifiedName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getAttribute' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].getAttribute.apply(this[impl], args);\n};\n\nElement.prototype.getAttributeNS = function getAttributeNS(namespace, localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'getAttributeNS' on 'Element': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return this[impl].getAttributeNS.apply(this[impl], args);\n};\n\nElement.prototype.setAttribute = function setAttribute(qualifiedName, value) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'setAttribute' on 'Element': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return this[impl].setAttribute.apply(this[impl], args);\n};\n\nElement.prototype.setAttributeNS = function setAttributeNS(namespace, qualifiedName, value) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 3) {\n    throw new TypeError(\"Failed to execute 'setAttributeNS' on 'Element': 3 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  args[2] = conversions[\"DOMString\"](args[2]);\n  return this[impl].setAttributeNS.apply(this[impl], args);\n};\n\nElement.prototype.removeAttribute = function removeAttribute(qualifiedName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'removeAttribute' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].removeAttribute.apply(this[impl], args);\n};\n\nElement.prototype.removeAttributeNS = function removeAttributeNS(namespace, localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'removeAttributeNS' on 'Element': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return this[impl].removeAttributeNS.apply(this[impl], args);\n};\n\nElement.prototype.hasAttribute = function hasAttribute(qualifiedName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'hasAttribute' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].hasAttribute.apply(this[impl], args);\n};\n\nElement.prototype.hasAttributeNS = function hasAttributeNS(namespace, localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'hasAttributeNS' on 'Element': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return this[impl].hasAttributeNS.apply(this[impl], args);\n};\n\nElement.prototype.getAttributeNode = function getAttributeNode(qualifiedName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getAttributeNode' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].getAttributeNode.apply(this[impl], args));\n};\n\nElement.prototype.getAttributeNodeNS = function getAttributeNodeNS(namespace, localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'getAttributeNodeNS' on 'Element': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return utils.tryWrapperForImpl(this[impl].getAttributeNodeNS.apply(this[impl], args));\n};\n\nElement.prototype.setAttributeNode = function setAttributeNode(attr) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'setAttributeNode' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].setAttributeNode.apply(this[impl], args));\n};\n\nElement.prototype.setAttributeNodeNS = function setAttributeNodeNS(attr) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'setAttributeNodeNS' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].setAttributeNodeNS.apply(this[impl], args));\n};\n\nElement.prototype.removeAttributeNode = function removeAttributeNode(attr) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'removeAttributeNode' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].removeAttributeNode.apply(this[impl], args));\n};\n\nElement.prototype.matches = function matches(selectors) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'matches' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].matches.apply(this[impl], args);\n};\n\nElement.prototype.webkitMatchesSelector = function webkitMatchesSelector(selectors) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'webkitMatchesSelector' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].webkitMatchesSelector.apply(this[impl], args);\n};\n\nElement.prototype.getElementsByTagName = function getElementsByTagName(localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getElementsByTagName' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].getElementsByTagName.apply(this[impl], args));\n};\n\nElement.prototype.getElementsByTagNameNS = function getElementsByTagNameNS(namespace, localName) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'getElementsByTagNameNS' on 'Element': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return utils.tryWrapperForImpl(this[impl].getElementsByTagNameNS.apply(this[impl], args));\n};\n\nElement.prototype.getElementsByClassName = function getElementsByClassName(classNames) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getElementsByClassName' on 'Element': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].getElementsByClassName.apply(this[impl], args));\n};\n\nElement.prototype.insertAdjacentHTML = function insertAdjacentHTML(position, text) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'insertAdjacentHTML' on 'Element': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"DOMString\"](args[1]);\n  return this[impl].insertAdjacentHTML.apply(this[impl], args);\n};\n\nElement.prototype.getClientRects = function getClientRects() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].getClientRects.apply(this[impl], args));\n};\n\nElement.prototype.getBoundingClientRect = function getBoundingClientRect() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].getBoundingClientRect.apply(this[impl], args));\n};\n\nElement.prototype.toString = function () {\n  if (this === Element.prototype) {\n    return \"[object ElementPrototype]\";\n  }\n  return Node.interface.prototype.toString.call(this);\n};\nObject.defineProperty(Element.prototype, \"namespaceURI\", {\n  get() {\n    return this[impl].namespaceURI;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"prefix\", {\n  get() {\n    return this[impl].prefix;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"localName\", {\n  get() {\n    return this[impl].localName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"tagName\", {\n  get() {\n    return this[impl].tagName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"id\", {\n  get() {\n    const value = this.getAttribute(\"id\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"id\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"className\", {\n  get() {\n    const value = this.getAttribute(\"class\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"class\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"classList\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].classList);\n  },\n  set(V) {\n    this.classList.value = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"attributes\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].attributes);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"innerHTML\", {\n  get() {\n    return this[impl].innerHTML;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].innerHTML = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"outerHTML\", {\n  get() {\n    return this[impl].outerHTML;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].outerHTML = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"scrollTop\", {\n  get() {\n    return this[impl].scrollTop;\n  },\n  set(V) {\n    V = conversions[\"unrestricted double\"](V);\n    this[impl].scrollTop = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"scrollLeft\", {\n  get() {\n    return this[impl].scrollLeft;\n  },\n  set(V) {\n    V = conversions[\"unrestricted double\"](V);\n    this[impl].scrollLeft = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"scrollWidth\", {\n  get() {\n    return this[impl].scrollWidth;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"scrollHeight\", {\n  get() {\n    return this[impl].scrollHeight;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"clientTop\", {\n  get() {\n    return this[impl].clientTop;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"clientLeft\", {\n  get() {\n    return this[impl].clientLeft;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"clientWidth\", {\n  get() {\n    return this[impl].clientWidth;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Element.prototype, \"clientHeight\", {\n  get() {\n    return this[impl].clientHeight;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Element.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Element.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Node._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Element,\n  expose: {\n    Window: { Element: Element }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/Element-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/Element-impl.js":"\"use strict\";\nconst vm = require(\"vm\");\nconst nwmatcher = require(\"nwmatcher/src/nwmatcher-noqsa\");\nconst idlUtils = require(\"../generated/utils\");\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\nconst attributes = require(\"../attributes\");\nconst namedPropertiesWindow = require(\"../named-properties-window\");\nconst NODE_TYPE = require(\"../node-type\");\nconst domToHtml = require(\"../../browser/domtohtml\").domToHtml;\nconst memoizeQuery = require(\"../../utils\").memoizeQuery;\nconst clone = require(\"../node\").clone;\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst resetDOMTokenList = require(\"../dom-token-list\").reset;\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst createDOMTokenList = require(\"../dom-token-list\").create;\nconst attrGenerated = require(\"../generated/Attr\");\nconst validateNames = require(\"../helpers/validate-names\");\nconst listOfElementsWithQualifiedName = require(\"../node\").listOfElementsWithQualifiedName;\nconst listOfElementsWithNamespaceAndLocalName = require(\"../node\").listOfElementsWithNamespaceAndLocalName;\nconst listOfElementsWithClassNames = require(\"../node\").listOfElementsWithClassNames;\nconst proxiedWindowEventHandlers = require(\"../helpers/proxied-window-event-handlers\");\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\n\n// nwmatcher gets `document.documentElement` at creation-time, so we have to initialize lazily, since in the initial\n// stages of Document initialization, there is no documentElement present yet.\nfunction addNwmatcher(parentNode) {\n  const document = parentNode._ownerDocument;\n\n  if (!document._nwmatcher) {\n    document._nwmatcher = nwmatcher({ document });\n    document._nwmatcher.configure({ UNIQUE_ID: false });\n  }\n\n  return document._nwmatcher;\n}\n\nfunction clearChildNodes(node) {\n  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction setInnerHTML(document, node, html) {\n  // Clear the children first:\n  if (node._templateContents) {\n    clearChildNodes(node._templateContents);\n  } else {\n    clearChildNodes(node);\n  }\n\n  if (html !== \"\") {\n    if (node.nodeName === \"#document\") {\n      document._htmlToDom.appendHtmlToDocument(html, node);\n    } else {\n      document._htmlToDom.appendHtmlToElement(html, node);\n    }\n  }\n}\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      const elms = doc._ids[id];\n      for (let i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nclass ElementImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n\n    this._namespaceURI = null;\n    this._prefix = null;\n    this._localName = privateData.localName;\n    this._attributes = attributes.createNamedNodeMap(this);\n  }\n\n  _attach() {\n    namedPropertiesWindow.nodeAttachedToDocument(this);\n\n    const id = this.getAttribute(\"id\");\n    if (id) {\n      attachId(id, this, this._ownerDocument);\n    }\n\n    super._attach();\n  }\n\n  _detach() {\n    super._detach();\n\n    namedPropertiesWindow.nodeDetachedFromDocument(this);\n\n    const id = this.getAttribute(\"id\");\n    if (id) {\n      detachId(id, this, this._ownerDocument);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    this._modified();\n    namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n    if (name === \"id\" && this._attached) {\n      const doc = this._ownerDocument;\n      detachId(oldValue, this, doc);\n      attachId(value, this, doc);\n    }\n\n    const w = this._ownerDocument._global;\n\n    // TODO event handlers:\n    // The correct way to do this is lazy, and a bit more complicated; see\n    // https://html.spec.whatwg.org/multipage/webappapis.html#event-handler-content-attributes\n    // It would only be possible if we had proper getters/setters for every event handler, which we don't right now.\n    if (name.length > 2 && name[0] === \"o\" && name[1] === \"n\") {\n      // If this document does not have a window, set IDL attribute to null\n      // step 2: https://html.spec.whatwg.org/multipage/webappapis.html#getting-the-current-value-of-the-event-handler\n      if (value && w) {\n        const self = proxiedWindowEventHandlers.has(name) && this._localName === \"body\" ? w : this;\n        const vmOptions = { filename: this._ownerDocument.URL, displayErrors: false };\n\n        // The handler code probably refers to functions declared globally on the window, so we need to run it in\n        // that context. In fact, it's worse; see\n        // https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/bindings/core/v8/V8LazyEventListener.cpp\n        // plus the spec, which show how multiple nested scopes are technically required. We won't implement that\n        // until someone asks for it, though.\n\n        // https://html.spec.whatwg.org/multipage/webappapis.html#the-event-handler-processing-algorithm\n\n        if (name === \"onerror\" && self === w) {\n          // https://html.spec.whatwg.org/multipage/webappapis.html#getting-the-current-value-of-the-event-handler\n          // step 10\n\n          self[name] = function (event, source, lineno, colno, error) {\n            w.__tempEventHandlerThis = this;\n            w.__tempEventHandlerEvent = event;\n            w.__tempEventHandlerSource = source;\n            w.__tempEventHandlerLineno = lineno;\n            w.__tempEventHandlerColno = colno;\n            w.__tempEventHandlerError = error;\n\n            try {\n              return vm.runInContext(`\n                (function (event, source, lineno, colno, error) {\n                  ${value}\n                }).call(__tempEventHandlerThis, __tempEventHandlerEvent, __tempEventHandlerSource,\n                        __tempEventHandlerLineno, __tempEventHandlerColno, __tempEventHandlerError)`, w, vmOptions);\n            } finally {\n              delete w.__tempEventHandlerThis;\n              delete w.__tempEventHandlerEvent;\n              delete w.__tempEventHandlerSource;\n              delete w.__tempEventHandlerLineno;\n              delete w.__tempEventHandlerColno;\n              delete w.__tempEventHandlerError;\n            }\n          };\n        } else {\n          self[name] = function (event) {\n            w.__tempEventHandlerThis = this;\n            w.__tempEventHandlerEvent = event;\n\n            try {\n              return vm.runInContext(`\n                (function (event) {\n                  ${value}\n                }).call(__tempEventHandlerThis, __tempEventHandlerEvent)`, w, vmOptions);\n            } finally {\n              delete w.__tempEventHandlerThis;\n              delete w.__tempEventHandlerEvent;\n            }\n          };\n        }\n      } else {\n        this[name] = null;\n      }\n    }\n\n    // update classList\n    if (name === \"class\") {\n      resetDOMTokenList(this.classList, value);\n    }\n  }\n\n  get namespaceURI() {\n    return this._namespaceURI;\n  }\n  get prefix() {\n    return this._prefix;\n  }\n  get localName() {\n    return this._localName;\n  }\n  get _qualifiedName() {\n    return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n  }\n  get tagName() {\n    let qualifiedName = this._qualifiedName;\n    if (this.namespaceURI === \"http://www.w3.org/1999/xhtml\" && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = qualifiedName.toUpperCase();\n    }\n    return qualifiedName;\n  }\n\n  get attributes() {\n    return this._attributes;\n  }\n\n  get outerHTML() {\n    return domToHtml([this]);\n  }\n\n  set outerHTML(html) {\n    if (html === null) {\n      html = \"\";\n    }\n\n    const parent = domSymbolTree.parent(this);\n    const document = this._ownerDocument;\n\n    if (!parent) {\n      return;\n    }\n\n    let contextElement;\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                  \"Modifications are not allowed for this document\");\n    } else if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      contextElement = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"body\");\n    } else if (parent.nodeType === NODE_TYPE.ELEMENT_NODE) {\n      contextElement = clone(this._core, parent, undefined, false);\n    } else {\n      throw new TypeError(\"This should never happen\");\n    }\n\n    document._htmlToDom.appendHtmlToElement(html, contextElement);\n\n    while (contextElement.firstChild) {\n      parent.insertBefore(contextElement.firstChild, this);\n    }\n\n    parent.removeChild(this);\n  }\n\n  get innerHTML() {\n    const tagName = this.tagName;\n    if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n      const type = this.getAttribute(\"type\");\n      if (!type || /^text\\//i.test(type) || /\\/javascript$/i.test(type)) {\n        return domToHtml(domSymbolTree.childrenIterator(this));\n      }\n    }\n\n    // In case of <template> we should pass its \"template contents\" fragment as a serialization root if we have one\n    if (this._templateContents) {\n      return domToHtml(domSymbolTree.childrenIterator(this._templateContents));\n    }\n\n    return domToHtml(domSymbolTree.childrenIterator(this));\n  }\n\n  set innerHTML(html) {\n    if (html === null) {\n      html = \"\";\n    }\n\n    setInnerHTML(this.ownerDocument, this, html);\n  }\n\n  get classList() {\n    if (this._classList === undefined) {\n      this._classList = createDOMTokenList(this, \"class\");\n    }\n    return this._classList;\n  }\n\n  hasAttributes() {\n    return attributes.hasAttributes(this);\n  }\n\n  getAttributeNames() {\n    return attributes.attributeNames(this);\n  }\n\n  getAttribute(name) {\n    return attributes.getAttributeValue(this, name);\n  }\n\n  getAttributeNS(namespace, localName) {\n    return attributes.getAttributeValueByNameNS(this, namespace, localName);\n  }\n\n  setAttribute(name, value) {\n    validateNames.name(name);\n\n    if (this._namespaceURI === \"http://www.w3.org/1999/xhtml\" && this._ownerDocument._parsingMode === \"html\") {\n      name = name.toLowerCase();\n    }\n\n    const attribute = attributes.getAttributeByName(this, name);\n\n    if (attribute === null) {\n      const newAttr = attrGenerated.createImpl([], { localName: name, value });\n      attributes.appendAttribute(this, newAttr);\n      return;\n    }\n\n    attributes.changeAttribute(this, attribute, value);\n  }\n\n  setAttributeNS(namespace, name, value) {\n    const extracted = validateNames.validateAndExtract(namespace, name);\n\n    attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n  }\n\n  removeAttribute(name) {\n    attributes.removeAttributeByName(this, name);\n  }\n\n  removeAttributeNS(namespace, localName) {\n    attributes.removeAttributeByNameNS(this, namespace, localName);\n  }\n\n  hasAttribute(name) {\n    if (this._namespaceURI === \"http://www.w3.org/1999/xhtml\" && this._ownerDocument._parsingMode === \"html\") {\n      name = name.toLowerCase();\n    }\n\n    return attributes.hasAttributeByName(this, name);\n  }\n\n  hasAttributeNS(namespace, localName) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    return attributes.hasAttributeByNameNS(this, namespace, localName);\n  }\n\n  getAttributeNode(name) {\n    return attributes.getAttributeByName(this, name);\n  }\n\n  getAttributeNodeNS(namespace, localName) {\n    return attributes.getAttributeByNameNS(this, namespace, localName);\n  }\n\n  setAttributeNode(attr) {\n    if (!attrGenerated.isImpl(attr)) {\n      throw new TypeError(\"First argument to Element.prototype.setAttributeNode must be an Attr\");\n    }\n\n    return attributes.setAttribute(this, attr);\n  }\n\n  setAttributeNodeNS(attr) {\n    if (!attrGenerated.isImpl(attr)) {\n      throw new TypeError(\"First argument to Element.prototype.setAttributeNodeNS must be an Attr\");\n    }\n\n    return attributes.setAttribute(this, attr);\n  }\n\n  removeAttributeNode(attr) {\n    if (!attrGenerated.isImpl(attr)) {\n      throw new TypeError(\"First argument to Element.prototype.removeAttributeNode must be an Attr\");\n    }\n\n    if (!attributes.hasAttribute(this, attr)) {\n      throw new DOMException(DOMException.NOT_FOUND_ERR, \"Tried to remove an attribute that was not present\");\n    }\n\n    attributes.removeAttribute(this, attr);\n\n    return attr;\n  }\n\n  getBoundingClientRect() {\n    return {\n      bottom: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      width: 0\n    };\n  }\n\n  getClientRects() {\n    return [];\n  }\n\n  get scrollWidth() {\n    return 0;\n  }\n\n  get scrollHeight() {\n    return 0;\n  }\n\n  get clientTop() {\n    return 0;\n  }\n\n  get clientLeft() {\n    return 0;\n  }\n\n  get clientWidth() {\n    return 0;\n  }\n\n  get clientHeight() {\n    return 0;\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n  insertAdjacentHTML(position, text) {\n    position = position.toLowerCase();\n\n    let context;\n    switch (position) {\n      case \"beforebegin\":\n      case \"afterend\": {\n        context = this.parentNode;\n        if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n          throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, \"Cannot insert HTML adjacent to \" +\n            \"parent-less nodes or children of document nodes.\");\n        }\n        break;\n      }\n      case \"afterbegin\":\n      case \"beforeend\": {\n        context = this;\n        break;\n      }\n      default: {\n        throw new DOMException(DOMException.SYNTAX_ERR, \"Must provide one of \\\"beforebegin\\\", \\\"afterend\\\", \" +\n          \"\\\"afterbegin\\\", or \\\"beforeend\\\".\");\n      }\n    }\n\n    // TODO: use context for parsing instead of a <template>.\n    const fragment = this.ownerDocument.createElement(\"template\");\n    fragment.innerHTML = text;\n\n    switch (position) {\n      case \"beforebegin\": {\n        this.parentNode.insertBefore(fragment.content, this);\n        break;\n      }\n      case \"afterbegin\": {\n        this.insertBefore(fragment.content, this.firstChild);\n        break;\n      }\n      case \"beforeend\": {\n        this.appendChild(fragment.content);\n        break;\n      }\n      case \"afterend\": {\n        this.parentNode.insertBefore(fragment.content, this.nextSibling);\n        break;\n      }\n    }\n  }\n}\n\nidlUtils.mixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nidlUtils.mixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nidlUtils.mixin(ElementImpl.prototype, ChildNodeImpl.prototype);\n\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\n\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\n\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nElementImpl.prototype.matches = memoizeQuery(function (selectors) {\n  const matcher = addNwmatcher(this);\n\n  try {\n    return matcher.match(idlUtils.wrapperForImpl(this), selectors);\n  } catch (e) {\n    throw new DOMException(DOMException.SYNTAX_ERR, e.message);\n  }\n});\n\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\n\nmodule.exports = {\n  implementation: ElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/proxied-window-event-handlers.js":"\"use strict\";\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#event-handlers-on-elements,-document-objects,-and-window-objects\n\nmodule.exports = new Set([\"onblur\", \"onerror\", \"onfocus\", \"onload\", \"onresize\", \"onscroll\", \"onafterprint\",\n  \"onbeforeprint\", \"onbeforeunload\", \"onhashchange\", \"onlanguagechange\", \"onmessage\", \"onoffline\", \"ononline\",\n  \"onpagehide\", \"onpageshow\", \"onpopstate\", \"onstorage\", \"onunload\"]);\n\n// level2/html sets up setters/getters on HTMLBodyElement that proxy to the window (setting data properties there)\n// level1/core sets up so that modifying the appropriate attributes on body elements will forward to setting on\n// the window, with the appropriate `this`.\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ElementCSSInlineStyle.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction ElementCSSInlineStyle() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nElementCSSInlineStyle.prototype.toString = function () {\n  if (this === ElementCSSInlineStyle.prototype) {\n    return \"[object ElementCSSInlineStylePrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(ElementCSSInlineStyle.prototype, \"style\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].style);\n  },\n  set(V) {\n    this.style.cssText = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(ElementCSSInlineStyle.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(ElementCSSInlineStyle.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: ElementCSSInlineStyle,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/ElementCSSInlineStyle-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/ElementCSSInlineStyle-impl.js":"\"use strict\";\n\nclass ElementCSSInlineStyle { }\n\nmodule.exports = {\n  implementation: ElementCSSInlineStyle\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ElementContentEditable.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction ElementContentEditable() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nElementContentEditable.prototype.toString = function () {\n  if (this === ElementContentEditable.prototype) {\n    return \"[object ElementContentEditablePrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(ElementContentEditable.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(ElementContentEditable.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: ElementContentEditable,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/ElementContentEditable-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/ElementContentEditable-impl.js":"\"use strict\";\n\nclass ElementContentEditableImpl { }\n\nmodule.exports = {\n  implementation: ElementContentEditableImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLElement-impl.js":"\"use strict\";\n\nconst ElementImpl = require(\"./Element-impl\").implementation;\nconst MouseEvent = require(\"../generated/MouseEvent\");\nconst focusing = require(\"../helpers/focusing.js\");\nconst conversions = require(\"webidl-conversions\");\nconst isDisabled = require(\"../helpers/form-controls\").isDisabled;\n\nclass HTMLElementImpl extends ElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._tabIndex = 0;\n\n    this._settingCssText = false;\n    this._clickInProgress = false;\n\n    this._style = new this._core.CSSStyleDeclaration(newCssText => {\n      if (!this._settingCssText) {\n        this._settingCssText = true;\n        this.setAttribute(\"style\", newCssText);\n        this._settingCssText = false;\n      }\n    });\n  }\n\n  // Add default event behavior (click link to navigate, click button to submit\n  // form, etc). We start by wrapping dispatchEvent so we can forward events to\n  // the element's default functions (only events that did not incur\n  // preventDefault).\n  dispatchEvent(event) {\n    if (event.type === \"click\") {\n      callEventBehaviorHook(event, \"_preClickActivationSteps\", this);\n    }\n\n    const outcome = super.dispatchEvent(event);\n\n    if (event.type === \"click\") {\n      if (event.defaultPrevented) {\n        callEventBehaviorHook(event, \"_canceledActivationSteps\");\n      } else {\n        callEventBehaviorHook(event, \"_activationBehavior\");\n      }\n    }\n\n    return outcome;\n  }\n\n  focus() {\n    if (!focusing.isFocusableAreaElement(this)) {\n      return;\n    }\n\n    const previous = this._ownerDocument._lastFocusedElement;\n\n    focusing.fireFocusEventWithTargetAdjustment(\"blur\", previous, this);\n    this._ownerDocument._lastFocusedElement = this;\n    focusing.fireFocusEventWithTargetAdjustment(\"focus\", this, previous);\n\n    if (this._ownerDocument._defaultView._frameElement) {\n      this._ownerDocument._defaultView._frameElement.focus();\n    }\n  }\n\n  blur() {\n    if (this._ownerDocument._lastFocusedElement !== this || !focusing.isFocusableAreaElement(this)) {\n      return;\n    }\n\n    focusing.fireFocusEventWithTargetAdjustment(\"blur\", this, this._ownerDocument);\n    this._ownerDocument._lastFocusedElement = null;\n    focusing.fireFocusEventWithTargetAdjustment(\"focus\", this._ownerDocument, this);\n  }\n\n  click() {\n    // https://html.spec.whatwg.org/multipage/interaction.html#dom-click\n    // https://html.spec.whatwg.org/multipage/interaction.html#run-synthetic-click-activation-steps\n    // Not completely spec compliant due to e.g. incomplete implementations of disabled for form controls, or no\n    // implementation at all of isTrusted.\n\n    if (this._clickInProgress) {\n      return;\n    }\n\n    this._clickInProgress = true;\n\n    if (isDisabled(this)) {\n      return;\n    }\n\n    const event = MouseEvent.createImpl([\"click\", { bubbles: true, cancelable: true }], {});\n\n    // Run synthetic click activation steps. According to the spec,\n    // this should not be calling dispatchEvent, but it matches browser behavior.\n    // See: https://www.w3.org/Bugs/Public/show_bug.cgi?id=12230\n    // See also: https://github.com/whatwg/html/issues/805\n    this.dispatchEvent(event);\n\n\n    this._clickInProgress = false;\n  }\n\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    this._style.cssText = value;\n  }\n\n  _attrModified(name, value, oldValue) {\n    if (name === \"style\" && value !== oldValue && !this._settingCssText) {\n      this._settingCssText = true;\n      this._style.cssText = value;\n      this._settingCssText = false;\n    }\n\n    super._attrModified.apply(this, arguments);\n  }\n\n  // TODO this should be [Reflect]able if we added default value support to webidl2js's [Reflect]\n  get tabIndex() {\n    if (!this.hasAttribute(\"tabindex\")) {\n      return focusing.isFocusableAreaElement(this) ? 0 : -1;\n    }\n    return conversions.long(this.getAttribute(\"tabindex\"));\n  }\n\n  set tabIndex(value) {\n    this.setAttribute(\"tabIndex\", String(value));\n  }\n\n  get offsetParent() {\n    return null;\n  }\n\n  get offsetTop() {\n    return 0;\n  }\n\n  get offsetLeft() {\n    return 0;\n  }\n\n  get offsetWidth() {\n    return 0;\n  }\n\n  get offsetHeight() {\n    return 0;\n  }\n}\n\nfunction callEventBehaviorHook(event, name, targetOverride) {\n  if (event) {\n    const target = targetOverride || event.target;\n    if (target && typeof target[name] === \"function\") {\n      target[name]();\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/MouseEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst UIEvent = require(\"./UIEvent.js\");\nconst impl = utils.implSymbol;\nconst convertMouseEventInit = require(\"./MouseEventInit\").convert;\n\nfunction MouseEvent(typeArg) {\n  if (!this || this[impl] || !(this instanceof MouseEvent)) {\n    throw new TypeError(\"Failed to construct 'MouseEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'MouseEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertMouseEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nMouseEvent.prototype = Object.create(UIEvent.interface.prototype);\nMouseEvent.prototype.constructor = MouseEvent;\n\n\nMouseEvent.prototype.getModifierState = function getModifierState(keyArg) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getModifierState' on 'MouseEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].getModifierState.apply(this[impl], args);\n};\n\nMouseEvent.prototype.initMouseEvent = function initMouseEvent(typeArg, bubblesArg, cancelableArg, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 15) {\n    throw new TypeError(\"Failed to execute 'initMouseEvent' on 'MouseEvent': 15 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 15; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"boolean\"](args[1]);\n  args[2] = conversions[\"boolean\"](args[2]);\n  if (args[3] === null || args[3] === undefined) {\n    args[3] = null;\n  } else {\n  }\n  args[4] = conversions[\"long\"](args[4]);\n  args[5] = conversions[\"long\"](args[5]);\n  args[6] = conversions[\"long\"](args[6]);\n  args[7] = conversions[\"long\"](args[7]);\n  args[8] = conversions[\"long\"](args[8]);\n  args[9] = conversions[\"boolean\"](args[9]);\n  args[10] = conversions[\"boolean\"](args[10]);\n  args[11] = conversions[\"boolean\"](args[11]);\n  args[12] = conversions[\"boolean\"](args[12]);\n  args[13] = conversions[\"short\"](args[13]);\n  if (args[14] === null || args[14] === undefined) {\n    args[14] = null;\n  } else {\n  }\n  return this[impl].initMouseEvent.apply(this[impl], args);\n};\n\nMouseEvent.prototype.toString = function () {\n  if (this === MouseEvent.prototype) {\n    return \"[object MouseEventPrototype]\";\n  }\n  return UIEvent.interface.prototype.toString.call(this);\n};\nObject.defineProperty(MouseEvent.prototype, \"screenX\", {\n  get() {\n    return this[impl].screenX;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"screenY\", {\n  get() {\n    return this[impl].screenY;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"clientX\", {\n  get() {\n    return this[impl].clientX;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"clientY\", {\n  get() {\n    return this[impl].clientY;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"ctrlKey\", {\n  get() {\n    return this[impl].ctrlKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"shiftKey\", {\n  get() {\n    return this[impl].shiftKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"altKey\", {\n  get() {\n    return this[impl].altKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"metaKey\", {\n  get() {\n    return this[impl].metaKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"button\", {\n  get() {\n    return this[impl].button;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"relatedTarget\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].relatedTarget);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MouseEvent.prototype, \"buttons\", {\n  get() {\n    return this[impl].buttons;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(MouseEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(MouseEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    UIEvent._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: MouseEvent,\n  expose: {\n    Window: { MouseEvent: MouseEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/MouseEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/UIEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Event = require(\"./Event.js\");\nconst impl = utils.implSymbol;\nconst convertUIEventInit = require(\"./UIEventInit\").convert;\n\nfunction UIEvent(type) {\n  if (!this || this[impl] || !(this instanceof UIEvent)) {\n    throw new TypeError(\"Failed to construct 'UIEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'UIEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertUIEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nUIEvent.prototype = Object.create(Event.interface.prototype);\nUIEvent.prototype.constructor = UIEvent;\n\n\nUIEvent.prototype.initUIEvent = function initUIEvent(typeArg, bubblesArg, cancelableArg, viewArg, detailArg) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 5) {\n    throw new TypeError(\"Failed to execute 'initUIEvent' on 'UIEvent': 5 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 5; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"boolean\"](args[1]);\n  args[2] = conversions[\"boolean\"](args[2]);\n  if (args[3] === null || args[3] === undefined) {\n    args[3] = null;\n  } else {\n  }\n  args[4] = conversions[\"long\"](args[4]);\n  return this[impl].initUIEvent.apply(this[impl], args);\n};\n\nUIEvent.prototype.toString = function () {\n  if (this === UIEvent.prototype) {\n    return \"[object UIEventPrototype]\";\n  }\n  return Event.interface.prototype.toString.call(this);\n};\nObject.defineProperty(UIEvent.prototype, \"view\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].view);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(UIEvent.prototype, \"detail\", {\n  get() {\n    return this[impl].detail;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(UIEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(UIEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Event._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: UIEvent,\n  expose: {\n    Window: { UIEvent: UIEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/UIEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/UIEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventInit = require(\"./EventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"detail\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"view\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = (value);\n    } else {\n      ret[key] = null;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/UIEvent-impl.js":"\"use strict\";\n\nconst EventImpl = require(\"./Event-impl\").implementation;\n\nclass UIEventImpl extends EventImpl {\n  initUIEvent(type, bubbles, cancelable, view, detail) {\n    if (this._dispatchFlag) {\n      return;\n    }\n\n    this.initEvent(type, bubbles, cancelable);\n    this.view = view;\n    this.detail = detail;\n  }\n}\n\nmodule.exports = {\n  implementation: UIEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/MouseEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventModifierInit = require(\"./EventModifierInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventModifierInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"button\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"short\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"buttons\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned short\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"clientX\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"clientY\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"relatedTarget\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = (value);\n    } else {\n      ret[key] = null;\n    }\n\n    key = \"screenX\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"screenY\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/EventModifierInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst UIEventInit = require(\"./UIEventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    UIEventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"altKey\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"ctrlKey\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"metaKey\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierAltGraph\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierCapsLock\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierFn\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierFnLock\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierHyper\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierNumLock\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierOS\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierScrollLock\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierSuper\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierSymbol\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"modifierSymbolLock\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"shiftKey\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/MouseEvent-impl.js":"\"use strict\";\n\nconst UIEventImpl = require(\"./UIEvent-impl\").implementation;\n\nclass MouseEventImpl extends UIEventImpl {\n  initMouseEvent(type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY,\n                 ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {\n    if (this._dispatchFlag) {\n      return;\n    }\n\n    this.initUIEvent(type, bubbles, cancelable, view, detail);\n    this.screenX = screenX;\n    this.screenY = screenY;\n    this.clientX = clientX;\n    this.clientY = clientY;\n    this.ctrlKey = ctrlKey;\n    this.altKey = altKey;\n    this.shiftKey = shiftKey;\n    this.metaKey = metaKey;\n    this.button = button;\n    this.relatedTarget = relatedTarget;\n  }\n}\n\nmodule.exports = {\n  implementation: MouseEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/focusing.js":"\"use strict\";\nconst nodeType = require(\"../node-type.js\");\nconst FocusEvent = require(\"../generated/FocusEvent.js\");\nconst idlUtils = require(\"../generated/utils.js\");\nconst isDisabled = require(\"./form-controls.js\").isDisabled;\n\nconst focusableFormElements = new Set([\"input\", \"select\", \"textarea\", \"button\"]);\n\n// https://html.spec.whatwg.org/multipage/interaction.html#focusable-area, but also some of\n// https://html.spec.whatwg.org/multipage/interaction.html#focusing-steps: e.g., Documents are not actually focusable\n// areas, but their viewports are, and the first step of the latter algorithm translates Documents to their viewports.\n// And also https://html.spec.whatwg.org/multipage/interaction.html#specially-focusable!\nexports.isFocusableAreaElement = elImpl => {\n  if (!elImpl._ownerDocument._defaultView && !elImpl._defaultView) {\n    return false;\n  }\n\n  if (elImpl._nodeType === nodeType.DOCUMENT_NODE) {\n    return true;\n  }\n\n  if (!Number.isNaN(parseInt(elImpl.getAttribute(\"tabindex\")))) {\n    return true;\n  }\n\n  if (elImpl._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n    if (elImpl._localName === \"iframe\") {\n      return true;\n    }\n\n    if (elImpl._localName === \"a\" && elImpl.hasAttribute(\"href\")) {\n      return true;\n    }\n\n    if (focusableFormElements.has(elImpl._localName) && !isDisabled(elImpl)) {\n      if (elImpl._localName === \"input\" && elImpl.type === \"hidden\") {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\n// https://html.spec.whatwg.org/multipage/interaction.html#fire-a-focus-event plus the steps of\n// https://html.spec.whatwg.org/multipage/interaction.html#focus-update-steps that adjust Documents to Windows\nexports.fireFocusEventWithTargetAdjustment = (name, target, relatedTarget) => {\n  if (target === null) {\n    // E.g. firing blur with nothing previously focused.\n    return;\n  }\n\n  const event = FocusEvent.createImpl(\n    [name, {\n      bubbles: false,\n      cancelable: false,\n      relatedTarget,\n      view: target._ownerDocument._defaultView,\n      detail: 0\n    }],\n    {\n      isTrusted: true\n    }\n  );\n\n  if (target._defaultView) {\n    target = idlUtils.implForWrapper(target._defaultView);\n  }\n\n  // _dispatch allows setting isTrusted\n  target._dispatch(event);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/FocusEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst UIEvent = require(\"./UIEvent.js\");\nconst impl = utils.implSymbol;\nconst convertFocusEventInit = require(\"./FocusEventInit\").convert;\n\nfunction FocusEvent(type) {\n  if (!this || this[impl] || !(this instanceof FocusEvent)) {\n    throw new TypeError(\"Failed to construct 'FocusEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'FocusEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertFocusEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nFocusEvent.prototype = Object.create(UIEvent.interface.prototype);\nFocusEvent.prototype.constructor = FocusEvent;\n\n\nFocusEvent.prototype.toString = function () {\n  if (this === FocusEvent.prototype) {\n    return \"[object FocusEventPrototype]\";\n  }\n  return UIEvent.interface.prototype.toString.call(this);\n};\nObject.defineProperty(FocusEvent.prototype, \"relatedTarget\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].relatedTarget);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(FocusEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(FocusEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    UIEvent._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: FocusEvent,\n  expose: {\n    Window: { FocusEvent: FocusEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/FocusEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/FocusEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst UIEventInit = require(\"./UIEventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    UIEventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"relatedTarget\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = (value);\n    } else {\n      ret[key] = null;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/FocusEvent-impl.js":"\"use strict\";\nconst EventImpl = require(\"./Event-impl\").implementation;\n\nexports.implementation = class FocusEventImpl extends EventImpl { };\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/form-controls.js":"\"use strict\";\n\nconst submittableLocalNames = new Set([\"button\", \"input\", \"keygen\", \"object\", \"select\", \"textarea\"]);\n\nexports.isDisabled = formControl => {\n  if (formControl.localName === \"button\" || formControl.localName === \"input\" || formControl.localName === \"select\" ||\n      formControl.localName === \"textarea\") {\n    if (formControl.hasAttribute(\"disabled\")) {\n      return true;\n    }\n  }\n\n  let e = formControl.parentNode;\n  while (e) {\n    if (e.localName === \"fieldset\" && e.hasAttribute(\"disabled\")) {\n      const firstLegendElementChild = e.querySelector(\"legend\");\n      if (!firstLegendElementChild || !firstLegendElementChild.contains(formControl)) {\n        return true;\n      }\n    }\n    e = e.parentNode;\n  }\n\n  return false;\n};\n\nexports.isSubmittable = formControl => {\n  // https://html.spec.whatwg.org/multipage/forms.html#category-submit\n  return submittableLocalNames.has(formControl.localName);\n};\n\nexports.isButton = formControl => {\n  // https://html.spec.whatwg.org/multipage/forms.html#concept-button\n  return formControl.type === \"button\" || formControl.type === \"submit\" || formControl.type === \"reset\" ||\n         formControl.type === \"image\" || formControl.localName === \"button\";\n};\n\nexports.normalizeToCRLF = string => {\n  return string.replace(/\\r([^\\n])/g, \"\\r\\n$1\")\n               .replace(/\\r$/, \"\\r\\n\")\n               .replace(/([^\\r])\\n/g, \"$1\\r\\n\")\n               .replace(/^\\n/, \"\\r\\n\");\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLUnknownElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLUnknownElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLUnknownElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLUnknownElement.prototype.constructor = HTMLUnknownElement;\n\n\nHTMLUnknownElement.prototype.toString = function () {\n  if (this === HTMLUnknownElement.prototype) {\n    return \"[object HTMLUnknownElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLUnknownElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLUnknownElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLUnknownElement,\n  expose: {\n    Window: { HTMLUnknownElement: HTMLUnknownElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLUnknownElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLUnknownElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLUnknownElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLUnknownElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/TreeWalker.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction TreeWalker() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nTreeWalker.prototype.parentNode = function parentNode() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].parentNode.apply(this[impl], args));\n};\n\nTreeWalker.prototype.firstChild = function firstChild() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].firstChild.apply(this[impl], args));\n};\n\nTreeWalker.prototype.lastChild = function lastChild() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].lastChild.apply(this[impl], args));\n};\n\nTreeWalker.prototype.previousSibling = function previousSibling() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].previousSibling.apply(this[impl], args));\n};\n\nTreeWalker.prototype.nextSibling = function nextSibling() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].nextSibling.apply(this[impl], args));\n};\n\nTreeWalker.prototype.previousNode = function previousNode() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].previousNode.apply(this[impl], args));\n};\n\nTreeWalker.prototype.nextNode = function nextNode() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].nextNode.apply(this[impl], args));\n};\n\nTreeWalker.prototype.toString = function () {\n  if (this === TreeWalker.prototype) {\n    return \"[object TreeWalkerPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(TreeWalker.prototype, \"root\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].root);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TreeWalker.prototype, \"whatToShow\", {\n  get() {\n    return this[impl].whatToShow;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TreeWalker.prototype, \"filter\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].filter);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TreeWalker.prototype, \"currentNode\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].currentNode);\n  },\n  set(V) {\n    this[impl].currentNode = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(TreeWalker.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(TreeWalker.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: TreeWalker,\n  expose: {\n    Window: { TreeWalker: TreeWalker }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../traversal/TreeWalker-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/traversal/TreeWalker-impl.js":"\"use strict\";\n\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst idlUtils = require(\"../generated/utils\");\nconst conversions = require(\"webidl-conversions\");\n\n// FIXME: Once NodeFilter is ported to IDL method, uncomment these.\nconst FILTER_ACCEPT = 1; // NodeFilter.FILTER_ACCEPT;\nconst FILTER_REJECT = 2; // NodeFilter.FILTER_REJECT;\nconst FILTER_SKIP = 3; // NodeFilter.FILTER_SKIP;\nconst FIRST = false;\nconst LAST = true;\nconst NEXT = false;\nconst PREVIOUS = true;\n\nfunction isNull(o) {\n  return o === null || typeof o === \"undefined\";\n}\n\nclass TreeWalkerImpl {\n  constructor(args, privateData) {\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n    this.currentNode = this.root;\n  }\n\n  get currentNode() {\n    return this._currentNode;\n  }\n\n  set currentNode(node) {\n    if (isNull(node)) {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR, \"Cannot set currentNode to null\");\n    }\n\n    this._currentNode = node;\n  }\n\n  parentNode() {\n    let node = this._currentNode;\n    while (!isNull(node) && node !== this.root) {\n      node = node.parentNode;\n\n      if (!isNull(node) && this._filterNode(node) === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n    return null;\n  }\n\n  firstChild() {\n    return this._traverseChildren(FIRST);\n  }\n\n  lastChild() {\n    return this._traverseChildren(LAST);\n  }\n\n  previousSibling() {\n    return this._traverseSiblings(PREVIOUS);\n  }\n\n  nextSibling() {\n    return this._traverseSiblings(NEXT);\n  }\n\n  previousNode() {\n    let node = this._currentNode;\n\n    while (node !== this.root) {\n      let sibling = node.previousSibling;\n\n      while (!isNull(sibling)) {\n        node = sibling;\n        let result = this._filterNode(node);\n\n        while (result !== FILTER_REJECT && node.hasChildNodes()) {\n          node = node.lastChild;\n          result = this._filterNode(node);\n        }\n\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n\n        sibling = node.previousSibling;\n      }\n\n      if (node === this.root || isNull(node.parentNode)) {\n        return null;\n      }\n\n      node = node.parentNode;\n\n      if (this._filterNode(node) === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n\n    return null;\n  }\n\n  nextNode() {\n    let node = this._currentNode;\n    let result = FILTER_ACCEPT;\n\n    for (;;) {\n      while (result !== FILTER_REJECT && node.hasChildNodes()) {\n        node = node.firstChild;\n        result = this._filterNode(node);\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n      }\n\n      do {\n        if (node === this.root) {\n          return null;\n        }\n\n        const sibling = node.nextSibling;\n\n        if (!isNull(sibling)) {\n          node = sibling;\n          break;\n        }\n\n        node = node.parentNode;\n      } while (!isNull(node));\n\n      if (isNull(node)) {\n        return null;\n      }\n\n      result = this._filterNode(node);\n\n      if (result === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n  }\n\n  toString() {\n    return \"[object TreeWalker]\";\n  }\n\n  _filterNode(node) {\n    const n = node.nodeType - 1;\n\n    if (!((1 << n) & this.whatToShow)) {\n      return FILTER_SKIP;\n    }\n\n    const filter = this.filter;\n\n    if (isNull(filter)) {\n      return FILTER_ACCEPT;\n    }\n\n    let result;\n\n    if (typeof filter === \"function\") {\n      result = filter(idlUtils.wrapperForImpl(node));\n    } else {\n      result = filter.acceptNode(idlUtils.wrapperForImpl(node));\n    }\n\n    result = conversions[\"unsigned short\"](result);\n\n    return result;\n  }\n\n  _traverseChildren(type) {\n    let node = this._currentNode;\n    node = type === FIRST ? node.firstChild : node.lastChild;\n\n    if (isNull(node)) {\n      return null;\n    }\n\n    main: for (;;) {\n      const result = this._filterNode(node);\n\n      if (result === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n\n      if (result === FILTER_SKIP) {\n        const child = type === FIRST ? node.firstChild : node.lastChild;\n\n        if (!isNull(child)) {\n          node = child;\n          continue;\n        }\n      }\n\n      for (;;) {\n        const sibling = type === FIRST ? node.nextSibling : node.previousSibling;\n\n        if (!isNull(sibling)) {\n          node = sibling;\n          continue main;\n        }\n\n        const parent = node.parentNode;\n\n        if (isNull(parent) || parent === this.root || parent === this._currentNode) {\n          return null;\n        }\n\n        node = parent;\n      }\n    }\n  }\n\n  _traverseSiblings(type) {\n    let node = this._currentNode;\n\n    if (node === this.root) {\n      return null;\n    }\n\n    for (;;) {\n      let sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n\n      while (!isNull(sibling)) {\n        node = sibling;\n        const result = this._filterNode(node);\n\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n\n        sibling = type === NEXT ? node.firstChild : node.lastChild;\n\n        if (result === FILTER_REJECT || isNull(sibling)) {\n          sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n        }\n      }\n\n      node = node.parentNode;\n\n      if (isNull(node) || node === this.root) {\n        return null;\n      }\n\n      if (this._filterNode(node) === FILTER_ACCEPT) {\n        return null;\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: TreeWalkerImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/CustomEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Event = require(\"./Event.js\");\nconst impl = utils.implSymbol;\nconst convertCustomEventInit = require(\"./CustomEventInit\").convert;\n\nfunction CustomEvent(type) {\n  if (!this || this[impl] || !(this instanceof CustomEvent)) {\n    throw new TypeError(\"Failed to construct 'CustomEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'CustomEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertCustomEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nCustomEvent.prototype = Object.create(Event.interface.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\n\nCustomEvent.prototype.initCustomEvent = function initCustomEvent(type, bubbles, cancelable, detail) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 4) {\n    throw new TypeError(\"Failed to execute 'initCustomEvent' on 'CustomEvent': 4 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 4; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"boolean\"](args[1]);\n  args[2] = conversions[\"boolean\"](args[2]);\n  args[3] = conversions[\"any\"](args[3]);\n  return this[impl].initCustomEvent.apply(this[impl], args);\n};\n\nCustomEvent.prototype.toString = function () {\n  if (this === CustomEvent.prototype) {\n    return \"[object CustomEventPrototype]\";\n  }\n  return Event.interface.prototype.toString.call(this);\n};\nObject.defineProperty(CustomEvent.prototype, \"detail\", {\n  get() {\n    return this[impl].detail;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(CustomEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(CustomEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Event._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: CustomEvent,\n  expose: {\n    Window: { CustomEvent: CustomEvent },\n    Worker: { CustomEvent: CustomEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/CustomEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/CustomEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventInit = require(\"./EventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"detail\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"any\"](value);\n    } else {\n      ret[key] = null;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/CustomEvent-impl.js":"\"use strict\";\n\nconst EventImpl = require(\"./Event-impl\").implementation;\n\nclass CustomEventImpl extends EventImpl {\n  initCustomEvent(type, bubbles, cancelable, detail) {\n    if (this._dispatchFlag) {\n      return;\n    }\n\n    this.initEvent(type, bubbles, cancelable);\n    this.detail = detail;\n  }\n}\n\nmodule.exports = {\n  implementation: CustomEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/KeyboardEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst UIEvent = require(\"./UIEvent.js\");\nconst impl = utils.implSymbol;\nconst convertKeyboardEventInit = require(\"./KeyboardEventInit\").convert;\n\nfunction KeyboardEvent(typeArg) {\n  if (!this || this[impl] || !(this instanceof KeyboardEvent)) {\n    throw new TypeError(\"Failed to construct 'KeyboardEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'KeyboardEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertKeyboardEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nKeyboardEvent.prototype = Object.create(UIEvent.interface.prototype);\nKeyboardEvent.prototype.constructor = KeyboardEvent;\n\n\nKeyboardEvent.prototype.getModifierState = function getModifierState(keyArg) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getModifierState' on 'KeyboardEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].getModifierState.apply(this[impl], args);\n};\n\nKeyboardEvent.prototype.initKeyboardEvent = function initKeyboardEvent(typeArg, bubblesArg, cancelableArg, viewArg, keyArg, locationArg, modifiersListArg, repeat, locale) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 9) {\n    throw new TypeError(\"Failed to execute 'initKeyboardEvent' on 'KeyboardEvent': 9 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 9; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"boolean\"](args[1]);\n  args[2] = conversions[\"boolean\"](args[2]);\n  if (args[3] === null || args[3] === undefined) {\n    args[3] = null;\n  } else {\n  }\n  args[4] = conversions[\"DOMString\"](args[4]);\n  args[5] = conversions[\"unsigned long\"](args[5]);\n  args[6] = conversions[\"DOMString\"](args[6]);\n  args[7] = conversions[\"boolean\"](args[7]);\n  args[8] = conversions[\"DOMString\"](args[8]);\n  return this[impl].initKeyboardEvent.apply(this[impl], args);\n};\n\nKeyboardEvent.prototype.toString = function () {\n  if (this === KeyboardEvent.prototype) {\n    return \"[object KeyboardEventPrototype]\";\n  }\n  return UIEvent.interface.prototype.toString.call(this);\n};\nObject.defineProperty(KeyboardEvent, \"DOM_KEY_LOCATION_STANDARD\", {\n  value: 0,\n  enumerable: true\n});\nObject.defineProperty(KeyboardEvent.prototype, \"DOM_KEY_LOCATION_STANDARD\", {\n  value: 0,\n  enumerable: true\n});\n\nObject.defineProperty(KeyboardEvent, \"DOM_KEY_LOCATION_LEFT\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(KeyboardEvent.prototype, \"DOM_KEY_LOCATION_LEFT\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(KeyboardEvent, \"DOM_KEY_LOCATION_RIGHT\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(KeyboardEvent.prototype, \"DOM_KEY_LOCATION_RIGHT\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(KeyboardEvent, \"DOM_KEY_LOCATION_NUMPAD\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(KeyboardEvent.prototype, \"DOM_KEY_LOCATION_NUMPAD\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"key\", {\n  get() {\n    return this[impl].key;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"code\", {\n  get() {\n    return this[impl].code;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"location\", {\n  get() {\n    return this[impl].location;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"ctrlKey\", {\n  get() {\n    return this[impl].ctrlKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"shiftKey\", {\n  get() {\n    return this[impl].shiftKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"altKey\", {\n  get() {\n    return this[impl].altKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"metaKey\", {\n  get() {\n    return this[impl].metaKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"repeat\", {\n  get() {\n    return this[impl].repeat;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"isComposing\", {\n  get() {\n    return this[impl].isComposing;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"charCode\", {\n  get() {\n    return this[impl].charCode;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"keyCode\", {\n  get() {\n    return this[impl].keyCode;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(KeyboardEvent.prototype, \"which\", {\n  get() {\n    return this[impl].which;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(KeyboardEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(KeyboardEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    UIEvent._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: KeyboardEvent,\n  expose: {\n    Window: { KeyboardEvent: KeyboardEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/KeyboardEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/KeyboardEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventModifierInit = require(\"./EventModifierInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventModifierInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"charCode\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"code\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    } else {\n      ret[key] = \"\";\n    }\n\n    key = \"isComposing\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"key\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    } else {\n      ret[key] = \"\";\n    }\n\n    key = \"keyCode\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"location\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"repeat\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"which\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/KeyboardEvent-impl.js":"\"use strict\";\n\nconst UIEventImpl = require(\"./UIEvent-impl\").implementation;\n\nclass KeyboardEventImpl extends UIEventImpl {\n  initKeyboardEvent(type, bubbles, cancelable, view, key, location, modifiersList, repeat, locale) {\n    if (this._dispatchFlag) {\n      return;\n    }\n\n    this.initUIEvent(type, bubbles, cancelable, view, key);\n    this.location = location;\n    this.modifiersList = modifiersList;\n    this.repeat = repeat;\n    this.locale = locale;\n  }\n}\n\nmodule.exports = {\n  implementation: KeyboardEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/MessageEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Event = require(\"./Event.js\");\nconst impl = utils.implSymbol;\nconst convertMessageEventInit = require(\"./MessageEventInit\").convert;\n\nfunction MessageEvent(type) {\n  if (!this || this[impl] || !(this instanceof MessageEvent)) {\n    throw new TypeError(\"Failed to construct 'MessageEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'MessageEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertMessageEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nMessageEvent.prototype = Object.create(Event.interface.prototype);\nMessageEvent.prototype.constructor = MessageEvent;\n\n\nMessageEvent.prototype.initMessageEvent = function initMessageEvent(type, bubbles, cancelable, data, origin, lastEventId, source, ports) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 8) {\n    throw new TypeError(\"Failed to execute 'initMessageEvent' on 'MessageEvent': 8 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 8; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"boolean\"](args[1]);\n  args[2] = conversions[\"boolean\"](args[2]);\n  args[3] = conversions[\"any\"](args[3]);\n  args[4] = conversions[\"DOMString\"](args[4]);\n  args[5] = conversions[\"DOMString\"](args[5]);\n  if (args[6] === null || args[6] === undefined) {\n    args[6] = null;\n  } else {\n  }\n  if (args[7] === null || args[7] === undefined) {\n    args[7] = null;\n  } else {\n  }\n  return this[impl].initMessageEvent.apply(this[impl], args);\n};\n\nMessageEvent.prototype.toString = function () {\n  if (this === MessageEvent.prototype) {\n    return \"[object MessageEventPrototype]\";\n  }\n  return Event.interface.prototype.toString.call(this);\n};\nObject.defineProperty(MessageEvent.prototype, \"data\", {\n  get() {\n    return this[impl].data;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MessageEvent.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MessageEvent.prototype, \"lastEventId\", {\n  get() {\n    return this[impl].lastEventId;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MessageEvent.prototype, \"source\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].source);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(MessageEvent.prototype, \"ports\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ports);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(MessageEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(MessageEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Event._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: MessageEvent,\n  expose: {\n    Window: { MessageEvent: MessageEvent },\n    Worker: { MessageEvent: MessageEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/MessageEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/MessageEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventInit = require(\"./EventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"data\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"any\"](value);\n    }\n\n    key = \"lastEventId\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    }\n\n    key = \"origin\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    }\n\n    key = \"ports\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = (value);\n    }\n\n    key = \"source\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = (value);\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/MessageEvent-impl.js":"\"use strict\";\n\nconst EventImpl = require(\"./Event-impl\").implementation;\n\nclass MessageEventImpl extends EventImpl {\n  initMessageEvent(type, bubbles, cancelable, data, origin, lastEventId, source, ports) {\n    if (this._dispatchFlag) {\n      return;\n    }\n\n    this.initEvent(type, bubbles, cancelable);\n    this.data = data;\n    this.origin = origin;\n    this.lastEventId = lastEventId;\n    this.source = source;\n    this.ports = ports;\n  }\n}\n\nmodule.exports = {\n  implementation: MessageEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ProgressEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Event = require(\"./Event.js\");\nconst impl = utils.implSymbol;\nconst convertProgressEventInit = require(\"./ProgressEventInit\").convert;\n\nfunction ProgressEvent(type) {\n  if (!this || this[impl] || !(this instanceof ProgressEvent)) {\n    throw new TypeError(\"Failed to construct 'ProgressEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'ProgressEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertProgressEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nProgressEvent.prototype = Object.create(Event.interface.prototype);\nProgressEvent.prototype.constructor = ProgressEvent;\n\n\nProgressEvent.prototype.toString = function () {\n  if (this === ProgressEvent.prototype) {\n    return \"[object ProgressEventPrototype]\";\n  }\n  return Event.interface.prototype.toString.call(this);\n};\nObject.defineProperty(ProgressEvent.prototype, \"lengthComputable\", {\n  get() {\n    return this[impl].lengthComputable;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ProgressEvent.prototype, \"loaded\", {\n  get() {\n    return this[impl].loaded;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ProgressEvent.prototype, \"total\", {\n  get() {\n    return this[impl].total;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(ProgressEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(ProgressEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Event._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: ProgressEvent,\n  expose: {\n    Window: { ProgressEvent: ProgressEvent },\n    DedicatedWorker: { ProgressEvent: ProgressEvent },\n    SharedWorker: { ProgressEvent: ProgressEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/ProgressEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/ProgressEventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst EventInit = require(\"./EventInit\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    EventInit.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"lengthComputable\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"loaded\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned long long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n\n    key = \"total\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"unsigned long long\"](value);\n    } else {\n      ret[key] = 0;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/ProgressEvent-impl.js":"\"use strict\";\n\nconst EventImpl = require(\"./Event-impl\").implementation;\n\nclass ProgressEventImpl extends EventImpl {\n\n}\n\nmodule.exports = {\n  implementation: ProgressEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/TouchEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst UIEvent = require(\"./UIEvent.js\");\nconst impl = utils.implSymbol;\n\nfunction TouchEvent() {\n  throw new TypeError(\"Illegal constructor\");\n}\nTouchEvent.prototype = Object.create(UIEvent.interface.prototype);\nTouchEvent.prototype.constructor = TouchEvent;\n\n\nTouchEvent.prototype.toString = function () {\n  if (this === TouchEvent.prototype) {\n    return \"[object TouchEventPrototype]\";\n  }\n  return UIEvent.interface.prototype.toString.call(this);\n};\nObject.defineProperty(TouchEvent.prototype, \"touches\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].touches);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TouchEvent.prototype, \"targetTouches\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].targetTouches);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TouchEvent.prototype, \"changedTouches\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].changedTouches);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TouchEvent.prototype, \"altKey\", {\n  get() {\n    return this[impl].altKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TouchEvent.prototype, \"metaKey\", {\n  get() {\n    return this[impl].metaKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TouchEvent.prototype, \"ctrlKey\", {\n  get() {\n    return this[impl].ctrlKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(TouchEvent.prototype, \"shiftKey\", {\n  get() {\n    return this[impl].shiftKey;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(TouchEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(TouchEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    UIEvent._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: TouchEvent,\n  expose: {\n    Window: { TouchEvent: TouchEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/TouchEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/events/TouchEvent-impl.js":"\"use strict\";\n\nconst UIEventImpl = require(\"./UIEvent-impl\").implementation;\n\nclass TouchEventImpl extends UIEventImpl {\n\n}\n\nmodule.exports = {\n  implementation: TouchEventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Blob.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\nconst convertBlobPropertyBag = require(\"./BlobPropertyBag\").convert;\n\nfunction Blob() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[1] = convertBlobPropertyBag(args[1]);\n\n  iface.setup(this, args);\n}\n\n\nBlob.prototype.slice = function slice() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"long long\"](args[0], { clamp: true });\n  }\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"long long\"](args[1], { clamp: true });\n  }\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"DOMString\"](args[2]);\n  }\n  return utils.tryWrapperForImpl(this[impl].slice.apply(this[impl], args));\n};\n\nBlob.prototype.close = function close() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].close.apply(this[impl], args);\n};\n\nBlob.prototype.toString = function () {\n  if (this === Blob.prototype) {\n    return \"[object BlobPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(Blob.prototype, \"size\", {\n  get() {\n    return this[impl].size;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Blob.prototype, \"type\", {\n  get() {\n    return this[impl].type;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Blob.prototype, \"isClosed\", {\n  get() {\n    return this[impl].isClosed;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Blob.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Blob.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Blob,\n  expose: {\n    Window: { Blob: Blob },\n    Worker: { Blob: Blob }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../file-api/Blob-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/BlobPropertyBag.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    let key, value;\n\n    key = \"type\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"DOMString\"](value);\n    } else {\n      ret[key] = \"\";\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/file-api/Blob-impl.js":"\"use strict\";\nconst idlUtils = require(\"../generated/utils\");\nconst conversions = require(\"webidl-conversions\");\nconst Blob = require(\"../generated/Blob\");\n\nexports.implementation = class BlobImpl {\n  constructor(args) {\n    const parts = args[0];\n    const properties = args[1];\n\n    const buffers = [];\n\n    if (parts !== undefined) {\n      if (parts === null || typeof parts !== \"object\" || typeof parts[Symbol.iterator] !== \"function\") {\n        throw new TypeError(\"parts must be an iterable object\");\n      }\n\n      const arr = [];\n      for (const part of parts) {\n        if (part instanceof ArrayBuffer || ArrayBuffer.isView(part) || Blob.is(part)) {\n          arr.push(idlUtils.tryImplForWrapper(part));\n        } else {\n          arr.push(conversions.USVString(part));\n        }\n      }\n\n      for (const part of arr) {\n        let buffer;\n        if (part instanceof ArrayBuffer) {\n          buffer = new Buffer(new Uint8Array(part));\n        } else if (ArrayBuffer.isView(part)) {\n          buffer = new Buffer(new Uint8Array(part.buffer, part.byteOffset, part.byteLength));\n        } else if (Blob.isImpl(part)) {\n          buffer = part._buffer;\n        } else {\n          buffer = new Buffer(part);\n        }\n        buffers.push(buffer);\n      }\n    }\n\n    this._buffer = Buffer.concat(buffers);\n\n    this.type = properties.type;\n    if (/[^\\u0020-\\u007E]/.test(this.type)) {\n      this.type = \"\";\n    } else {\n      this.type = this.type.toLowerCase();\n    }\n\n    this.isClosed = false;\n  }\n\n  get size() {\n    return this.isClosed ? 0 : this._buffer.length;\n  }\n\n  slice(start, end, contentType) {\n    const size = this.size;\n\n    let relativeStart;\n    let relativeEnd;\n    let relativeContentType;\n\n    if (start === undefined) {\n      relativeStart = 0;\n    } else if (start < 0) {\n      relativeStart = Math.max(size + start, 0);\n    } else {\n      relativeStart = Math.min(start, size);\n    }\n    if (end === undefined) {\n      relativeEnd = size;\n    } else if (end < 0) {\n      relativeEnd = Math.max(size + end, 0);\n    } else {\n      relativeEnd = Math.min(end, size);\n    }\n\n    if (contentType === undefined) {\n      relativeContentType = \"\";\n    } else {\n      // sanitization (lower case and invalid char check) is done in the\n      // constructor\n      relativeContentType = contentType;\n    }\n\n    const span = Math.max(relativeEnd - relativeStart, 0);\n\n    const buffer = this._buffer;\n    const slicedBuffer = buffer.slice(\n      relativeStart,\n      relativeStart + span\n    );\n\n    const blob = Blob.createImpl([[], { type: relativeContentType }], {});\n    blob.isClosed = this.isClosed;\n    blob._buffer = slicedBuffer;\n    return blob;\n  }\n\n  close() {\n    this.isClosed = true;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/FileReader.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst EventTarget = require(\"./EventTarget.js\");\nconst impl = utils.implSymbol;\n\n\nmodule.exports = {\n  createInterface: function (defaultPrivateData) {\n    defaultPrivateData = defaultPrivateData === undefined ? {} : defaultPrivateData;\n\nfunction FileReader() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n\n  iface.setup(this, args);\n}\nFileReader.prototype = Object.create(EventTarget.interface.prototype);\nFileReader.prototype.constructor = FileReader;\n\n\nFileReader.prototype.readAsArrayBuffer = function readAsArrayBuffer(blob) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'readAsArrayBuffer' on 'FileReader': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].readAsArrayBuffer.apply(this[impl], args);\n};\n\nFileReader.prototype.readAsText = function readAsText(blob) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'readAsText' on 'FileReader': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"DOMString\"](args[1]);\n  }\n  return this[impl].readAsText.apply(this[impl], args);\n};\n\nFileReader.prototype.readAsDataURL = function readAsDataURL(blob) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'readAsDataURL' on 'FileReader': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].readAsDataURL.apply(this[impl], args);\n};\n\nFileReader.prototype.abort = function abort() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].abort.apply(this[impl], args);\n};\n\nFileReader.prototype.toString = function () {\n  if (this === FileReader.prototype) {\n    return \"[object FileReaderPrototype]\";\n  }\n  return EventTarget.interface.prototype.toString.call(this);\n};\nObject.defineProperty(FileReader, \"EMPTY\", {\n  value: 0,\n  enumerable: true\n});\nObject.defineProperty(FileReader.prototype, \"EMPTY\", {\n  value: 0,\n  enumerable: true\n});\n\nObject.defineProperty(FileReader, \"LOADING\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(FileReader.prototype, \"LOADING\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(FileReader, \"DONE\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(FileReader.prototype, \"DONE\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"readyState\", {\n  get() {\n    return this[impl].readyState;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"result\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].result);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"error\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].error);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"onloadstart\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onloadstart);\n  },\n  set(V) {\n    this[impl].onloadstart = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"onprogress\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onprogress);\n  },\n  set(V) {\n    this[impl].onprogress = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"onload\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onload);\n  },\n  set(V) {\n    this[impl].onload = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"onabort\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onabort);\n  },\n  set(V) {\n    this[impl].onabort = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"onerror\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onerror);\n  },\n  set(V) {\n    this[impl].onerror = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(FileReader.prototype, \"onloadend\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onloadend);\n  },\n  set(V) {\n    this[impl].onloadend = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  create(constructorArgs, privateData) {\n    let obj = Object.create(FileReader.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(FileReader.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    EventTarget._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    for (var prop in defaultPrivateData) {\n      if (!(prop in privateData)) {\n        privateData[prop] = defaultPrivateData[prop];\n      }\n    }\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: FileReader,\n  expose: {\n    Window: { FileReader: FileReader },\n    Worker: { FileReader: FileReader }\n  }\n};\nreturn iface;\n  },\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n};\n\nconst Impl = require(\"../file-api/FileReader-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/file-api/FileReader-impl.js":"\"use strict\";\n\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst parseContentType = require(\"content-type-parser\");\nconst querystring = require(\"querystring\");\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst Blob = require(\"../generated/Blob\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst READY_STATES = Object.freeze({\n  EMPTY: 0,\n  LOADING: 1,\n  DONE: 2\n});\n\nexports.implementation = class FileReaderImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super([], privateData);\n\n    this.error = null;\n    this.readyState = READY_STATES.EMPTY;\n    this.result = null;\n\n    this.onloadstart = null;\n    this.onprogress = null;\n    this.onload = null;\n    this.onabort = null;\n    this.onerror = null;\n    this.onloadend = null;\n\n    this._ownerDocument = privateData.window.document;\n  }\n\n  readAsArrayBuffer(file) {\n    this._readFile(file, \"buffer\");\n  }\n  readAsDataURL(file) {\n    this._readFile(file, \"dataURL\");\n  }\n  readAsText(file, encoding) {\n    this._readFile(file, \"text\", whatwgEncoding.labelToName(encoding) || \"UTF-8\");\n  }\n\n  abort() {\n    if (this.readyState === READY_STATES.DONE || this.readyState === READY_STATES.EMPTY) {\n      this.result = null;\n      return;\n    }\n\n    if (this.readyState === READY_STATES.LOADING) {\n      this.readyState = READY_STATES.DONE;\n    }\n\n    this._fireProgressEvent(\"abort\");\n    this._fireProgressEvent(\"loadend\");\n  }\n\n  _fireProgressEvent(name, props) {\n    const event = ProgressEvent.createImpl([name, Object.assign({ bubbles: false, cancelable: false }, props)], {});\n    this.dispatchEvent(event);\n  }\n\n  _readFile(file, format, encoding) {\n    if (!Blob.isImpl(file)) {\n      throw new TypeError(\"file argument must be a Blob\");\n    }\n\n    if (this.readyState === READY_STATES.LOADING) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR);\n    }\n    if (file.isClosed) {\n      this.error = new DOMException(DOMException.INVALID_STATE_ERR);\n      this._fireProgressEvent(\"error\");\n    }\n\n    this.readyState = READY_STATES.LOADING;\n    this._fireProgressEvent(\"loadstart\");\n\n    process.nextTick(() => {\n      let data = file._buffer;\n      if (!data) {\n        data = new Buffer(\"\");\n      }\n      this._fireProgressEvent(\"progress\", {\n        lengthComputable: !isNaN(file.size),\n        total: file.size,\n        loaded: data.length\n      });\n\n      process.nextTick(() => {\n        switch (format) {\n          default:\n          case \"buffer\": {\n            this.result = (new Uint8Array(data)).buffer;\n            break;\n          }\n          case \"dataURL\": {\n            let dataUrl = \"data:\";\n            const contentType = parseContentType(file.type);\n            if (contentType && contentType.isText()) {\n              const fallbackEncoding = whatwgEncoding.getBOMEncoding(data) ||\n                whatwgEncoding.labelToName(contentType.get(\"charset\")) || \"UTF-8\";\n              const decoded = whatwgEncoding.decode(data, fallbackEncoding);\n\n              contentType.set(\"charset\", encoding);\n              dataUrl += contentType.toString();\n              dataUrl += \",\";\n              dataUrl += querystring.escape(decoded);\n            } else {\n              if (contentType) {\n                dataUrl += contentType.toString();\n              }\n              dataUrl += \";base64,\";\n              dataUrl += data.toString(\"base64\");\n            }\n            this.result = dataUrl;\n            break;\n          }\n          case \"text\": {\n            this.result = whatwgEncoding.decode(data, encoding);\n            break;\n          }\n        }\n        this.readyState = READY_STATES.DONE;\n        this._fireProgressEvent(\"load\");\n        this._fireProgressEvent(\"loadend\");\n      });\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/Navigator.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst NavigatorID = require(\"./NavigatorID.js\");\nconst NavigatorLanguage = require(\"./NavigatorLanguage.js\");\nconst NavigatorOnLine = require(\"./NavigatorOnLine.js\");\nconst NavigatorCookies = require(\"./NavigatorCookies.js\");\nconst NavigatorPlugins = require(\"./NavigatorPlugins.js\");\nconst NavigatorConcurrentHardware = require(\"./NavigatorConcurrentHardware.js\");\n\nfunction Navigator() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\nmixin(Navigator.prototype, NavigatorID.interface.prototype);\nNavigatorID.mixedInto.push(Navigator);\nmixin(Navigator.prototype, NavigatorLanguage.interface.prototype);\nNavigatorLanguage.mixedInto.push(Navigator);\nmixin(Navigator.prototype, NavigatorOnLine.interface.prototype);\nNavigatorOnLine.mixedInto.push(Navigator);\nmixin(Navigator.prototype, NavigatorCookies.interface.prototype);\nNavigatorCookies.mixedInto.push(Navigator);\nmixin(Navigator.prototype, NavigatorPlugins.interface.prototype);\nNavigatorPlugins.mixedInto.push(Navigator);\nmixin(Navigator.prototype, NavigatorConcurrentHardware.interface.prototype);\nNavigatorConcurrentHardware.mixedInto.push(Navigator);\n\nNavigator.prototype.toString = function () {\n  if (this === Navigator.prototype) {\n    return \"[object NavigatorPrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Navigator.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Navigator.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Navigator,\n  expose: {\n    Window: { Navigator: Navigator }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../navigator/Navigator-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/NavigatorID.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction NavigatorID() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nNavigatorID.prototype.toString = function () {\n  if (this === NavigatorID.prototype) {\n    return \"[object NavigatorIDPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(NavigatorID.prototype, \"appCodeName\", {\n  get() {\n    return this[impl].appCodeName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorID.prototype, \"appName\", {\n  get() {\n    return this[impl].appName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorID.prototype, \"appVersion\", {\n  get() {\n    return this[impl].appVersion;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorID.prototype, \"platform\", {\n  get() {\n    return this[impl].platform;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorID.prototype, \"product\", {\n  get() {\n    return this[impl].product;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorID.prototype, \"productSub\", {\n  get() {\n    return this[impl].productSub;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorID.prototype, \"userAgent\", {\n  get() {\n    return this[impl].userAgent;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorID.prototype, \"vendor\", {\n  get() {\n    return this[impl].vendor;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorID.prototype, \"vendorSub\", {\n  get() {\n    return this[impl].vendorSub;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorID.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorID.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: NavigatorID,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../navigator/NavigatorID-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/navigator/NavigatorID-impl.js":"\"use strict\";\n\nexports.implementation = class NavigatorIDImpl {\n  get appCodeName() {\n    return \"Mozilla\";\n  }\n\n  get appName() {\n    return \"Netscape\";\n  }\n\n  get appVersion() {\n    return \"4.0\";\n  }\n\n  get platform() {\n    return \"\";\n  }\n\n  get product() {\n    return \"Gecko\";\n  }\n\n  get productSub() {\n    return \"20030107\";\n  }\n\n  // see Navigator constructor for userAgent\n\n  get vendor() {\n    return \"Apple Computer, Inc.\";\n  }\n\n  get vendorSub() {\n    return \"\";\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/NavigatorLanguage.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction NavigatorLanguage() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nNavigatorLanguage.prototype.toString = function () {\n  if (this === NavigatorLanguage.prototype) {\n    return \"[object NavigatorLanguagePrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(NavigatorLanguage.prototype, \"language\", {\n  get() {\n    return this[impl].language;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(NavigatorLanguage.prototype, \"languages\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].languages);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorLanguage.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorLanguage.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: NavigatorLanguage,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../navigator/NavigatorLanguage-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/navigator/NavigatorLanguage-impl.js":"\"use strict\";\n\nexports.implementation = class NavigatorLanguageImpl {\n  get language() {\n    return \"en-US\";\n  }\n\n  // See Navigator constructor for languages\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/NavigatorOnLine.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction NavigatorOnLine() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nNavigatorOnLine.prototype.toString = function () {\n  if (this === NavigatorOnLine.prototype) {\n    return \"[object NavigatorOnLinePrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(NavigatorOnLine.prototype, \"onLine\", {\n  get() {\n    return this[impl].onLine;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorOnLine.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorOnLine.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: NavigatorOnLine,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../navigator/NavigatorOnLine-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/navigator/NavigatorOnLine-impl.js":"\"use strict\";\n\nexports.implementation = class NavigatorOnLineImpl {\n  get onLine() {\n    return true;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/NavigatorCookies.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction NavigatorCookies() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nNavigatorCookies.prototype.toString = function () {\n  if (this === NavigatorCookies.prototype) {\n    return \"[object NavigatorCookiesPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(NavigatorCookies.prototype, \"cookieEnabled\", {\n  get() {\n    return this[impl].cookieEnabled;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorCookies.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorCookies.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: NavigatorCookies,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../navigator/NavigatorCookies-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/navigator/NavigatorCookies-impl.js":"\"use strict\";\n\nexports.implementation = class NavigatorCookiesImpl {\n  get cookieEnabled() {\n    return true;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/NavigatorPlugins.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction NavigatorPlugins() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nNavigatorPlugins.prototype.javaEnabled = function javaEnabled() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].javaEnabled.apply(this[impl], args);\n};\n\nNavigatorPlugins.prototype.toString = function () {\n  if (this === NavigatorPlugins.prototype) {\n    return \"[object NavigatorPluginsPrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorPlugins.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorPlugins.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: NavigatorPlugins,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../navigator/NavigatorPlugins-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/navigator/NavigatorPlugins-impl.js":"\"use strict\";\n\nexports.implementation = class NavigatorPluginsImpl {\n  javaEnabled() {\n    return false;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/NavigatorConcurrentHardware.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction NavigatorConcurrentHardware() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nNavigatorConcurrentHardware.prototype.toString = function () {\n  if (this === NavigatorConcurrentHardware.prototype) {\n    return \"[object NavigatorConcurrentHardwarePrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(NavigatorConcurrentHardware.prototype, \"hardwareConcurrency\", {\n  get() {\n    return this[impl].hardwareConcurrency;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorConcurrentHardware.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(NavigatorConcurrentHardware.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: NavigatorConcurrentHardware,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../navigator/NavigatorConcurrentHardware-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/navigator/NavigatorConcurrentHardware-impl.js":"\"use strict\";\nconst os = require(\"os\");\n\nexports.implementation = class NavigatorConcurrentHardwareImpl {\n  get hardwareConcurrency() {\n    return os.cpus().length;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/navigator/Navigator-impl.js":"\"use strict\";\nconst idlUtils = require(\"../generated/utils\");\nconst NavigatorIDImpl = require(\"./NavigatorID-impl\").implementation;\nconst NavigatorLanguageImpl = require(\"./NavigatorLanguage-impl\").implementation;\nconst NavigatorOnLineImpl = require(\"./NavigatorOnLine-impl\").implementation;\nconst NavigatorCookiesImpl = require(\"./NavigatorCookies-impl\").implementation;\nconst NavigatorPluginsImpl = require(\"./NavigatorPlugins-impl\").implementation;\nconst NavigatorConcurrentHardwareImpl = require(\"./NavigatorConcurrentHardware-impl\").implementation;\n\nclass NavigatorImpl {\n  constructor(args, privateData) {\n    this.userAgent = privateData.userAgent;\n    this.languages = Object.freeze([\"en-US\", \"en\"]);\n  }\n}\n\nidlUtils.mixin(NavigatorImpl.prototype, NavigatorIDImpl.prototype);\nidlUtils.mixin(NavigatorImpl.prototype, NavigatorLanguageImpl.prototype);\nidlUtils.mixin(NavigatorImpl.prototype, NavigatorOnLineImpl.prototype);\nidlUtils.mixin(NavigatorImpl.prototype, NavigatorCookiesImpl.prototype);\nidlUtils.mixin(NavigatorImpl.prototype, NavigatorPluginsImpl.prototype);\nidlUtils.mixin(NavigatorImpl.prototype, NavigatorConcurrentHardwareImpl.prototype);\n\nexports.implementation = NavigatorImpl;\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/index.js":"\"use strict\";\n\nexports.DOMException = require(\"../web-idl/DOMException\");\nexports.NamedNodeMap = require(\"./attributes\").NamedNodeMap;\nexports.Attr = require(\"./generated/Attr\").interface;\nexports.Node = require(\"./generated/Node\").interface;\nexports.Element = require(\"./generated/Element\").interface;\nexports.DocumentFragment = require(\"./generated/DocumentFragment\").interface;\nexports.Document = exports.HTMLDocument = require(\"./generated/Document\").interface;\nexports.XMLDocument = require(\"./generated/XMLDocument\").interface;\nexports.CharacterData = require(\"./generated/CharacterData\").interface;\nexports.Text = require(\"./generated/Text\").interface;\nexports.CDATASection = require(\"./generated/CDATASection\").interface;\nexports.ProcessingInstruction = require(\"./generated/ProcessingInstruction\").interface;\nexports.Comment = require(\"./generated/Comment\").interface;\nexports.DocumentType = require(\"./generated/DocumentType\").interface;\nexports.DOMImplementation = require(\"./generated/DOMImplementation\").interface;\n\nexports.Event = require(\"./generated/Event\").interface;\nexports.CustomEvent = require(\"./generated/CustomEvent\").interface;\nexports.MessageEvent = require(\"./generated/MessageEvent\").interface;\nexports.ErrorEvent = require(\"./generated/ErrorEvent\").interface;\nexports.HashChangeEvent = require(\"./generated/HashChangeEvent\").interface;\nexports.FocusEvent = require(\"./generated/FocusEvent\").interface;\nexports.PopStateEvent = require(\"./generated/PopStateEvent\").interface;\nexports.UIEvent = require(\"./generated/UIEvent\").interface;\nexports.MouseEvent = require(\"./generated/MouseEvent\").interface;\nexports.KeyboardEvent = require(\"./generated/KeyboardEvent\").interface;\nexports.TouchEvent = require(\"./generated/TouchEvent\").interface;\nexports.ProgressEvent = require(\"./generated/ProgressEvent\").interface;\nexports.EventTarget = require(\"./generated/EventTarget\").interface;\n\nexports.Location = require(\"./generated/Location\").interface;\nexports.History = require(\"./generated/History\").interface;\n\nexports.Blob = require(\"./generated/Blob\").interface;\nexports.File = require(\"./generated/File\").interface;\nexports.FileList = require(\"./generated/FileList\").interface;\n\nexports.DOMParser = require(\"./generated/DOMParser\").interface;\n\nexports.FormData = require(\"./generated/FormData\").interface;\n\nrequire(\"./register-elements\")(exports);\n\n// These need to be cleaned up...\nrequire(\"../level2/style\")(exports);\nrequire(\"../level3/xpath\")(exports);\n\n// These are OK but need migration to webidl2js eventually.\nrequire(\"./html-collection\")(exports);\nrequire(\"./node-filter\")(exports);\nrequire(\"./node-iterator\")(exports);\nrequire(\"./node-list\")(exports);\nrequire(\"./xmlhttprequest-event-target\")(exports);\nrequire(\"./xmlhttprequest-upload\")(exports);\n\nexports.DOMTokenList = require(\"./dom-token-list\").DOMTokenList;\nexports.URL = require(\"whatwg-url\").URL;\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/XMLDocument.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Document = require(\"./Document.js\");\nconst impl = utils.implSymbol;\n\nfunction XMLDocument() {\n  throw new TypeError(\"Illegal constructor\");\n}\nXMLDocument.prototype = Object.create(Document.interface.prototype);\nXMLDocument.prototype.constructor = XMLDocument;\n\n\nXMLDocument.prototype.toString = function () {\n  if (this === XMLDocument.prototype) {\n    return \"[object XMLDocumentPrototype]\";\n  }\n  return Document.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(XMLDocument.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(XMLDocument.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Document._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: XMLDocument,\n  expose: {\n    Window: { XMLDocument: XMLDocument }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/XMLDocument-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/XMLDocument-impl.js":"\"use strict\";\nconst DocumentImpl = require(\"./Document-impl\").implementation;\n\nexports.implementation = class XMLDocumentImpl extends DocumentImpl {};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/File.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Blob = require(\"./Blob.js\");\nconst impl = utils.implSymbol;\nconst convertFilePropertyBag = require(\"./FilePropertyBag\").convert;\n\nfunction File(fileBits, fileName) {\n  if (!this || this[impl] || !(this instanceof File)) {\n    throw new TypeError(\"Failed to construct 'File': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to construct 'File': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[1] = conversions[\"USVString\"](args[1]);\n  args[2] = convertFilePropertyBag(args[2]);\n\n  iface.setup(this, args);\n}\nFile.prototype = Object.create(Blob.interface.prototype);\nFile.prototype.constructor = File;\n\n\nFile.prototype.toString = function () {\n  if (this === File.prototype) {\n    return \"[object FilePrototype]\";\n  }\n  return Blob.interface.prototype.toString.call(this);\n};\nObject.defineProperty(File.prototype, \"name\", {\n  get() {\n    return this[impl].name;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(File.prototype, \"lastModified\", {\n  get() {\n    return this[impl].lastModified;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(File.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(File.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Blob._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: File,\n  expose: {\n    Window: { File: File },\n    Worker: { File: File }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../file-api/File-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/FilePropertyBag.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst BlobPropertyBag = require(\"./BlobPropertyBag\");\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    BlobPropertyBag.convertInherit(obj, ret);\n    let key, value;\n\n    key = \"lastModified\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"long long\"](value);\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/file-api/File-impl.js":"\"use strict\";\n\nconst BlobImpl = require(\"./Blob-impl\").implementation;\n\nexports.implementation = class FileImpl extends BlobImpl {\n  constructor(args, privateData) {\n    const fileBits = args[0];\n    const fileName = args[1];\n    const options = args[2];\n    super([fileBits, options], privateData);\n\n    this.name = fileName.replace(/\\//g, \":\");\n    this.lastModified = \"lastModified\" in options ? options.lastModified : Date.now();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/FileList.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction FileList() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nFileList.prototype.item = function item(index) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'item' on 'FileList': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"unsigned long\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].item.apply(this[impl], args));\n};\n\nFileList.prototype.toString = function () {\n  if (this === FileList.prototype) {\n    return \"[object FileListPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(FileList.prototype, \"length\", {\n  get() {\n    return this[impl].length;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(FileList.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(FileList.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: FileList,\n  expose: {\n    Window: { FileList: FileList },\n    Worker: { FileList: FileList }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../file-api/FileList-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/file-api/FileList-impl.js":"\"use strict\";\n\nexports.implementation = class FileListImpl extends Array {\n  constructor() {\n    super(0);\n  }\n  item(index) {\n    return this[index] || null;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/DOMParser.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction DOMParser() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n\n  iface.setup(this, args);\n}\n\n\nDOMParser.prototype.parseFromString = function parseFromString(str, type) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'parseFromString' on 'DOMParser': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].parseFromString.apply(this[impl], args));\n};\n\nDOMParser.prototype.toString = function () {\n  if (this === DOMParser.prototype) {\n    return \"[object DOMParserPrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(DOMParser.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(DOMParser.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: DOMParser,\n  expose: {\n    Window: { DOMParser: DOMParser }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../domparsing/DOMParser-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/domparsing/DOMParser-impl.js":"\"use strict\";\nconst Document = require(\"../generated/Document\");\nconst core = require(\"..\");\nconst applyDocumentFeatures = require(\"../../browser/documentfeatures\").applyDocumentFeatures;\n\nexports.implementation = class DOMParserImpl {\n  parseFromString(string, contentType) {\n    switch (String(contentType)) {\n      case \"text/html\": {\n        return createScriptingDisabledDocument(\"html\", contentType, string);\n      }\n\n      case \"text/xml\":\n      case \"application/xml\":\n      case \"application/xhtml+xml\":\n      case \"image/svg+xml\": {\n        // TODO: use a strict XML parser (sax's strict mode might work?) and create parsererror elements\n        try {\n          return createScriptingDisabledDocument(\"xml\", contentType, string);\n        } catch (error) {\n          const document = createScriptingDisabledDocument(\"xml\", contentType);\n          const element = document.createElementNS(\n            \"http://www.mozilla.org/newlayout/xml/parsererror.xml\", \"parsererror\");\n\n          element.textContent = error.message;\n\n          document.appendChild(element);\n          return document;\n        }\n      }\n\n      default:\n        throw new TypeError(\"Invalid contentType\");\n    }\n  }\n};\n\nfunction createScriptingDisabledDocument(parsingMode, contentType, string) {\n  const document = Document.createImpl([], {\n    core,\n    options: {\n      parsingMode,\n      encoding: \"UTF-8\",\n      contentType\n      // TODO: somehow set URL to active document's URL\n    }\n  });\n\n  // \"scripting enabled\" set to false\n  applyDocumentFeatures(document, {\n    FetchExternalResources: [],\n    ProcessExternalResources: false,\n    SkipExternalResources: false\n  });\n\n  if (string !== undefined) {\n    document._htmlToDom.appendHtmlToDocument(string, document);\n  }\n  document.close();\n  return document;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/FormData.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction FormData() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n\n  iface.setup(this, args);\n}\n\n\nFormData.prototype.append = function append(name, value) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'append' on 'FormData': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"USVString\"](args[2]);\n  }\n  return this[impl].append.apply(this[impl], args);\n};\n\nFormData.prototype.delete = function _(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'delete' on 'FormData': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  return this[impl].delete.apply(this[impl], args);\n};\n\nFormData.prototype.get = function get(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'get' on 'FormData': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].get.apply(this[impl], args));\n};\n\nFormData.prototype.getAll = function getAll(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getAll' on 'FormData': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].getAll.apply(this[impl], args));\n};\n\nFormData.prototype.has = function has(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'has' on 'FormData': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  return this[impl].has.apply(this[impl], args);\n};\n\nFormData.prototype.set = function set(name, value) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'set' on 'FormData': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"USVString\"](args[2]);\n  }\n  return this[impl].set.apply(this[impl], args);\n};\n\nFormData.prototype.toString = function () {\n  if (this === FormData.prototype) {\n    return \"[object FormDataPrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(FormData.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(FormData.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: FormData,\n  expose: {\n    Window: { FormData: FormData },\n    Worker: { FormData: FormData }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../xhr/FormData-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/xhr/FormData-impl.js":"\"use strict\";\nconst idlUtils = require(\"../generated/utils\");\nconst isFormElement = require(\"../generated/HTMLFormElement\").isImpl;\nconst closest = require(\"../helpers/traversal\").closest;\nconst isDisabled = require(\"../helpers/form-controls\").isDisabled;\nconst isSubmittable = require(\"../helpers/form-controls\").isSubmittable;\nconst isButton = require(\"../helpers/form-controls\").isButton;\nconst normalizeToCRLF = require(\"../helpers/form-controls\").normalizeToCRLF;\nconst Blob = require(\"../generated/Blob.js\");\nconst File = require(\"../generated/File.js\");\nconst conversions = require(\"webidl-conversions\");\n\nexports.implementation = class FormDataImpl {\n  constructor(args) {\n    this._entries = [];\n\n    if (args[0] !== undefined) {\n      if (!isFormElement(args[0])) {\n        throw new TypeError(\"First argument must undefined or a HTMLFormElement\");\n      }\n\n      this._entries = constructTheFormDataSet(args[0]);\n    }\n  }\n\n  append(name, value, filename) {\n    // Handling this manually for now: https://github.com/jsdom/webidl2js/issues/29\n    if (!Blob.isImpl(value)) {\n      value = conversions.USVString(value);\n    }\n\n    const entry = createAnEntry(name, value, filename);\n    this._entries.push(entry);\n  }\n\n  delete(name) {\n    this._entries = this._entries.filter(entry => entry.name !== name);\n  }\n\n  get(name) {\n    const foundEntry = this._entries.find(entry => entry.name === name);\n    return foundEntry !== undefined ? foundEntry.value : null;\n  }\n\n  getAll(name) {\n    return this._entries.filter(entry => entry.name === name).map(entry => entry.value);\n  }\n\n  has(name) {\n    return this._entries.findIndex(entry => entry.name === name) !== -1;\n  }\n\n  set(name, value, filename) {\n    // Handling this manually for now: https://github.com/jsdom/webidl2js/issues/29\n    if (!Blob.isImpl(value)) {\n      value = conversions.USVString(value);\n    }\n\n    const entry = createAnEntry(name, value, filename);\n\n    const foundIndex = this._entries.findIndex(e => e.name === name);\n    if (foundIndex !== -1) {\n      this._entries[foundIndex] = entry;\n      this._entries = this._entries.filter((e, i) => e.name !== name || i === foundIndex);\n    } else {\n      this._entries.push(entry);\n    }\n  }\n};\n\nfunction createAnEntry(name, value, filename) {\n  const entry = { name };\n\n  // https://github.com/whatwg/xhr/issues/75\n\n  if (Blob.isImpl(value) && !File.isImpl(value)) {\n    const oldValue = value;\n    value = File.createImpl([\n      [],\n      \"blob\",\n      { type: oldValue.type }\n    ]);\n    // \"representing the same bytes\"\n    value._buffer = oldValue._buffer;\n  }\n\n  if (File.isImpl(value) && filename !== undefined) {\n    const oldValue = value;\n    value = File.createImpl([\n      [],\n      filename,\n      // spec makes no mention of `lastModified`; assume it is inherited\n      // (Chrome's behavior)\n      { type: oldValue.type, lastModified: oldValue.lastModified }\n    ]);\n    // \"representing the same bytes\"\n    value._buffer = oldValue._buffer;\n  }\n\n  entry.value = value;\n\n  return entry;\n}\n\nfunction constructTheFormDataSet(form, submitter) {\n  // https://html.spec.whatwg.org/multipage/forms.html#constructing-form-data-set\n\n  const controls = Array.prototype.filter.call(form.elements, isSubmittable); // submittable is a subset of listed\n  const formDataSet = [];\n\n  for (const fieldWrapper of controls) {\n    const field = idlUtils.implForWrapper(fieldWrapper);\n\n    if (closest(field, \"datalist\") !== null) {\n      continue;\n    }\n    if (isDisabled(field)) {\n      continue;\n    }\n    if (isButton(field) && field !== submitter) {\n      continue;\n    }\n    if (field.type === \"checkbox\" && field._checkedness === false) {\n      continue;\n    }\n    if (field.type === \"radio\" && field._checkedness === false) {\n      continue;\n    }\n    if (field.type !== \"image\" && (!field.hasAttribute(\"name\") || field.getAttribute(\"name\") === \"\")) {\n      continue;\n    }\n    if (field.localName === \"object\") { // in jsdom, no objects are \"using a plugin\"\n      continue;\n    }\n\n    const type = field.type;\n\n    // Omit special processing of <input type=\"image\"> since so far we don't actually ever pass submitter\n\n    const nameAttr = field.getAttribute(\"name\");\n    const name = nameAttr === null ? \"\" : nameAttr;\n\n    if (field.localName === \"select\") {\n      for (let i = 0; i < field.options.length; ++i) {\n        const option = idlUtils.implForWrapper(field.options[i]);\n        if (option._selectedness === true && !isDisabled(field)) {\n          formDataSet.push({ name, value: option.value, type });\n        }\n      }\n    } else if (field.localName === \"input\" && (type === \"checkbox\" || type === \"radio\")) {\n      const value = field.hasAttribute(\"value\") ? field.getAttribute(\"value\") : \"on\";\n      formDataSet.push({ name, value, type });\n    } else if (type === \"file\") {\n      for (let i = 0; i < field.files.length; ++i) {\n        formDataSet.push({ name, value: field.files.item(i), type });\n      }\n\n      if (field.files.length === 0) {\n        formDataSet.push({ name, value: \"\", type: \"application/octet-stream\" });\n      }\n    } /* skip plugins */ else {\n      formDataSet.push({ name, value: field._getValue(), type });\n    }\n\n    const dirname = field.getAttribute(\"dirname\");\n    if (dirname !== null && dirname !== \"\") {\n      const dir = \"ltr\"; // jsdom does not (yet?) implement actual directionality\n      formDataSet.push({ name: dirname, value: dir, type: \"direction\" });\n    }\n  }\n\n  for (const entry of formDataSet) {\n    entry.name = conversions.USVString(normalizeToCRLF(entry.name));\n\n    if (entry.type !== \"file\" && entry.type !== \"textarea\") {\n      entry.value = normalizeToCRLF(entry.value);\n    }\n\n    if (entry.type !== \"file\") {\n      entry.value = conversions.USVString(entry.value);\n    }\n  }\n\n  return formDataSet;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLFormElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLFormElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLFormElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLFormElement.prototype.constructor = HTMLFormElement;\n\n\nHTMLFormElement.prototype.submit = function submit() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].submit.apply(this[impl], args);\n};\n\nHTMLFormElement.prototype.reset = function reset() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].reset.apply(this[impl], args);\n};\n\nHTMLFormElement.prototype.toString = function () {\n  if (this === HTMLFormElement.prototype) {\n    return \"[object HTMLFormElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLFormElement.prototype, \"acceptCharset\", {\n  get() {\n    const value = this.getAttribute(\"accept-charset\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"accept-charset\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFormElement.prototype, \"action\", {\n  get() {\n    return this[impl].action;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].action = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFormElement.prototype, \"enctype\", {\n  get() {\n    return this[impl].enctype;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].enctype = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFormElement.prototype, \"method\", {\n  get() {\n    return this[impl].method;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].method = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFormElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFormElement.prototype, \"noValidate\", {\n  get() {\n    return this.hasAttribute(\"noValidate\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"noValidate\", \"\");\n  } else {\n    this.removeAttribute(\"noValidate\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFormElement.prototype, \"target\", {\n  get() {\n    const value = this.getAttribute(\"target\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"target\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFormElement.prototype, \"elements\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].elements);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFormElement.prototype, \"length\", {\n  get() {\n    return this[impl].length;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFormElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFormElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLFormElement,\n  expose: {\n    Window: { HTMLFormElement: HTMLFormElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLFormElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLFormElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst descendantsByHTMLLocalNames = require(\"../helpers/traversal\").descendantsByHTMLLocalNames;\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst createHTMLCollection = require(\"../../living/html-collection\").create;\nconst notImplemented = require(\"../../browser/not-implemented\");\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\n\n// http://www.whatwg.org/specs/web-apps/current-work/#category-listed\nconst listedElements = new Set([\"button\", \"fieldset\", \"input\", \"keygen\", \"object\", \"select\", \"textarea\"]);\n\nconst encTypes = new Set([\n  \"application/x-www-form-urlencoded\",\n  \"multipart/form-data\",\n  \"text/plain\"\n]);\n\nconst methods = new Set([\n  \"get\",\n  \"post\",\n  \"dialog\"\n]);\n\nclass HTMLFormElementImpl extends HTMLElementImpl {\n  _descendantAdded(parent, child) {\n    const form = this;\n    for (const el of domSymbolTree.treeIterator(child)) {\n      if (typeof el._changedFormOwner === \"function\") {\n        el._changedFormOwner(form);\n      }\n    }\n\n    super._descendantAdded.apply(this, arguments);\n  }\n\n  _descendantRemoved(parent, child) {\n    for (const el of domSymbolTree.treeIterator(child)) {\n      if (typeof el._changedFormOwner === \"function\") {\n        el._changedFormOwner(null);\n      }\n    }\n\n    super._descendantRemoved.apply(this, arguments);\n  }\n\n  get elements() {\n    return createHTMLCollection(this, () => descendantsByHTMLLocalNames(this, listedElements));\n  }\n\n  get length() {\n    return this.elements.length;\n  }\n\n  _dispatchSubmitEvent() {\n    const ev = this._ownerDocument.createEvent(\"HTMLEvents\");\n    ev.initEvent(\"submit\", true, true);\n    if (this.dispatchEvent(ev)) {\n      this.submit();\n    }\n  }\n\n  submit() {\n    notImplemented(\"HTMLFormElement.prototype.submit\", this._ownerDocument._defaultView);\n  }\n\n  reset() {\n    Array.prototype.forEach.call(this.elements, el => {\n      el = idlUtils.implForWrapper(el);\n      if (typeof el._formReset === \"function\") {\n        el._formReset();\n      }\n    });\n  }\n\n  get method() {\n    let method = this.getAttribute(\"method\");\n    if (method) {\n      method = method.toLowerCase();\n    }\n\n    if (methods.has(method)) {\n      return method;\n    }\n    return \"get\";\n  }\n\n  set method(V) {\n    this.setAttribute(\"method\", V);\n  }\n\n  get enctype() {\n    let type = this.getAttribute(\"enctype\");\n    if (type) {\n      type = type.toLowerCase();\n    }\n\n    if (encTypes.has(type)) {\n      return type;\n    }\n    return \"application/x-www-form-urlencoded\";\n  }\n\n  set enctype(V) {\n    this.setAttribute(\"enctype\", V);\n  }\n\n  get action() {\n    const attributeValue = this.getAttribute(\"action\");\n    if (attributeValue === null || attributeValue === \"\") {\n      return this._ownerDocument.URL;\n    }\n\n    return reflectURLAttribute(this, \"action\");\n  }\n\n  set action(V) {\n    this.setAttribute(\"action\", V);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLFormElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/register-elements.js":"\"use strict\";\n/* eslint global-require: 0 */\n\nconst DocumentImpl = require(\"./nodes/Document-impl.js\");\n\nconst mappings = {\n  HTMLElement: {\n    file: require(\"./generated/HTMLElement.js\"),\n    tags: []\n  },\n  HTMLAnchorElement: {\n    file: require(\"./generated/HTMLAnchorElement.js\"),\n    tags: [\"a\"]\n  },\n  HTMLAppletElement: {\n    file: require(\"./generated/HTMLAppletElement.js\"),\n    tags: [\"applet\"]\n  },\n  HTMLAreaElement: {\n    file: require(\"./generated/HTMLAreaElement.js\"),\n    tags: [\"area\"]\n  },\n  HTMLAudioElement: {\n    file: require(\"./generated/HTMLAudioElement.js\"),\n    tags: [\"audio\"]\n  },\n  HTMLBaseElement: {\n    file: require(\"./generated/HTMLBaseElement.js\"),\n    tags: [\"base\"]\n  },\n  HTMLBodyElement: {\n    file: require(\"./generated/HTMLBodyElement.js\"),\n    tags: [\"body\"]\n  },\n  HTMLBRElement: {\n    file: require(\"./generated/HTMLBRElement.js\"),\n    tags: [\"br\"]\n  },\n  HTMLButtonElement: {\n    file: require(\"./generated/HTMLButtonElement.js\"),\n    tags: [\"button\"]\n  },\n  HTMLCanvasElement: {\n    file: require(\"./generated/HTMLCanvasElement.js\"),\n    tags: [\"canvas\"]\n  },\n  HTMLDataElement: {\n    file: require(\"./generated/HTMLDataElement.js\"),\n    tags: [\"data\"]\n  },\n  HTMLDataListElement: {\n    file: require(\"./generated/HTMLDataListElement.js\"),\n    tags: [\"datalist\"]\n  },\n  HTMLDialogElement: {\n    file: require(\"./generated/HTMLDialogElement.js\"),\n    tags: [\"dialog\"]\n  },\n  HTMLDirectoryElement: {\n    file: require(\"./generated/HTMLDirectoryElement.js\"),\n    tags: [\"dir\"]\n  },\n  HTMLDivElement: {\n    file: require(\"./generated/HTMLDivElement.js\"),\n    tags: [\"div\"]\n  },\n  HTMLDListElement: {\n    file: require(\"./generated/HTMLDListElement.js\"),\n    tags: [\"dl\"]\n  },\n  HTMLEmbedElement: {\n    file: require(\"./generated/HTMLEmbedElement.js\"),\n    tags: [\"embed\"]\n  },\n  HTMLFieldSetElement: {\n    file: require(\"./generated/HTMLFieldSetElement.js\"),\n    tags: [\"fieldset\"]\n  },\n  HTMLFontElement: {\n    file: require(\"./generated/HTMLFontElement.js\"),\n    tags: [\"font\"]\n  },\n  HTMLFormElement: {\n    file: require(\"./generated/HTMLFormElement.js\"),\n    tags: [\"form\"]\n  },\n  HTMLFrameElement: {\n    file: require(\"./generated/HTMLFrameElement.js\"),\n    tags: [\"frame\"]\n  },\n  HTMLFrameSetElement: {\n    file: require(\"./generated/HTMLFrameSetElement.js\"),\n    tags: [\"frameset\"]\n  },\n  HTMLHeadingElement: {\n    file: require(\"./generated/HTMLHeadingElement.js\"),\n    tags: [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"]\n  },\n  HTMLHeadElement: {\n    file: require(\"./generated/HTMLHeadElement.js\"),\n    tags: [\"head\"]\n  },\n  HTMLHRElement: {\n    file: require(\"./generated/HTMLHRElement.js\"),\n    tags: [\"hr\"]\n  },\n  HTMLHtmlElement: {\n    file: require(\"./generated/HTMLHtmlElement.js\"),\n    tags: [\"html\"]\n  },\n  HTMLIFrameElement: {\n    file: require(\"./generated/HTMLIFrameElement.js\"),\n    tags: [\"iframe\"]\n  },\n  HTMLImageElement: {\n    file: require(\"./generated/HTMLImageElement.js\"),\n    tags: [\"img\"]\n  },\n  HTMLInputElement: {\n    file: require(\"./generated/HTMLInputElement.js\"),\n    tags: [\"input\"]\n  },\n  HTMLLabelElement: {\n    file: require(\"./generated/HTMLLabelElement.js\"),\n    tags: [\"label\"]\n  },\n  HTMLLegendElement: {\n    file: require(\"./generated/HTMLLegendElement.js\"),\n    tags: [\"legend\"]\n  },\n  HTMLLIElement: {\n    file: require(\"./generated/HTMLLIElement.js\"),\n    tags: [\"li\"]\n  },\n  HTMLLinkElement: {\n    file: require(\"./generated/HTMLLinkElement.js\"),\n    tags: [\"link\"]\n  },\n  HTMLMapElement: {\n    file: require(\"./generated/HTMLMapElement.js\"),\n    tags: [\"map\"]\n  },\n  HTMLMediaElement: {\n    file: require(\"./generated/HTMLMediaElement.js\"),\n    tags: []\n  },\n  HTMLMenuElement: {\n    file: require(\"./generated/HTMLMenuElement.js\"),\n    tags: [\"menu\"]\n  },\n  HTMLMetaElement: {\n    file: require(\"./generated/HTMLMetaElement.js\"),\n    tags: [\"meta\"]\n  },\n  HTMLMeterElement: {\n    file: require(\"./generated/HTMLMeterElement.js\"),\n    tags: [\"meter\"]\n  },\n  HTMLModElement: {\n    file: require(\"./generated/HTMLModElement.js\"),\n    tags: [\"del\", \"ins\"]\n  },\n  HTMLObjectElement: {\n    file: require(\"./generated/HTMLObjectElement.js\"),\n    tags: [\"object\"]\n  },\n  HTMLOListElement: {\n    file: require(\"./generated/HTMLOListElement.js\"),\n    tags: [\"ol\"]\n  },\n  HTMLOptGroupElement: {\n    file: require(\"./generated/HTMLOptGroupElement.js\"),\n    tags: [\"optgroup\"]\n  },\n  HTMLOptionElement: {\n    file: require(\"./generated/HTMLOptionElement.js\"),\n    tags: [\"option\"]\n  },\n  HTMLOutputElement: {\n    file: require(\"./generated/HTMLOutputElement.js\"),\n    tags: [\"output\"]\n  },\n  HTMLParagraphElement: {\n    file: require(\"./generated/HTMLParagraphElement.js\"),\n    tags: [\"p\"]\n  },\n  HTMLParamElement: {\n    file: require(\"./generated/HTMLParamElement.js\"),\n    tags: [\"param\"]\n  },\n  HTMLPreElement: {\n    file: require(\"./generated/HTMLPreElement.js\"),\n    tags: [\"pre\"]\n  },\n  HTMLProgressElement: {\n    file: require(\"./generated/HTMLProgressElement.js\"),\n    tags: [\"progress\"]\n  },\n  HTMLQuoteElement: {\n    file: require(\"./generated/HTMLQuoteElement.js\"),\n    tags: [\"blockquote\", \"q\"]\n  },\n  HTMLScriptElement: {\n    file: require(\"./generated/HTMLScriptElement.js\"),\n    tags: [\"script\"]\n  },\n  HTMLSelectElement: {\n    file: require(\"./generated/HTMLSelectElement.js\"),\n    tags: [\"select\"]\n  },\n  HTMLSourceElement: {\n    file: require(\"./generated/HTMLSourceElement.js\"),\n    tags: [\"source\"]\n  },\n  HTMLSpanElement: {\n    file: require(\"./generated/HTMLSpanElement.js\"),\n    tags: [\"span\"]\n  },\n  HTMLStyleElement: {\n    file: require(\"./generated/HTMLStyleElement.js\"),\n    tags: [\"style\"]\n  },\n  HTMLTableCaptionElement: {\n    file: require(\"./generated/HTMLTableCaptionElement.js\"),\n    tags: [\"caption\"]\n  },\n  HTMLTableCellElement: {\n    file: require(\"./generated/HTMLTableCellElement.js\"),\n    tags: []\n  },\n  HTMLTableColElement: {\n    file: require(\"./generated/HTMLTableColElement.js\"),\n    tags: [\"col\", \"colgroup\"]\n  },\n  HTMLTableDataCellElement: {\n    file: require(\"./generated/HTMLTableDataCellElement.js\"),\n    tags: [\"td\"]\n  },\n  HTMLTableElement: {\n    file: require(\"./generated/HTMLTableElement.js\"),\n    tags: [\"table\"]\n  },\n  HTMLTableHeaderCellElement: {\n    file: require(\"./generated/HTMLTableHeaderCellElement.js\"),\n    tags: [\"th\"]\n  },\n  HTMLTimeElement: {\n    file: require(\"./generated/HTMLTimeElement.js\"),\n    tags: [\"time\"]\n  },\n  HTMLTitleElement: {\n    file: require(\"./generated/HTMLTitleElement.js\"),\n    tags: [\"title\"]\n  },\n  HTMLTableRowElement: {\n    file: require(\"./generated/HTMLTableRowElement.js\"),\n    tags: [\"tr\"]\n  },\n  HTMLTableSectionElement: {\n    file: require(\"./generated/HTMLTableSectionElement.js\"),\n    tags: [\"thead\", \"tbody\", \"tfoot\"]\n  },\n  HTMLTemplateElement: {\n    file: require(\"./generated/HTMLTemplateElement.js\"),\n    tags: [\"template\"]\n  },\n  HTMLTextAreaElement: {\n    file: require(\"./generated/HTMLTextAreaElement.js\"),\n    tags: [\"textarea\"]\n  },\n  HTMLTrackElement: {\n    file: require(\"./generated/HTMLTrackElement.js\"),\n    tags: [\"track\"]\n  },\n  HTMLUListElement: {\n    file: require(\"./generated/HTMLUListElement.js\"),\n    tags: [\"ul\"]\n  },\n  HTMLUnknownElement: {\n    file: require(\"./generated/HTMLUnknownElement.js\"),\n    tags: []\n  },\n  HTMLVideoElement: {\n    file: require(\"./generated/HTMLVideoElement.js\"),\n    tags: [\"video\"]\n  }\n};\n\nmodule.exports = core => {\n  for (const interfaceName of Object.keys(mappings)) {\n    const file = mappings[interfaceName].file;\n    const tags = mappings[interfaceName].tags;\n\n    core[interfaceName] = file.interface;\n\n    for (const tagName of tags) {\n      DocumentImpl.implementation.prototype._elementBuilders[tagName] = (document, elName) => {\n        return file.create([], {\n          core,\n          ownerDocument: document,\n          localName: elName || tagName.toUpperCase()\n        });\n      };\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLAnchorElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst HTMLHyperlinkElementUtils = require(\"./HTMLHyperlinkElementUtils.js\");\n\nfunction HTMLAnchorElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLAnchorElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLAnchorElement.prototype.constructor = HTMLAnchorElement;\n\nmixin(HTMLAnchorElement.prototype, HTMLHyperlinkElementUtils.interface.prototype);\nHTMLHyperlinkElementUtils.mixedInto.push(HTMLAnchorElement);\n\nHTMLAnchorElement.prototype.toString = function () {\n  if (this === HTMLAnchorElement.prototype) {\n    return \"[object HTMLAnchorElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLAnchorElement.prototype, \"target\", {\n  get() {\n    const value = this.getAttribute(\"target\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"target\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"download\", {\n  get() {\n    const value = this.getAttribute(\"download\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"download\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"rel\", {\n  get() {\n    const value = this.getAttribute(\"rel\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"rel\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"hreflang\", {\n  get() {\n    const value = this.getAttribute(\"hreflang\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"hreflang\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"text\", {\n  get() {\n    return this[impl].text;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].text = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"coords\", {\n  get() {\n    const value = this.getAttribute(\"coords\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"coords\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"charset\", {\n  get() {\n    const value = this.getAttribute(\"charset\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"charset\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"rev\", {\n  get() {\n    const value = this.getAttribute(\"rev\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"rev\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAnchorElement.prototype, \"shape\", {\n  get() {\n    const value = this.getAttribute(\"shape\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"shape\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLAnchorElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLAnchorElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLAnchorElement,\n  expose: {\n    Window: { HTMLAnchorElement: HTMLAnchorElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLAnchorElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLHyperlinkElementUtils.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLHyperlinkElementUtils() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nHTMLHyperlinkElementUtils.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this[impl].href;;\n};\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"username\", {\n  get() {\n    return this[impl].username;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].username = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"password\", {\n  get() {\n    return this[impl].password;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].password = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHyperlinkElementUtils.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHyperlinkElementUtils.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHyperlinkElementUtils.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLHyperlinkElementUtils,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLHyperlinkElementUtils-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLHyperlinkElementUtils-impl.js":"\"use strict\";\nconst whatwgURL = require(\"whatwg-url\");\nconst parseURLToResultingURLRecord = require(\"../helpers/document-base-url\").parseURLToResultingURLRecord;\n\nexports.implementation = class HTMLHyperlinkElementUtilsImpl {\n  _htmlHyperlinkElementUtilsSetup() {\n    this.url = null;\n  }\n\n  toString() {\n    return this.href;\n  }\n\n  get href() {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null) {\n      const href = this.getAttribute(\"href\");\n      return href === null ? \"\" : href;\n    }\n\n    return whatwgURL.serializeURL(url);\n  }\n\n  set href(v) {\n    this.setAttribute(\"href\", v);\n  }\n\n  get origin() {\n    setTheURL(this);\n\n    if (this.url === null) {\n      return \"\";\n    }\n\n    return whatwgURL.serializeURLToUnicodeOrigin(this.url);\n  }\n\n  get protocol() {\n    setTheURL(this);\n\n    if (this.url === null) {\n      return \":\";\n    }\n\n    return this.url.scheme + \":\";\n  }\n\n  set protocol(v) {\n    if (this.url === null) {\n      return;\n    }\n\n    whatwgURL.basicURLParse(v + \":\", { url: this.url, stateOverride: \"scheme start\" });\n    updateHref(this);\n  }\n\n  get username() {\n    setTheURL(this);\n\n    if (this.url === null) {\n      return \"\";\n    }\n\n    return this.url.username;\n  }\n\n  set username(v) {\n    const url = this.url;\n\n    if (url === null || url.host === null || url.cannotBeABaseURL) {\n      return;\n    }\n\n    whatwgURL.setTheUsername(url, v);\n    updateHref(this);\n  }\n\n  get password() {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.password === null) {\n      return \"\";\n    }\n\n    return url.password;\n  }\n\n  set password(v) {\n    const url = this.url;\n\n    if (url === null || url.host === null || url.cannotBeABaseURL) {\n      return;\n    }\n\n    whatwgURL.setThePassword(url, v);\n    updateHref(this);\n  }\n\n  get host() {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.host === null) {\n      return \"\";\n    }\n\n    if (url.port === null) {\n      return whatwgURL.serializeHost(url.host);\n    }\n\n    return whatwgURL.serializeHost(url.host) + \":\" + whatwgURL.serializeInteger(url.port);\n  }\n\n  set host(v) {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.cannotBeABaseURL) {\n      return;\n    }\n\n    whatwgURL.basicURLParse(v, { url, stateOverride: \"host\" });\n    updateHref(this);\n  }\n\n  get hostname() {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.host === null) {\n      return \"\";\n    }\n\n    return whatwgURL.serializeHost(url.host);\n  }\n\n  set hostname(v) {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.cannotBeABaseURL) {\n      return;\n    }\n\n    whatwgURL.basicURLParse(v, { url, stateOverride: \"hostname\" });\n    updateHref(this);\n  }\n\n  get port() {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.port === null) {\n      return \"\";\n    }\n\n    return whatwgURL.serializeInteger(url.port);\n  }\n\n  set port(v) {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.host === null || url.cannotBeABaseURL || url.scheme === \"file\") {\n      return;\n    }\n\n    whatwgURL.basicURLParse(v, { url, stateOverride: \"port\" });\n    updateHref(this);\n  }\n\n  get pathname() {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null) {\n      return \"\";\n    }\n\n    if (url.cannotBeABaseURL) {\n      return url.path[0];\n    }\n\n    return \"/\" + url.path.join(\"/\");\n  }\n\n  set pathname(v) {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.cannotBeABaseURL) {\n      return;\n    }\n\n    url.path = [];\n    whatwgURL.basicURLParse(v, { url, stateOverride: \"path start\" });\n  }\n\n  get search() {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.query === null || url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + url.query;\n  }\n\n  set search(v) {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null) {\n      return;\n    }\n\n    if (v === \"\") {\n      url.query = null;\n    } else {\n      const input = v[0] === \"?\" ? v.substring(1) : v;\n      url.query = \"\";\n      whatwgURL.basicURLParse(input, { url, stateOverride: \"query\" });\n    }\n    updateHref(this);\n  }\n\n  get hash() {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.fragment === null || url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + url.fragment;\n  }\n\n  set hash(v) {\n    setTheURL(this);\n    const url = this.url;\n\n    if (url === null || url.scheme === \"javascript\") {\n      return;\n    }\n\n    if (v === \"\") {\n      url.fragment = null;\n    } else {\n      const input = v[0] === \"#\" ? v.substring(1) : v;\n      url.fragment = \"\";\n      whatwgURL.basicURLParse(input, { url, stateOverride: \"fragment\" });\n    }\n    updateHref(this);\n  }\n};\n\nfunction setTheURL(hheu) {\n  const href = hheu.getAttribute(\"href\");\n  if (href === null) {\n    hheu.url = null;\n    return;\n  }\n\n  const parsed = parseURLToResultingURLRecord(href, hheu._ownerDocument);\n\n  hheu.url = parsed === \"failure\" ? null : parsed;\n}\n\nfunction updateHref(hheu) {\n  hheu.setAttribute(\"href\", whatwgURL.serializeURL(hheu.url));\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLAnchorElement-impl.js":"\"use strict\";\nconst idlUtils = require(\"../generated/utils\");\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst HTMLHyperlinkElementUtilsImpl = require(\"./HTMLHyperlinkElementUtils-impl\").implementation;\n\nclass HTMLAnchorElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._htmlHyperlinkElementUtilsSetup();\n  }\n\n  get text() {\n    return this.textContent;\n  }\n  set text(v) {\n    this.textContent = v;\n  }\n}\n\nidlUtils.mixin(HTMLAnchorElementImpl.prototype, HTMLHyperlinkElementUtilsImpl.prototype);\n\nmodule.exports = {\n  implementation: HTMLAnchorElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLAppletElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLAppletElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLAppletElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLAppletElement.prototype.constructor = HTMLAppletElement;\n\n\nHTMLAppletElement.prototype.toString = function () {\n  if (this === HTMLAppletElement.prototype) {\n    return \"[object HTMLAppletElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLAppletElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"alt\", {\n  get() {\n    const value = this.getAttribute(\"alt\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"alt\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"archive\", {\n  get() {\n    const value = this.getAttribute(\"archive\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"archive\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"code\", {\n  get() {\n    const value = this.getAttribute(\"code\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"code\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"codeBase\", {\n  get() {\n    return this[impl].codeBase;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].codeBase = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"height\", {\n  get() {\n    const value = this.getAttribute(\"height\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"height\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"hspace\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"hspace\"));\n    return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    V = V > 2147483647 ? 0 : V;\n    this.setAttribute(\"hspace\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"object\", {\n  get() {\n    return this[impl].object;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].object = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"vspace\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"vspace\"));\n    return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    V = V > 2147483647 ? 0 : V;\n    this.setAttribute(\"vspace\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAppletElement.prototype, \"width\", {\n  get() {\n    const value = this.getAttribute(\"width\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"width\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLAppletElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLAppletElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLAppletElement,\n  expose: {\n    Window: { HTMLAppletElement: HTMLAppletElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLAppletElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLAppletElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\n\nclass HTMLAppletElementImpl extends HTMLElementImpl {\n  get object() {\n    return reflectURLAttribute(this, \"object\");\n  }\n\n  set object(V) {\n    this.setAttribute(\"object\", V);\n  }\n\n  get codeBase() {\n    return reflectURLAttribute(this, \"codebase\");\n  }\n\n  set codeBase(V) {\n    this.setAttribute(\"codebase\", V);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLAppletElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLAreaElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst HTMLHyperlinkElementUtils = require(\"./HTMLHyperlinkElementUtils.js\");\n\nfunction HTMLAreaElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLAreaElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLAreaElement.prototype.constructor = HTMLAreaElement;\n\nmixin(HTMLAreaElement.prototype, HTMLHyperlinkElementUtils.interface.prototype);\nHTMLHyperlinkElementUtils.mixedInto.push(HTMLAreaElement);\n\nHTMLAreaElement.prototype.toString = function () {\n  if (this === HTMLAreaElement.prototype) {\n    return \"[object HTMLAreaElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLAreaElement.prototype, \"alt\", {\n  get() {\n    const value = this.getAttribute(\"alt\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"alt\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAreaElement.prototype, \"coords\", {\n  get() {\n    const value = this.getAttribute(\"coords\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"coords\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAreaElement.prototype, \"shape\", {\n  get() {\n    const value = this.getAttribute(\"shape\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"shape\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAreaElement.prototype, \"target\", {\n  get() {\n    const value = this.getAttribute(\"target\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"target\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAreaElement.prototype, \"rel\", {\n  get() {\n    const value = this.getAttribute(\"rel\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"rel\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLAreaElement.prototype, \"noHref\", {\n  get() {\n    return this.hasAttribute(\"noHref\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"noHref\", \"\");\n  } else {\n    this.removeAttribute(\"noHref\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLAreaElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLAreaElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLAreaElement,\n  expose: {\n    Window: { HTMLAreaElement: HTMLAreaElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLAreaElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLAreaElement-impl.js":"\"use strict\";\nconst idlUtils = require(\"../generated/utils\");\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst HTMLHyperlinkElementUtilsImpl = require(\"./HTMLHyperlinkElementUtils-impl\").implementation;\n\nclass HTMLAreaElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._htmlHyperlinkElementUtilsSetup();\n  }\n}\n\nidlUtils.mixin(HTMLAreaElementImpl.prototype, HTMLHyperlinkElementUtilsImpl.prototype);\n\nmodule.exports = {\n  implementation: HTMLAreaElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLAudioElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLMediaElement = require(\"./HTMLMediaElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLAudioElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLAudioElement.prototype = Object.create(HTMLMediaElement.interface.prototype);\nHTMLAudioElement.prototype.constructor = HTMLAudioElement;\n\n\nHTMLAudioElement.prototype.toString = function () {\n  if (this === HTMLAudioElement.prototype) {\n    return \"[object HTMLAudioElementPrototype]\";\n  }\n  return HTMLMediaElement.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLAudioElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLAudioElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLMediaElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLAudioElement,\n  expose: {\n    Window: { HTMLAudioElement: HTMLAudioElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLAudioElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLMediaElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLMediaElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLMediaElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLMediaElement.prototype.constructor = HTMLMediaElement;\n\n\nHTMLMediaElement.prototype.load = function load() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].load.apply(this[impl], args);\n};\n\nHTMLMediaElement.prototype.canPlayType = function canPlayType(type) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'canPlayType' on 'HTMLMediaElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return utils.tryWrapperForImpl(this[impl].canPlayType.apply(this[impl], args));\n};\n\nHTMLMediaElement.prototype.play = function play() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].play.apply(this[impl], args);\n};\n\nHTMLMediaElement.prototype.pause = function pause() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].pause.apply(this[impl], args);\n};\n\nHTMLMediaElement.prototype.addTextTrack = function addTextTrack(kind) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'addTextTrack' on 'HTMLMediaElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"DOMString\"](args[1]);\n  } else {\n    args[1] = \"\";\n  }\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"DOMString\"](args[2]);\n  } else {\n    args[2] = \"\";\n  }\n  return utils.tryWrapperForImpl(this[impl].addTextTrack.apply(this[impl], args));\n};\n\nHTMLMediaElement.prototype.toString = function () {\n  if (this === HTMLMediaElement.prototype) {\n    return \"[object HTMLMediaElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLMediaElement.prototype, \"src\", {\n  get() {\n    return this[impl].src;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].src = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"currentSrc\", {\n  get() {\n    return this[impl].currentSrc;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"crossOrigin\", {\n  get() {\n    const value = this.getAttribute(\"crossOrigin\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this.setAttribute(\"crossOrigin\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"NETWORK_EMPTY\", {\n  value: 0,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"NETWORK_EMPTY\", {\n  value: 0,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"NETWORK_IDLE\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"NETWORK_IDLE\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"NETWORK_LOADING\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"NETWORK_LOADING\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"NETWORK_NO_SOURCE\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"NETWORK_NO_SOURCE\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"networkState\", {\n  get() {\n    return this[impl].networkState;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"preload\", {\n  get() {\n    const value = this.getAttribute(\"preload\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"preload\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"buffered\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].buffered);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"HAVE_NOTHING\", {\n  value: 0,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"HAVE_NOTHING\", {\n  value: 0,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"HAVE_METADATA\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"HAVE_METADATA\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"HAVE_CURRENT_DATA\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"HAVE_CURRENT_DATA\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"HAVE_FUTURE_DATA\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"HAVE_FUTURE_DATA\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement, \"HAVE_ENOUGH_DATA\", {\n  value: 4,\n  enumerable: true\n});\nObject.defineProperty(HTMLMediaElement.prototype, \"HAVE_ENOUGH_DATA\", {\n  value: 4,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"readyState\", {\n  get() {\n    return this[impl].readyState;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"seeking\", {\n  get() {\n    return this[impl].seeking;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"currentTime\", {\n  get() {\n    return this[impl].currentTime;\n  },\n  set(V) {\n    V = conversions[\"double\"](V);\n    this[impl].currentTime = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"duration\", {\n  get() {\n    return this[impl].duration;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"paused\", {\n  get() {\n    return this[impl].paused;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"defaultPlaybackRate\", {\n  get() {\n    return this[impl].defaultPlaybackRate;\n  },\n  set(V) {\n    V = conversions[\"double\"](V);\n    this[impl].defaultPlaybackRate = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"playbackRate\", {\n  get() {\n    return this[impl].playbackRate;\n  },\n  set(V) {\n    V = conversions[\"double\"](V);\n    this[impl].playbackRate = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"played\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].played);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"seekable\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].seekable);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"ended\", {\n  get() {\n    return this[impl].ended;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"autoplay\", {\n  get() {\n    return this.hasAttribute(\"autoplay\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"autoplay\", \"\");\n  } else {\n    this.removeAttribute(\"autoplay\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"loop\", {\n  get() {\n    return this.hasAttribute(\"loop\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"loop\", \"\");\n  } else {\n    this.removeAttribute(\"loop\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"controls\", {\n  get() {\n    return this.hasAttribute(\"controls\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"controls\", \"\");\n  } else {\n    this.removeAttribute(\"controls\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"volume\", {\n  get() {\n    return this[impl].volume;\n  },\n  set(V) {\n    V = conversions[\"double\"](V);\n    this[impl].volume = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"muted\", {\n  get() {\n    return this[impl].muted;\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    this[impl].muted = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"defaultMuted\", {\n  get() {\n    return this.hasAttribute(\"muted\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"muted\", \"\");\n  } else {\n    this.removeAttribute(\"muted\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"audioTracks\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].audioTracks);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"videoTracks\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].videoTracks);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMediaElement.prototype, \"textTracks\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].textTracks);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMediaElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMediaElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLMediaElement,\n  expose: {\n    Window: { HTMLMediaElement: HTMLMediaElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLMediaElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLMediaElement-impl.js":"\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst notImplemented = require(\"../../browser/not-implemented\");\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\nconst DOMException = require(\"../../web-idl/DOMException\");\n\nfunction getTimeRangeDummy() {\n  return {\n    length: 0,\n    start() {\n      return 0;\n    },\n    end() {\n      return 0;\n    }\n  };\n}\n\nclass HTMLMediaElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._muted = false;\n    this._volume = 1.0;\n    this.readyState = 0;\n    this.networkState = 0;\n    this.currentTime = 0;\n    this.currentSrc = \"\";\n    this.buffered = getTimeRangeDummy();\n    this.seeking = false;\n    this.duration = 0;\n    this.paused = true;\n    this.played = getTimeRangeDummy();\n    this.seekable = getTimeRangeDummy();\n    this.ended = false;\n    this.audioTracks = [];\n    this.videoTracks = [];\n    this.textTracks = [];\n  }\n  // Implemented accoring to W3C Draft 22 August 2012\n  set defaultPlaybackRate(v) {\n    if (v === 0.0) {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR);\n    }\n    if (this._defaultPlaybackRate !== v) {\n      this._defaultPlaybackRate = v;\n      this._dispatchRateChange();\n    }\n  }\n\n  _dispatchRateChange() {\n    const ev = this._ownerDocument.createEvent(\"HTMLEvents\");\n    ev.initEvent(\"ratechange\", false, false);\n    this.dispatchEvent(ev);\n  }\n  get defaultPlaybackRate() {\n    if (this._defaultPlaybackRate === undefined) {\n      return 1.0;\n    }\n    return this._defaultPlaybackRate;\n  }\n  get playbackRate() {\n    if (this._playbackRate === undefined) {\n      return 1.0;\n    }\n    return this._playbackRate;\n  }\n  set playbackRate(v) {\n    if (v !== this._playbackRate) {\n      this._playbackRate = v;\n      this._dispatchRateChange();\n    }\n  }\n  get muted() {\n    return this._muted;\n  }\n  _dispatchVolumeChange() {\n    const ev = this._ownerDocument.createEvent(\"HTMLEvents\");\n    ev.initEvent(\"volumechange\", false, false);\n    this.dispatchEvent(ev);\n  }\n  set muted(v) {\n    if (v !== this._muted) {\n      this._muted = v;\n      this._dispatchVolumeChange();\n    }\n  }\n  get defaultMuted() {\n    return this.getAttribute(\"muted\") !== null;\n  }\n  set defaultMuted(v) {\n    if (v) {\n      this.setAttribute(\"muted\", v);\n    } else {\n      this.removeAttribute(\"muted\");\n    }\n  }\n  get volume() {\n    return this._volume;\n  }\n  set volume(v) {\n    if (v < 0 || v > 1) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n    if (this._volume !== v) {\n      this._volume = v;\n      this._dispatchVolumeChange();\n    }\n  }\n\n    // Not (yet) implemented according to spec\n    // Should return sane default values\n  load() {\n    notImplemented(\"HTMLMediaElement.prototype.load\", this._ownerDocument._defaultView);\n  }\n  canPlayType() {\n    return \"\";\n  }\n  play() {\n    notImplemented(\"HTMLMediaElement.prototype.play\", this._ownerDocument._defaultView);\n  }\n  pause() {\n    notImplemented(\"HTMLMediaElement.prototype.pause\", this._ownerDocument._defaultView);\n  }\n  addTextTrack() {\n    notImplemented(\"HTMLMediaElement.prototype.addNextTrack\", this._ownerDocument._defaultView);\n  }\n\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n\n  set src(value) {\n    this.setAttribute(\"src\", value);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLMediaElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLAudioElement-impl.js":"\"use strict\";\n\nconst HTMLMediaElementImpl = require(\"./HTMLMediaElement-impl\").implementation;\n\nclass HTMLAudioElementImpl extends HTMLMediaElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLAudioElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLBaseElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLBaseElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLBaseElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLBaseElement.prototype.constructor = HTMLBaseElement;\n\n\nHTMLBaseElement.prototype.toString = function () {\n  if (this === HTMLBaseElement.prototype) {\n    return \"[object HTMLBaseElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLBaseElement.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLBaseElement.prototype, \"target\", {\n  get() {\n    const value = this.getAttribute(\"target\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"target\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLBaseElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLBaseElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLBaseElement,\n  expose: {\n    Window: { HTMLBaseElement: HTMLBaseElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLBaseElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLBaseElement-impl.js":"\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst whatwgURL = require(\"whatwg-url\");\nconst fallbackBaseURL = require(\"../helpers/document-base-url\").fallbackBaseURL;\n\nclass HTMLBaseElement extends HTMLElementImpl {\n  get href() {\n    const document = this._ownerDocument;\n\n    const url = this.hasAttribute(\"href\") ? this.getAttribute(\"href\") : \"\";\n    const parsed = whatwgURL.parseURL(url, { baseURL: fallbackBaseURL(document) });\n\n    if (parsed === \"failure\") {\n      return url;\n    }\n\n    return whatwgURL.serializeURL(parsed);\n  }\n\n  set href(value) {\n    this.setAttribute(\"href\", value);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLBaseElement\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLBodyElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst WindowEventHandlers = require(\"./WindowEventHandlers.js\");\n\nfunction HTMLBodyElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLBodyElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLBodyElement.prototype.constructor = HTMLBodyElement;\n\nmixin(HTMLBodyElement.prototype, WindowEventHandlers.interface.prototype);\nWindowEventHandlers.mixedInto.push(HTMLBodyElement);\n\nHTMLBodyElement.prototype.toString = function () {\n  if (this === HTMLBodyElement.prototype) {\n    return \"[object HTMLBodyElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLBodyElement.prototype, \"text\", {\n  get() {\n    const value = this.getAttribute(\"text\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"text\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLBodyElement.prototype, \"link\", {\n  get() {\n    const value = this.getAttribute(\"link\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"link\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLBodyElement.prototype, \"vLink\", {\n  get() {\n    const value = this.getAttribute(\"vLink\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"vLink\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLBodyElement.prototype, \"aLink\", {\n  get() {\n    const value = this.getAttribute(\"aLink\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"aLink\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLBodyElement.prototype, \"bgColor\", {\n  get() {\n    const value = this.getAttribute(\"bgColor\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"bgColor\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLBodyElement.prototype, \"background\", {\n  get() {\n    const value = this.getAttribute(\"background\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"background\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLBodyElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLBodyElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLBodyElement,\n  expose: {\n    Window: { HTMLBodyElement: HTMLBodyElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLBodyElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/WindowEventHandlers.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction WindowEventHandlers() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nWindowEventHandlers.prototype.toString = function () {\n  if (this === WindowEventHandlers.prototype) {\n    return \"[object WindowEventHandlersPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(WindowEventHandlers.prototype, \"onafterprint\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onafterprint);\n  },\n  set(V) {\n    this[impl].onafterprint = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onbeforeprint\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onbeforeprint);\n  },\n  set(V) {\n    this[impl].onbeforeprint = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onbeforeunload\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onbeforeunload);\n  },\n  set(V) {\n    this[impl].onbeforeunload = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onhashchange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onhashchange);\n  },\n  set(V) {\n    this[impl].onhashchange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onlanguagechange\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onlanguagechange);\n  },\n  set(V) {\n    this[impl].onlanguagechange = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onmessage\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onmessage);\n  },\n  set(V) {\n    this[impl].onmessage = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onoffline\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onoffline);\n  },\n  set(V) {\n    this[impl].onoffline = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"ononline\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ononline);\n  },\n  set(V) {\n    this[impl].ononline = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onpagehide\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onpagehide);\n  },\n  set(V) {\n    this[impl].onpagehide = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onpageshow\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onpageshow);\n  },\n  set(V) {\n    this[impl].onpageshow = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onpopstate\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onpopstate);\n  },\n  set(V) {\n    this[impl].onpopstate = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onrejectionhandled\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onrejectionhandled);\n  },\n  set(V) {\n    this[impl].onrejectionhandled = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onstorage\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onstorage);\n  },\n  set(V) {\n    this[impl].onstorage = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onunhandledrejection\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onunhandledrejection);\n  },\n  set(V) {\n    this[impl].onunhandledrejection = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(WindowEventHandlers.prototype, \"onunload\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].onunload);\n  },\n  set(V) {\n    this[impl].onunload = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(WindowEventHandlers.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(WindowEventHandlers.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: WindowEventHandlers,\n  expose: {\n    Window: { WindowEventHandlers: WindowEventHandlers }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/WindowEventHandlers-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/WindowEventHandlers-impl.js":"\"use strict\";\n\nclass WindowEventHandlersImpl {\n\n}\n\nmodule.exports = {\n  implementation: WindowEventHandlersImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLBodyElement-impl.js":"\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst proxiedWindowEventHandlers = require(\"../helpers/proxied-window-event-handlers\");\n\nclass HTMLBodyElementImpl extends HTMLElementImpl {}\n\nfor (const name of proxiedWindowEventHandlers) {\n  Object.defineProperty(HTMLBodyElementImpl.prototype, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const window = this._ownerDocument._defaultView;\n      return window ? window[name] : null;\n    },\n    set(handler) {\n      const window = this._ownerDocument._defaultView;\n      if (window) {\n        window[name] = handler;\n      }\n    }\n  });\n}\n\nmodule.exports = {\n  implementation: HTMLBodyElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLBRElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLBRElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLBRElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLBRElement.prototype.constructor = HTMLBRElement;\n\n\nHTMLBRElement.prototype.toString = function () {\n  if (this === HTMLBRElement.prototype) {\n    return \"[object HTMLBRElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLBRElement.prototype, \"clear\", {\n  get() {\n    const value = this.getAttribute(\"clear\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"clear\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLBRElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLBRElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLBRElement,\n  expose: {\n    Window: { HTMLBRElement: HTMLBRElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLBRElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLBRElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLBRElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLBRElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLButtonElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLButtonElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLButtonElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLButtonElement.prototype.constructor = HTMLButtonElement;\n\n\nHTMLButtonElement.prototype.toString = function () {\n  if (this === HTMLButtonElement.prototype) {\n    return \"[object HTMLButtonElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLButtonElement.prototype, \"autofocus\", {\n  get() {\n    return this.hasAttribute(\"autofocus\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"autofocus\", \"\");\n  } else {\n    this.removeAttribute(\"autofocus\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLButtonElement.prototype, \"disabled\", {\n  get() {\n    return this.hasAttribute(\"disabled\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"disabled\", \"\");\n  } else {\n    this.removeAttribute(\"disabled\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLButtonElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLButtonElement.prototype, \"formNoValidate\", {\n  get() {\n    return this.hasAttribute(\"formNoValidate\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"formNoValidate\", \"\");\n  } else {\n    this.removeAttribute(\"formNoValidate\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLButtonElement.prototype, \"formTarget\", {\n  get() {\n    const value = this.getAttribute(\"formTarget\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"formTarget\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLButtonElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLButtonElement.prototype, \"type\", {\n  get() {\n    return this[impl].type;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].type = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLButtonElement.prototype, \"value\", {\n  get() {\n    const value = this.getAttribute(\"value\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"value\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLButtonElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLButtonElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLButtonElement,\n  expose: {\n    Window: { HTMLButtonElement: HTMLButtonElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLButtonElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLButtonElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nconst closest = require(\"../helpers/traversal\").closest;\nconst isDisabled = require(\"../helpers/form-controls\").isDisabled;\n\nclass HTMLButtonElementImpl extends HTMLElementImpl {\n  _activationBehavior() {\n    const form = this.form;\n    if (form) {\n      if (this.type === \"submit\" && !isDisabled(this)) {\n        form._dispatchSubmitEvent();\n      }\n    }\n  }\n\n  _getValue() {\n    const valueAttr = this.getAttribute(\"value\");\n    return valueAttr === null ? \"\" : valueAttr;\n  }\n\n  get form() {\n    return closest(this, \"form\");\n  }\n\n  get type() {\n    const typeAttr = (this.getAttribute(\"type\") || \"\").toLowerCase();\n    switch (typeAttr) {\n      case \"submit\":\n      case \"reset\":\n      case \"button\":\n      case \"menu\":\n        return typeAttr;\n      default:\n        return \"submit\";\n    }\n  }\n\n  set type(v) {\n    v = String(v).toLowerCase();\n    switch (v) {\n      case \"submit\":\n      case \"reset\":\n      case \"button\":\n      case \"menu\":\n        this.setAttribute(\"type\", v);\n        break;\n      default:\n        this.setAttribute(\"type\", \"submit\");\n        break;\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLButtonElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLCanvasElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLCanvasElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLCanvasElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLCanvasElement.prototype.constructor = HTMLCanvasElement;\n\n\nHTMLCanvasElement.prototype.getContext = function getContext(contextId) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getContext' on 'HTMLCanvasElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"any\"](args[1]);\n  }\n  return utils.tryWrapperForImpl(this[impl].getContext.apply(this[impl], args));\n};\n\nHTMLCanvasElement.prototype.probablySupportsContext = function probablySupportsContext(contextId) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'probablySupportsContext' on 'HTMLCanvasElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"any\"](args[1]);\n  }\n  return this[impl].probablySupportsContext.apply(this[impl], args);\n};\n\nHTMLCanvasElement.prototype.setContext = function setContext(context) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'setContext' on 'HTMLCanvasElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].setContext.apply(this[impl], args);\n};\n\nHTMLCanvasElement.prototype.toDataURL = function toDataURL() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"DOMString\"](args[0]);\n  }\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"any\"](args[1]);\n  }\n  return this[impl].toDataURL.apply(this[impl], args);\n};\n\nHTMLCanvasElement.prototype.toBlob = function toBlob(callback) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'toBlob' on 'HTMLCanvasElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"DOMString\"](args[1]);\n  }\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"any\"](args[2]);\n  }\n  return this[impl].toBlob.apply(this[impl], args);\n};\n\nHTMLCanvasElement.prototype.toString = function () {\n  if (this === HTMLCanvasElement.prototype) {\n    return \"[object HTMLCanvasElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLCanvasElement.prototype, \"width\", {\n  get() {\n    return this[impl].width;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].width = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLCanvasElement.prototype, \"height\", {\n  get() {\n    return this[impl].height;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].height = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLCanvasElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLCanvasElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLCanvasElement,\n  expose: {\n    Window: { HTMLCanvasElement: HTMLCanvasElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLCanvasElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js":"\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst notImplemented = require(\"../../browser/not-implemented\");\nconst idlUtils = require(\"../generated/utils\");\nconst Canvas = require(\"../../utils\").Canvas;\n\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\n  _attrModified(name, value) {\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\n      this._canvas[name] = parseInt(value);\n    }\n\n    return super._attrModified.apply(this, arguments);\n  }\n\n  _getCanvas() {\n    if (Canvas && !this._canvas) {\n      this._canvas = new Canvas(this.width, this.height);\n    }\n    return this._canvas;\n  }\n\n  getContext(contextId) {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      if (!this._context) {\n        this._context = canvas.getContext(contextId) || null;\n        if (this._context) {\n          // Override the native canvas reference with our wrapper. This is the\n          // reason why we need to locally cache _context, since each call to\n          // canvas.getContext(contextId) would replace this reference again.\n          // Perhaps in the longer term, a better solution would be to create a\n          // full wrapper for the Context object as well.\n          this._context.canvas = idlUtils.wrapperForImpl(this);\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\n        }\n      }\n      return this._context;\n    }\n\n    notImplemented(\"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\",\n      this._ownerDocument._defaultView);\n    return null;\n  }\n\n  probablySupportsContext(contextId) {\n    const canvas = this._getCanvas();\n    return canvas ? contextId === \"2d\" : false;\n  }\n\n  setContext() {\n    notImplemented(\"HTMLCanvasElement.prototype.setContext\");\n  }\n\n  toDataURL() {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      return canvas.toDataURL.apply(this._canvas, arguments);\n    }\n\n    notImplemented(\"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\",\n      this._ownerDocument._defaultView);\n    return null;\n  }\n\n  toBlob(callback, type, qualityArgument) {\n    const window = this._ownerDocument._defaultView;\n    const canvas = this._getCanvas();\n    if (canvas) {\n      let stream;\n      switch (type) {\n        case \"image/jpg\":\n        case \"image/jpeg\":\n          stream = canvas.createJPEGStream({\n            quality: Math.min(0, Math.max(1, qualityArgument)) * 100\n          });\n          break;\n        default:\n          // TODO: Patch node-canvas to receive qualityArgument for PNG stream\n          type = \"image/png\";\n          stream = canvas.createPNGStream();\n      }\n      const buffers = [];\n      stream.on(\"data\", chunk => {\n        buffers.push(chunk);\n      });\n      stream.on(\"end\", () => {\n        callback(new window.Blob(buffers, { type }));\n      });\n    } else {\n      notImplemented(\"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\",\n        window);\n    }\n  }\n\n  get width() {\n    const parsed = parseInt(this.getAttribute(\"width\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n  }\n\n  set width(v) {\n    v = v > 2147483647 ? 300 : v;\n    this.setAttribute(\"width\", String(v));\n  }\n\n  get height() {\n    const parsed = parseInt(this.getAttribute(\"height\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n  }\n\n  set height(v) {\n    v = v > 2147483647 ? 150 : v;\n    this.setAttribute(\"height\", String(v));\n  }\n}\n\n// We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\nfunction wrapNodeCanvasMethod(ctx, name) {\n  const prev = ctx[name];\n  ctx[name] = function (image) {\n    const impl = idlUtils.implForWrapper(image);\n    if (impl) {\n      arguments[0] = impl._image || impl._canvas;\n    }\n    return prev.apply(ctx, arguments);\n  };\n}\n\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLDataElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLDataElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLDataElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLDataElement.prototype.constructor = HTMLDataElement;\n\n\nHTMLDataElement.prototype.toString = function () {\n  if (this === HTMLDataElement.prototype) {\n    return \"[object HTMLDataElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLDataElement.prototype, \"value\", {\n  get() {\n    const value = this.getAttribute(\"value\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"value\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDataElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDataElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLDataElement,\n  expose: {\n    Window: { HTMLDataElement: HTMLDataElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLDataElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLDataElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLDataElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLDataElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLDataListElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLDataListElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLDataListElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLDataListElement.prototype.constructor = HTMLDataListElement;\n\n\nHTMLDataListElement.prototype.toString = function () {\n  if (this === HTMLDataListElement.prototype) {\n    return \"[object HTMLDataListElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDataListElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDataListElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLDataListElement,\n  expose: {\n    Window: { HTMLDataListElement: HTMLDataListElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLDataListElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLDataListElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLDataListElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLDataListElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLDialogElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLDialogElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLDialogElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLDialogElement.prototype.constructor = HTMLDialogElement;\n\n\nHTMLDialogElement.prototype.toString = function () {\n  if (this === HTMLDialogElement.prototype) {\n    return \"[object HTMLDialogElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLDialogElement.prototype, \"open\", {\n  get() {\n    return this.hasAttribute(\"open\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"open\", \"\");\n  } else {\n    this.removeAttribute(\"open\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDialogElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDialogElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLDialogElement,\n  expose: {\n    Window: { HTMLDialogElement: HTMLDialogElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLDialogElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLDialogElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLDialogElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLDialogElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLDirectoryElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLDirectoryElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLDirectoryElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLDirectoryElement.prototype.constructor = HTMLDirectoryElement;\n\n\nHTMLDirectoryElement.prototype.toString = function () {\n  if (this === HTMLDirectoryElement.prototype) {\n    return \"[object HTMLDirectoryElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLDirectoryElement.prototype, \"compact\", {\n  get() {\n    return this.hasAttribute(\"compact\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"compact\", \"\");\n  } else {\n    this.removeAttribute(\"compact\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDirectoryElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDirectoryElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLDirectoryElement,\n  expose: {\n    Window: { HTMLDirectoryElement: HTMLDirectoryElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLDirectoryElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLDirectoryElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLDirectoryElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLDirectoryElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLDivElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLDivElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLDivElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLDivElement.prototype.constructor = HTMLDivElement;\n\n\nHTMLDivElement.prototype.toString = function () {\n  if (this === HTMLDivElement.prototype) {\n    return \"[object HTMLDivElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLDivElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDivElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDivElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLDivElement,\n  expose: {\n    Window: { HTMLDivElement: HTMLDivElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLDivElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLDivElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLDivElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLDivElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLDListElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLDListElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLDListElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLDListElement.prototype.constructor = HTMLDListElement;\n\n\nHTMLDListElement.prototype.toString = function () {\n  if (this === HTMLDListElement.prototype) {\n    return \"[object HTMLDListElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLDListElement.prototype, \"compact\", {\n  get() {\n    return this.hasAttribute(\"compact\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"compact\", \"\");\n  } else {\n    this.removeAttribute(\"compact\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDListElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLDListElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLDListElement,\n  expose: {\n    Window: { HTMLDListElement: HTMLDListElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLDListElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLDListElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLDListElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLDListElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLEmbedElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLEmbedElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLEmbedElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLEmbedElement.prototype.constructor = HTMLEmbedElement;\n\n\nHTMLEmbedElement.prototype.toString = function () {\n  if (this === HTMLEmbedElement.prototype) {\n    return \"[object HTMLEmbedElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLEmbedElement.prototype, \"src\", {\n  get() {\n    return this[impl].src;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].src = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLEmbedElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLEmbedElement.prototype, \"width\", {\n  get() {\n    const value = this.getAttribute(\"width\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"width\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLEmbedElement.prototype, \"height\", {\n  get() {\n    const value = this.getAttribute(\"height\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"height\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLEmbedElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLEmbedElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLEmbedElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLEmbedElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLEmbedElement,\n  expose: {\n    Window: { HTMLEmbedElement: HTMLEmbedElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLEmbedElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLEmbedElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\n\nclass HTMLEmbedElementImpl extends HTMLElementImpl {\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n\n  set src(value) {\n    this.setAttribute(\"src\", value);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLEmbedElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLFieldSetElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLFieldSetElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLFieldSetElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLFieldSetElement.prototype.constructor = HTMLFieldSetElement;\n\n\nHTMLFieldSetElement.prototype.toString = function () {\n  if (this === HTMLFieldSetElement.prototype) {\n    return \"[object HTMLFieldSetElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLFieldSetElement.prototype, \"disabled\", {\n  get() {\n    return this.hasAttribute(\"disabled\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"disabled\", \"\");\n  } else {\n    this.removeAttribute(\"disabled\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFieldSetElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFieldSetElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFieldSetElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFieldSetElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLFieldSetElement,\n  expose: {\n    Window: { HTMLFieldSetElement: HTMLFieldSetElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLFieldSetElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLFieldSetElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst closest = require(\"../helpers/traversal\").closest;\n\nclass HTMLFieldSetElementImpl extends HTMLElementImpl {\n  get form() {\n    return closest(this, \"form\");\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLFieldSetElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLFontElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLFontElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLFontElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLFontElement.prototype.constructor = HTMLFontElement;\n\n\nHTMLFontElement.prototype.toString = function () {\n  if (this === HTMLFontElement.prototype) {\n    return \"[object HTMLFontElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLFontElement.prototype, \"color\", {\n  get() {\n    const value = this.getAttribute(\"color\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"color\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFontElement.prototype, \"face\", {\n  get() {\n    const value = this.getAttribute(\"face\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"face\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFontElement.prototype, \"size\", {\n  get() {\n    const value = this.getAttribute(\"size\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"size\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFontElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFontElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLFontElement,\n  expose: {\n    Window: { HTMLFontElement: HTMLFontElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLFontElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLFontElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLFontElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLFontElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLFrameElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLFrameElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLFrameElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLFrameElement.prototype.constructor = HTMLFrameElement;\n\n\nHTMLFrameElement.prototype.toString = function () {\n  if (this === HTMLFrameElement.prototype) {\n    return \"[object HTMLFrameElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLFrameElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"scrolling\", {\n  get() {\n    const value = this.getAttribute(\"scrolling\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"scrolling\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"src\", {\n  get() {\n    return this[impl].src;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].src = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"frameBorder\", {\n  get() {\n    const value = this.getAttribute(\"frameBorder\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"frameBorder\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"longDesc\", {\n  get() {\n    return this[impl].longDesc;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].longDesc = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"noResize\", {\n  get() {\n    return this.hasAttribute(\"noResize\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"noResize\", \"\");\n  } else {\n    this.removeAttribute(\"noResize\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"contentDocument\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].contentDocument);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"contentWindow\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].contentWindow);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"marginHeight\", {\n  get() {\n    const value = this.getAttribute(\"marginHeight\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"marginHeight\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameElement.prototype, \"marginWidth\", {\n  get() {\n    const value = this.getAttribute(\"marginWidth\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"marginWidth\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFrameElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFrameElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLFrameElement,\n  expose: {\n    Window: { HTMLFrameElement: HTMLFrameElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLFrameElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLFrameElement-impl.js":"\"use strict\";\n\nconst parseContentType = require(\"content-type-parser\");\nconst URL = require(\"whatwg-url\").URL;\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst applyDocumentFeatures = require(\"../../browser/documentfeatures\").applyDocumentFeatures;\nconst resourceLoader = require(\"../../browser/resource-loader\");\nconst defineGetter = require(\"../../utils\").defineGetter;\nconst documentBaseURLSerialized = require(\"../helpers/document-base-url\").documentBaseURLSerialized;\nconst getAttributeValue = require(\"../attributes\").getAttributeValue;\nconst idlUtils = require(\"../generated/utils\");\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\n\nfunction loadFrame(frame) {\n  if (frame._contentDocument) {\n    if (frame._contentDocument._defaultView) {\n      // close calls delete on its document.\n      frame._contentDocument._defaultView.close();\n    } else {\n      delete frame._contentDocument;\n    }\n  }\n\n  const parentDoc = frame._ownerDocument;\n\n  // https://html.spec.whatwg.org/#process-the-iframe-attributes\n  let url;\n  const srcAttribute = getAttributeValue(frame, \"src\");\n  if (srcAttribute === null || srcAttribute === \"\") {\n    url = new URL(\"about:blank\");\n  } else {\n    try {\n      url = new URL(srcAttribute, documentBaseURLSerialized(parentDoc));\n    } catch (e) {\n      url = new URL(\"about:blank\");\n    }\n  }\n\n  // This is not great, but prevents a require cycle during webidl2js generation\n  const wnd = new parentDoc._defaultView.constructor({\n    parsingMode: \"html\",\n    url: url.protocol === \"javascript:\" || url.href === \"about:blank\" ? parentDoc.URL : url.href,\n    resourceLoader: parentDoc._customResourceLoader,\n    userAgent: parentDoc._defaultView.navigator.userAgent,\n    referrer: parentDoc.URL,\n    cookieJar: parentDoc._cookieJar,\n    pool: parentDoc._pool,\n    encoding: parentDoc._encoding,\n    agentOptions: parentDoc._agentOptions,\n    strictSSL: parentDoc._strictSSL,\n    proxy: parentDoc._proxy\n  });\n  const contentDoc = frame._contentDocument = idlUtils.implForWrapper(wnd._document);\n  applyDocumentFeatures(contentDoc, parentDoc._implementation._features);\n\n  const parent = parentDoc._defaultView;\n  const contentWindow = contentDoc._defaultView;\n  contentWindow._parent = parent;\n  contentWindow._top = parent.top;\n  contentWindow._frameElement = frame;\n  contentWindow._virtualConsole = parent._virtualConsole;\n\n  // Handle about:blank with a simulated load of an empty document.\n  if (url.href === \"about:blank\") {\n    // Cannot be done inside the enqueued callback; the documentElement etc. need to be immediately available.\n    contentDoc.write(\"<html><head></head><body></body></html>\");\n    contentDoc.close();\n    resourceLoader.enqueue(frame)(); // to fire the load event\n  } else if (url.protocol === \"javascript:\") {\n    // Cannot be done inside the enqueued callback; the documentElement etc. need to be immediately available.\n    contentDoc.write(\"<html><head></head><body></body></html>\");\n    contentDoc.close();\n    contentWindow.eval(url.pathname);\n    resourceLoader.enqueue(frame)(); // to fire the load event\n  } else {\n    resourceLoader.load(\n      frame,\n      url.href,\n      { defaultEncoding: parentDoc._encoding, detectMetaCharset: true },\n      (html, responseURL, response) => {\n        if (response) {\n          const contentType = parseContentType(response.headers[\"content-type\"]);\n          if (contentType) {\n            if (contentType.isXML()) {\n              contentDoc._parsingMode = \"xml\";\n            }\n            contentDoc._encoding = contentType.get(\"charset\");\n          }\n        }\n        contentDoc.write(html);\n        contentDoc.close();\n      }\n    );\n  }\n}\n\nfunction refreshAccessors(document) {\n  const window = document._defaultView;\n\n  if (!window) {\n    return;\n  }\n\n  const frames = document.querySelectorAll(\"iframe,frame\");\n\n  // delete accessors for all frames\n  for (let i = 0; i < window._length; ++i) {\n    delete window[i];\n  }\n\n  window._length = frames.length;\n  Array.prototype.forEach.call(frames, (frame, i) => {\n    defineGetter(window, i, () => frame.contentWindow);\n  });\n}\n\nclass HTMLFrameElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n    this._contentDocument = null;\n  }\n  _attrModified(name, value, oldVal) {\n    super._attrModified(name, value, oldVal);\n    if (name === \"src\") {\n      // iframe should never load in a document without a Window\n      // (e.g. implementation.createHTMLDocument)\n      if (this._attached && this._ownerDocument._defaultView) {\n        loadFrame(this);\n      }\n    }\n  }\n\n  _detach() {\n    super._detach();\n\n    if (this.contentWindow) {\n      this.contentWindow.close();\n    }\n\n    refreshAccessors(this._ownerDocument);\n  }\n\n  _attach() {\n    super._attach();\n\n    if (this._ownerDocument._defaultView) {\n      loadFrame(this);\n    }\n    refreshAccessors(this._ownerDocument);\n  }\n\n  get contentDocument() {\n    return this._contentDocument;\n  }\n\n  get contentWindow() {\n    return this.contentDocument ? this.contentDocument._defaultView : null;\n  }\n\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n\n  set src(value) {\n    this.setAttribute(\"src\", value);\n  }\n\n  get longDesc() {\n    return reflectURLAttribute(this, \"longdesc\");\n  }\n\n  set longDesc(value) {\n    this.setAttribute(\"longdesc\", value);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLFrameElementImpl\n};\n\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLFrameSetElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst WindowEventHandlers = require(\"./WindowEventHandlers.js\");\n\nfunction HTMLFrameSetElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLFrameSetElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLFrameSetElement.prototype.constructor = HTMLFrameSetElement;\n\nmixin(HTMLFrameSetElement.prototype, WindowEventHandlers.interface.prototype);\nWindowEventHandlers.mixedInto.push(HTMLFrameSetElement);\n\nHTMLFrameSetElement.prototype.toString = function () {\n  if (this === HTMLFrameSetElement.prototype) {\n    return \"[object HTMLFrameSetElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLFrameSetElement.prototype, \"cols\", {\n  get() {\n    const value = this.getAttribute(\"cols\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"cols\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLFrameSetElement.prototype, \"rows\", {\n  get() {\n    const value = this.getAttribute(\"rows\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"rows\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFrameSetElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLFrameSetElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLFrameSetElement,\n  expose: {\n    Window: { HTMLFrameSetElement: HTMLFrameSetElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLFrameSetElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLFrameSetElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLFramesetElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLFramesetElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLHeadingElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLHeadingElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLHeadingElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLHeadingElement.prototype.constructor = HTMLHeadingElement;\n\n\nHTMLHeadingElement.prototype.toString = function () {\n  if (this === HTMLHeadingElement.prototype) {\n    return \"[object HTMLHeadingElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLHeadingElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHeadingElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHeadingElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLHeadingElement,\n  expose: {\n    Window: { HTMLHeadingElement: HTMLHeadingElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLHeadingElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLHeadingElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLHeadingElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLHeadingElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLHeadElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLHeadElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLHeadElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLHeadElement.prototype.constructor = HTMLHeadElement;\n\n\nHTMLHeadElement.prototype.toString = function () {\n  if (this === HTMLHeadElement.prototype) {\n    return \"[object HTMLHeadElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHeadElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHeadElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLHeadElement,\n  expose: {\n    Window: { HTMLHeadElement: HTMLHeadElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLHeadElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLHeadElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLHeadElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLHeadElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLHRElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLHRElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLHRElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLHRElement.prototype.constructor = HTMLHRElement;\n\n\nHTMLHRElement.prototype.toString = function () {\n  if (this === HTMLHRElement.prototype) {\n    return \"[object HTMLHRElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLHRElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHRElement.prototype, \"color\", {\n  get() {\n    const value = this.getAttribute(\"color\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"color\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHRElement.prototype, \"noShade\", {\n  get() {\n    return this.hasAttribute(\"noShade\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"noShade\", \"\");\n  } else {\n    this.removeAttribute(\"noShade\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHRElement.prototype, \"size\", {\n  get() {\n    const value = this.getAttribute(\"size\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"size\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLHRElement.prototype, \"width\", {\n  get() {\n    const value = this.getAttribute(\"width\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"width\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHRElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHRElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLHRElement,\n  expose: {\n    Window: { HTMLHRElement: HTMLHRElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLHRElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLHRElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLHRElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLHRElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLHtmlElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLHtmlElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLHtmlElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLHtmlElement.prototype.constructor = HTMLHtmlElement;\n\n\nHTMLHtmlElement.prototype.toString = function () {\n  if (this === HTMLHtmlElement.prototype) {\n    return \"[object HTMLHtmlElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLHtmlElement.prototype, \"version\", {\n  get() {\n    const value = this.getAttribute(\"version\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"version\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHtmlElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLHtmlElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLHtmlElement,\n  expose: {\n    Window: { HTMLHtmlElement: HTMLHtmlElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLHtmlElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLHtmlElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLHtmlElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLHtmlElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLIFrameElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLIFrameElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLIFrameElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLIFrameElement.prototype.constructor = HTMLIFrameElement;\n\n\nHTMLIFrameElement.prototype.getSVGDocument = function getSVGDocument() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].getSVGDocument.apply(this[impl], args));\n};\n\nHTMLIFrameElement.prototype.toString = function () {\n  if (this === HTMLIFrameElement.prototype) {\n    return \"[object HTMLIFrameElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLIFrameElement.prototype, \"src\", {\n  get() {\n    return this[impl].src;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].src = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"srcdoc\", {\n  get() {\n    const value = this.getAttribute(\"srcdoc\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"srcdoc\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"seamless\", {\n  get() {\n    return this[impl].seamless;\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    this[impl].seamless = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"allowFullscreen\", {\n  get() {\n    return this.hasAttribute(\"allowFullscreen\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"allowFullscreen\", \"\");\n  } else {\n    this.removeAttribute(\"allowFullscreen\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"width\", {\n  get() {\n    const value = this.getAttribute(\"width\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"width\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"height\", {\n  get() {\n    const value = this.getAttribute(\"height\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"height\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"contentDocument\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].contentDocument);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"contentWindow\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].contentWindow);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"scrolling\", {\n  get() {\n    const value = this.getAttribute(\"scrolling\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"scrolling\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"frameBorder\", {\n  get() {\n    const value = this.getAttribute(\"frameBorder\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"frameBorder\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"longDesc\", {\n  get() {\n    return this[impl].longDesc;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].longDesc = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"marginHeight\", {\n  get() {\n    const value = this.getAttribute(\"marginHeight\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"marginHeight\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLIFrameElement.prototype, \"marginWidth\", {\n  get() {\n    const value = this.getAttribute(\"marginWidth\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"marginWidth\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLIFrameElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLIFrameElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLIFrameElement,\n  expose: {\n    Window: { HTMLIFrameElement: HTMLIFrameElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLIFrameElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLIFrameElement-impl.js":"\"use strict\";\n\nconst HTMLFrameElementImpl = require(\"./HTMLFrameElement-impl\").implementation;\n\nclass HTMLIFrameElementImpl extends HTMLFrameElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLIFrameElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLImageElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLImageElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLImageElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLImageElement.prototype.constructor = HTMLImageElement;\n\n\nHTMLImageElement.prototype.toString = function () {\n  if (this === HTMLImageElement.prototype) {\n    return \"[object HTMLImageElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLImageElement.prototype, \"alt\", {\n  get() {\n    const value = this.getAttribute(\"alt\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"alt\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"src\", {\n  get() {\n    return this[impl].src;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].src = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"srcset\", {\n  get() {\n    const value = this.getAttribute(\"srcset\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"srcset\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"sizes\", {\n  get() {\n    const value = this.getAttribute(\"sizes\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"sizes\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"crossOrigin\", {\n  get() {\n    const value = this.getAttribute(\"crossOrigin\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this.setAttribute(\"crossOrigin\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"useMap\", {\n  get() {\n    const value = this.getAttribute(\"useMap\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"useMap\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"isMap\", {\n  get() {\n    return this.hasAttribute(\"isMap\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"isMap\", \"\");\n  } else {\n    this.removeAttribute(\"isMap\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"width\", {\n  get() {\n    return this[impl].width;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].width = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"height\", {\n  get() {\n    return this[impl].height;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].height = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"naturalWidth\", {\n  get() {\n    return this[impl].naturalWidth;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"naturalHeight\", {\n  get() {\n    return this[impl].naturalHeight;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"complete\", {\n  get() {\n    return this[impl].complete;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"currentSrc\", {\n  get() {\n    return this[impl].currentSrc;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"lowsrc\", {\n  get() {\n    const value = this.getAttribute(\"lowsrc\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"lowsrc\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"hspace\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"hspace\"));\n    return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this.setAttribute(\"hspace\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"vspace\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"vspace\"));\n    return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this.setAttribute(\"vspace\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"longDesc\", {\n  get() {\n    const value = this.getAttribute(\"longDesc\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"longDesc\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLImageElement.prototype, \"border\", {\n  get() {\n    const value = this.getAttribute(\"border\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"border\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLImageElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLImageElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLImageElement,\n  expose: {\n    Window: { HTMLImageElement: HTMLImageElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLImageElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLImageElement-impl.js":"\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst resourceLoader = require(\"../../browser/resource-loader\");\nconst conversions = require(\"webidl-conversions\");\nconst Canvas = require(\"../../utils\").Canvas;\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\n\nclass HTMLImageElementImpl extends HTMLElementImpl {\n  _attrModified(name, value, oldVal) {\n    if (name === \"src\" && value !== oldVal) {\n      const document = this._ownerDocument;\n      if (Canvas && document.implementation._hasFeature(\"FetchExternalResources\", \"img\")) {\n        let error;\n        if (!this._image) {\n          this._image = new Canvas.Image();\n          // Install an error handler that just remembers the error. It is then\n          // thrown in the callback of resourceLoader.load() below.\n          this._image.onerror = function (err) {\n            error = err;\n          };\n        }\n        this._currentSrc = null;\n        resourceLoader.load(this, this.src, {}, (data, url, response) => {\n          if (response && response.statusCode !== undefined && response.statusCode !== 200) {\n            throw new Error(\"Status code: \" + response.statusCode);\n          }\n          error = null;\n          this._image.source = data;\n          if (error) {\n            throw new Error(error);\n          }\n          this._currentSrc = value;\n        });\n      } else {\n        resourceLoader.enqueue(this)();\n      }\n    }\n\n    super._attrModified(name, value, oldVal);\n  }\n\n  get _accept() {\n    return \"image/png,image/*;q=0.8,*/*;q=0.5\";\n  }\n\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n\n  set src(value) {\n    this.setAttribute(\"src\", value);\n  }\n\n  get height() {\n    // Just like on browsers, if no width / height is defined, we fall back on the\n    // dimensions of the internal image data.\n    return this.hasAttribute(\"height\") ?\n      conversions[\"unsigned long\"](this.getAttribute(\"height\")) : this.naturalHeight;\n  }\n\n  set height(V) {\n    this.setAttribute(\"height\", String(V));\n  }\n\n  get width() {\n    return this.hasAttribute(\"width\") ?\n      conversions[\"unsigned long\"](this.getAttribute(\"width\")) : this.naturalWidth;\n  }\n\n  set width(V) {\n    this.setAttribute(\"width\", String(V));\n  }\n\n  get naturalHeight() {\n    return this._image ? this._image.height : 0;\n  }\n\n  get naturalWidth() {\n    return this._image ? this._image.width : 0;\n  }\n\n  get complete() {\n    return Boolean(this._image && this._image.complete);\n  }\n\n  get currentSrc() {\n    return this._currentSrc || \"\";\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLImageElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLInputElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLInputElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLInputElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLInputElement.prototype.constructor = HTMLInputElement;\n\n\nHTMLInputElement.prototype.select = function select() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].select.apply(this[impl], args);\n};\n\nHTMLInputElement.prototype.setRangeText = function setRangeText(replacement) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'setRangeText' on 'HTMLInputElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 4; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].setRangeText.apply(this[impl], args);\n};\n\nHTMLInputElement.prototype.setSelectionRange = function setSelectionRange(start, end) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'setSelectionRange' on 'HTMLInputElement': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"unsigned long\"](args[0]);\n  args[1] = conversions[\"unsigned long\"](args[1]);\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"DOMString\"](args[2]);\n  }\n  return this[impl].setSelectionRange.apply(this[impl], args);\n};\n\nHTMLInputElement.prototype.toString = function () {\n  if (this === HTMLInputElement.prototype) {\n    return \"[object HTMLInputElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLInputElement.prototype, \"accept\", {\n  get() {\n    const value = this.getAttribute(\"accept\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"accept\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"alt\", {\n  get() {\n    const value = this.getAttribute(\"alt\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"alt\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"autocomplete\", {\n  get() {\n    const value = this.getAttribute(\"autocomplete\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"autocomplete\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"autofocus\", {\n  get() {\n    return this.hasAttribute(\"autofocus\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"autofocus\", \"\");\n  } else {\n    this.removeAttribute(\"autofocus\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"defaultChecked\", {\n  get() {\n    return this.hasAttribute(\"checked\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"checked\", \"\");\n  } else {\n    this.removeAttribute(\"checked\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"checked\", {\n  get() {\n    return this[impl].checked;\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    this[impl].checked = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"dirName\", {\n  get() {\n    const value = this.getAttribute(\"dirName\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"dirName\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"disabled\", {\n  get() {\n    return this.hasAttribute(\"disabled\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"disabled\", \"\");\n  } else {\n    this.removeAttribute(\"disabled\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"files\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].files);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"formNoValidate\", {\n  get() {\n    return this.hasAttribute(\"formNoValidate\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"formNoValidate\", \"\");\n  } else {\n    this.removeAttribute(\"formNoValidate\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"formTarget\", {\n  get() {\n    const value = this.getAttribute(\"formTarget\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"formTarget\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"inputMode\", {\n  get() {\n    const value = this.getAttribute(\"inputMode\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"inputMode\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"max\", {\n  get() {\n    const value = this.getAttribute(\"max\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"max\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"maxLength\", {\n  get() {\n    return this[impl].maxLength;\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this[impl].maxLength = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"min\", {\n  get() {\n    const value = this.getAttribute(\"min\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"min\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"minLength\", {\n  get() {\n    return this[impl].minLength;\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this[impl].minLength = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"multiple\", {\n  get() {\n    return this.hasAttribute(\"multiple\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"multiple\", \"\");\n  } else {\n    this.removeAttribute(\"multiple\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"pattern\", {\n  get() {\n    const value = this.getAttribute(\"pattern\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"pattern\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"placeholder\", {\n  get() {\n    const value = this.getAttribute(\"placeholder\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"placeholder\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"readOnly\", {\n  get() {\n    return this.hasAttribute(\"readOnly\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"readOnly\", \"\");\n  } else {\n    this.removeAttribute(\"readOnly\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"required\", {\n  get() {\n    return this.hasAttribute(\"required\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"required\", \"\");\n  } else {\n    this.removeAttribute(\"required\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"size\", {\n  get() {\n    return this[impl].size;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].size = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"src\", {\n  get() {\n    const value = this.getAttribute(\"src\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"src\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"step\", {\n  get() {\n    const value = this.getAttribute(\"step\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"step\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"type\", {\n  get() {\n    return this[impl].type;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].type = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"defaultValue\", {\n  get() {\n    const value = this.getAttribute(\"value\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"value\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"value\", {\n  get() {\n    return this[impl].value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].value = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"selectionStart\", {\n  get() {\n    return this[impl].selectionStart;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"unsigned long\"](V);\n    }\n    this[impl].selectionStart = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"selectionEnd\", {\n  get() {\n    return this[impl].selectionEnd;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"unsigned long\"](V);\n    }\n    this[impl].selectionEnd = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"selectionDirection\", {\n  get() {\n    return this[impl].selectionDirection;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this[impl].selectionDirection = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"useMap\", {\n  get() {\n    const value = this.getAttribute(\"useMap\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"useMap\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLInputElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLInputElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLInputElement,\n  expose: {\n    Window: { HTMLInputElement: HTMLInputElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLInputElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLInputElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\n\nconst Event = require(\"../generated/Event\");\nconst FileList = require(\"../generated/FileList\");\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst internalConstants = require(\"../helpers/internal-constants\");\nconst domSymbolTree = internalConstants.domSymbolTree;\nconst cloningSteps = internalConstants.cloningSteps;\nconst closest = require(\"../helpers/traversal\").closest;\nconst isDisabled = require(\"../helpers/form-controls\").isDisabled;\n\nconst filesSymbol = Symbol(\"files\");\n\nconst selectAllowedTypes = new Set([\"text\", \"search\", \"tel\", \"url\", \"password\", \"email\", \"date\", \"month\", \"week\",\n  \"time\", \"datetime-local\", \"color\", \"file\", \"number\"]);\n\nconst variableLengthSelectionAllowedTypes = new Set([\"text\", \"search\", \"tel\", \"url\", \"password\"]);\n\nfunction allowSelect(type) {\n  return selectAllowedTypes.has(type.toLowerCase());\n}\n\nfunction allowVariableLengthSelection(type) {\n  return variableLengthSelectionAllowedTypes.has(type.toLowerCase());\n}\n\nclass HTMLInputElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    if (!this.type) {\n      this.type = \"text\";\n    }\n    this._selectionStart = this._selectionEnd = 0;\n    this._selectionDirection = \"none\";\n    this._value = null;\n    this._dirtyValue = false;\n    this._checkedness = false;\n    this._dirtyCheckedness = false;\n\n    // This is used to implement the canceled activation steps for radio inputs:\n    // \"The canceled activation steps consist of setting the checkedness and the element's indeterminate IDL\n    // attribute back to the values they had before the pre-click activation steps were run.\"\n    this._preCancelState = null;\n  }\n\n  _getValue() {\n    return this._value;\n  }\n\n  _preClickActivationSteps() {\n    if (this.type === \"checkbox\") {\n      this.checked = !this.checked;\n    } else if (this.type === \"radio\") {\n      this._preCancelState = this.checked;\n      this.checked = true;\n    }\n  }\n\n  _canceledActivationSteps() {\n    if (this.type === \"checkbox\") {\n      this.checked = !this.checked;\n    } else if (this.type === \"radio\") {\n      if (this._preCancelState !== null) {\n        this.checked = this._preCancelState;\n        this._preCancelState = null;\n      }\n    }\n  }\n\n  _activationBehavior() {\n    if (isDisabled(this)) {\n      return;\n    }\n\n    if (this.type === \"checkbox\") {\n      const inputEvent = Event.createImpl([\"input\", { bubbles: true, cancelable: true }], {});\n      this.dispatchEvent(inputEvent);\n\n      const changeEvent = Event.createImpl([\"change\", { bubbles: true, cancelable: true }], {});\n      this.dispatchEvent(changeEvent);\n    } else if (this.type === \"submit\") {\n      const form = this.form;\n      if (form) {\n        form._dispatchSubmitEvent();\n      }\n    }\n  }\n\n  _attrModified(name) {\n    const wrapper = idlUtils.wrapperForImpl(this);\n    if (!this._dirtyValue && name === \"value\") {\n      this._value = wrapper.defaultValue;\n    }\n    if (!this._dirtyCheckedness && name === \"checked\") {\n      this._checkedness = wrapper.defaultChecked;\n      if (this._checkedness) {\n        this._removeOtherRadioCheckedness();\n      }\n    }\n\n    if (name === \"name\" || name === \"type\") {\n      if (this._checkedness) {\n        this._removeOtherRadioCheckedness();\n      }\n    }\n\n    super._attrModified.apply(this, arguments);\n  }\n  _formReset() {\n    const wrapper = idlUtils.wrapperForImpl(this);\n    this._value = wrapper.defaultValue;\n    this._dirtyValue = false;\n    this._checkedness = wrapper.defaultChecked;\n    this._dirtyCheckedness = false;\n    if (this._checkedness) {\n      this._removeOtherRadioCheckedness();\n    }\n  }\n  _changedFormOwner() {\n    if (this._checkedness) {\n      this._removeOtherRadioCheckedness();\n    }\n  }\n  _removeOtherRadioCheckedness() {\n    const wrapper = idlUtils.wrapperForImpl(this);\n    const root = this._radioButtonGroupRoot;\n    if (!root) {\n      return;\n    }\n\n    const name = wrapper.name.toLowerCase();\n\n    const descendants = domSymbolTree.treeIterator(root);\n    for (const candidate of descendants) {\n      if (candidate._radioButtonGroupRoot !== root) {\n        continue;\n      }\n\n      const candidateWrapper = idlUtils.wrapperForImpl(candidate);\n      if (!candidateWrapper.name || candidateWrapper.name.toLowerCase() !== name) {\n        continue;\n      }\n\n      if (candidate !== this) {\n        candidate._checkedness = false;\n      }\n    }\n  }\n  get _radioButtonGroupRoot() {\n    const wrapper = idlUtils.wrapperForImpl(this);\n    if (this.type !== \"radio\" || !wrapper.name) {\n      return null;\n    }\n\n    let e = domSymbolTree.parent(this);\n    while (e) {\n      // root node of this home sub tree\n      // or the form element we belong to\n      if (!domSymbolTree.parent(e) || e.nodeName.toUpperCase() === \"FORM\") {\n        return e;\n      }\n      e = domSymbolTree.parent(e);\n    }\n    return null;\n  }\n  get form() {\n    return closest(this, \"form\");\n  }\n  get checked() {\n    return this._checkedness;\n  }\n  set checked(checked) {\n    this._checkedness = Boolean(checked);\n    this._dirtyCheckedness = true;\n    if (this._checkedness) {\n      this._removeOtherRadioCheckedness();\n    }\n  }\n  get value() {\n    if (this._value === null) {\n      return \"\";\n    }\n    return this._value;\n  }\n  set value(val) {\n    this._dirtyValue = true;\n\n    if (val === null) {\n      this._value = null;\n    } else {\n      this._value = String(val);\n    }\n\n    this._selectionStart = 0;\n    this._selectionEnd = 0;\n    this._selectionDirection = \"none\";\n  }\n  get files() {\n    if (this.type === \"file\") {\n      this[filesSymbol] = this[filesSymbol] || FileList.create();\n    } else {\n      this[filesSymbol] = null;\n    }\n    return this[filesSymbol];\n  }\n  get type() {\n    const type = this.getAttribute(\"type\");\n    return type ? type.toLowerCase() : \"text\";\n  }\n  set type(type) {\n    this.setAttribute(\"type\", type);\n  }\n\n  _dispatchSelectEvent() {\n    const event = this._ownerDocument.createEvent(\"HTMLEvents\");\n    event.initEvent(\"select\", true, true);\n    this.dispatchEvent(event);\n  }\n  _getValueLength() {\n    return typeof this.value === \"string\" ? this.value.length : 0;\n  }\n\n  select() {\n    if (!allowSelect(this.type)) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR);\n    }\n\n    this._selectionStart = 0;\n    this._selectionEnd = this._getValueLength();\n    this._selectionDirection = \"none\";\n    this._dispatchSelectEvent();\n  }\n\n  get selectionStart() {\n    if (!allowVariableLengthSelection(this.type)) {\n      return null;\n    }\n\n    return this._selectionStart;\n  }\n\n  set selectionStart(start) {\n    if (!allowVariableLengthSelection(this.type)) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR);\n    }\n\n    this.setSelectionRange(start, Math.max(start, this._selectionEnd), this._selectionDirection);\n  }\n\n  get selectionEnd() {\n    if (!allowVariableLengthSelection(this.type)) {\n      return null;\n    }\n\n    return this._selectionEnd;\n  }\n\n  set selectionEnd(end) {\n    if (!allowVariableLengthSelection(this.type)) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR);\n    }\n\n    this.setSelectionRange(this._selectionStart, end, this._selectionDirection);\n  }\n\n  get selectionDirection() {\n    if (!allowVariableLengthSelection(this.type)) {\n      return null;\n    }\n\n    return this._selectionDirection;\n  }\n\n  set selectionDirection(dir) {\n    if (!allowVariableLengthSelection(this.type)) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR);\n    }\n\n    this.setSelectionRange(this._selectionStart, this._selectionEnd, dir);\n  }\n\n  setSelectionRange(start, end, dir) {\n    if (!allowVariableLengthSelection(this.type)) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR);\n    }\n\n    this._selectionEnd = Math.min(end, this._getValueLength());\n    this._selectionStart = Math.min(start, this._selectionEnd);\n    this._selectionDirection = dir === \"forward\" || dir === \"backward\" ? dir : \"none\";\n    this._dispatchSelectEvent();\n  }\n\n  setRangeText(repl, start, end, selectionMode) {\n    if (!allowVariableLengthSelection(this.type)) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR);\n    }\n\n    if (arguments.length < 2) {\n      start = this._selectionStart;\n      end = this._selectionEnd;\n    } else if (start > end) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n\n    start = Math.min(start, this._getValueLength());\n    end = Math.min(end, this._getValueLength());\n\n    const val = this.value;\n    let selStart = this._selectionStart;\n    let selEnd = this._selectionEnd;\n\n    this.value = val.slice(0, start) + repl + val.slice(end);\n\n    const newEnd = start + this.value.length;\n\n    if (selectionMode === \"select\") {\n      this.setSelectionRange(start, newEnd);\n    } else if (selectionMode === \"start\") {\n      this.setSelectionRange(start, start);\n    } else if (selectionMode === \"end\") {\n      this.setSelectionRange(newEnd, newEnd);\n    } else { // preserve\n      const delta = repl.length - (end - start);\n\n      if (selStart > end) {\n        selStart += delta;\n      } else if (selStart > start) {\n        selStart = start;\n      }\n\n      if (selEnd > end) {\n        selEnd += delta;\n      } else if (selEnd > start) {\n        selEnd = newEnd;\n      }\n\n      this.setSelectionRange(selStart, selEnd);\n    }\n  }\n\n  set maxLength(value) {\n    if (value < 0) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n    this.setAttribute(\"maxlength\", String(value));\n  }\n\n  get maxLength() {\n    if (!this.hasAttribute(\"maxlength\")) {\n      return 524288; // stole this from chrome\n    }\n    return parseInt(this.getAttribute(\"maxlength\"));\n  }\n\n  set minLength(value) {\n    if (value < 0) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n    this.setAttribute(\"minlength\", String(value));\n  }\n\n  get minLength() {\n    if (!this.hasAttribute(\"minlength\")) {\n      return 0;\n    }\n    return parseInt(this.getAttribute(\"minlength\"));\n  }\n\n  get size() {\n    if (!this.hasAttribute(\"size\")) {\n      return 20;\n    }\n    return parseInt(this.getAttribute(\"size\"));\n  }\n\n  set size(value) {\n    if (value <= 0) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n    this.setAttribute(\"size\", String(value));\n  }\n\n  [cloningSteps](copy, node) {\n    copy._value = node._value;\n    copy._checkedness = node._checkedness;\n    copy._dirtyValue = node._dirtyValue;\n    copy._dirtyCheckedness = node._dirtyCheckedness;\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLInputElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLLabelElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLLabelElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLLabelElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLLabelElement.prototype.constructor = HTMLLabelElement;\n\n\nHTMLLabelElement.prototype.toString = function () {\n  if (this === HTMLLabelElement.prototype) {\n    return \"[object HTMLLabelElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLLabelElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLabelElement.prototype, \"htmlFor\", {\n  get() {\n    const value = this.getAttribute(\"for\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"for\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLLabelElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLLabelElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLLabelElement,\n  expose: {\n    Window: { HTMLLabelElement: HTMLLabelElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLLabelElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLLabelElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst MouseEvent = require(\"../generated/MouseEvent\");\nconst closest = require(\"../helpers/traversal\").closest;\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\n\nfunction isLabelable(node) {\n  // labelable logic defined at: https://html.spec.whatwg.org/multipage/forms.html#category-label\n  if (node.nodeType !== 1) {\n    return false;\n  }\n\n  switch (node.tagName) {\n    case \"BUTTON\":\n    case \"KEYGEN\":\n    case \"METER\":\n    case \"OUTPUT\":\n    case \"PROGRESS\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      return true;\n\n    case \"INPUT\":\n      return node.type !== \"hidden\";\n  }\n\n  return false;\n}\n\nfunction sendClickToAssociatedNode(node) {\n  node.dispatchEvent(\n    MouseEvent.createImpl([\"click\", {\n      bubbles: true,\n      cancelable: true,\n      view: node.ownerDocument ? node.ownerDocument.defaultView : null,\n      screenX: 0,\n      screenY: 0,\n      clientX: 0,\n      clientY: 0,\n      button: 0,\n      detail: 1,\n      relatedTarget: null\n    }])\n  );\n}\n\nclass HTMLLabelElementImpl extends HTMLElementImpl {\n  _activationBehavior() {\n    if (this.hasAttribute(\"for\")) {\n      const node = this.ownerDocument.getElementById(this.getAttribute(\"for\"));\n      if (node && isLabelable(node)) {\n        sendClickToAssociatedNode(node);\n      }\n    } else {\n      for (const descendant of domSymbolTree.treeIterator(this)) {\n        if (isLabelable(descendant)) {\n          sendClickToAssociatedNode(descendant);\n          break;\n        }\n      }\n    }\n  }\n\n  get form() {\n    return closest(this, \"form\");\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLLabelElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLLegendElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLLegendElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLLegendElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLLegendElement.prototype.constructor = HTMLLegendElement;\n\n\nHTMLLegendElement.prototype.toString = function () {\n  if (this === HTMLLegendElement.prototype) {\n    return \"[object HTMLLegendElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLLegendElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLegendElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLLegendElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLLegendElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLLegendElement,\n  expose: {\n    Window: { HTMLLegendElement: HTMLLegendElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLLegendElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLLegendElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst closest = require(\"../helpers/traversal\").closest;\n\nclass HTMLLegendElementImpl extends HTMLElementImpl {\n  get form() {\n    return closest(this, \"form\");\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLLegendElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLLIElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLLIElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLLIElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLLIElement.prototype.constructor = HTMLLIElement;\n\n\nHTMLLIElement.prototype.toString = function () {\n  if (this === HTMLLIElement.prototype) {\n    return \"[object HTMLLIElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLLIElement.prototype, \"value\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"value\"));\n    return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this.setAttribute(\"value\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLIElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLLIElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLLIElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLLIElement,\n  expose: {\n    Window: { HTMLLIElement: HTMLLIElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLLIElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLLIElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLLIElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLLIElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLLinkElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst LinkStyle = require(\"./LinkStyle.js\");\n\nfunction HTMLLinkElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLLinkElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLLinkElement.prototype.constructor = HTMLLinkElement;\n\nmixin(HTMLLinkElement.prototype, LinkStyle.interface.prototype);\nLinkStyle.mixedInto.push(HTMLLinkElement);\n\nHTMLLinkElement.prototype.toString = function () {\n  if (this === HTMLLinkElement.prototype) {\n    return \"[object HTMLLinkElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLLinkElement.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLinkElement.prototype, \"crossOrigin\", {\n  get() {\n    const value = this.getAttribute(\"crossOrigin\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this.setAttribute(\"crossOrigin\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLinkElement.prototype, \"rel\", {\n  get() {\n    const value = this.getAttribute(\"rel\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"rel\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLinkElement.prototype, \"media\", {\n  get() {\n    const value = this.getAttribute(\"media\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"media\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLinkElement.prototype, \"hreflang\", {\n  get() {\n    const value = this.getAttribute(\"hreflang\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"hreflang\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLinkElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLinkElement.prototype, \"charset\", {\n  get() {\n    const value = this.getAttribute(\"charset\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"charset\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLinkElement.prototype, \"rev\", {\n  get() {\n    const value = this.getAttribute(\"rev\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"rev\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLLinkElement.prototype, \"target\", {\n  get() {\n    const value = this.getAttribute(\"target\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"target\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLLinkElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLLinkElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLLinkElement,\n  expose: {\n    Window: { HTMLLinkElement: HTMLLinkElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLLinkElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/LinkStyle.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction LinkStyle() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nLinkStyle.prototype.toString = function () {\n  if (this === LinkStyle.prototype) {\n    return \"[object LinkStylePrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(LinkStyle.prototype, \"sheet\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].sheet);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(LinkStyle.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(LinkStyle.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: LinkStyle,\n  expose: {\n    \n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/LinkStyle-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/LinkStyle-impl.js":"\"use strict\";\n\nconst cssom = require(\"cssom\");\n\nclass LinkStyleImpl {\n  get sheet() {\n    if (!this._cssStyleSheet) {\n      this._cssStyleSheet = new cssom.CSSStyleSheet();\n    }\n    return this._cssStyleSheet;\n  }\n}\n\nmodule.exports = {\n  implementation: LinkStyleImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLLinkElement-impl.js":"\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst LinkStyleImpl = require(\"./LinkStyle-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\nconst fetchStylesheet = require(\"../helpers/stylesheets\").fetchStylesheet;\nconst parseURLToResultingURLRecord = require(\"../helpers/document-base-url\").parseURLToResultingURLRecord;\nconst whatwgURL = require(\"whatwg-url\");\n\n// Important reading: \"appropriate times to obtain the resource\" in\n// https://html.spec.whatwg.org/multipage/semantics.html#link-type-stylesheet\n\nclass HTMLLinkElementImpl extends HTMLElementImpl {\n  _attach() {\n    super._attach();\n\n    if (isExternalResourceLink(this)) {\n      obtainTheResource(this);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    super._attrModified(name, value, oldValue);\n\n    if (name === \"href\" && this._attached && isExternalResourceLink(this)) {\n      obtainTheResource(this);\n    }\n  }\n\n  get _accept() {\n    return \"text/css,*/*;q=0.1\";\n  }\n\n  get href() {\n    return reflectURLAttribute(this, \"href\");\n  }\n\n  set href(value) {\n    this.setAttribute(\"href\", value);\n  }\n}\n\nidlUtils.mixin(HTMLLinkElementImpl.prototype, LinkStyleImpl.prototype);\n\nmodule.exports = {\n  implementation: HTMLLinkElementImpl\n};\n\nfunction obtainTheResource(el) {\n  const href = el.getAttribute(\"href\");\n\n  if (href === null || href === \"\") {\n    return;\n  }\n\n  const url = parseURLToResultingURLRecord(href, el._ownerDocument);\n  if (url === \"failure\") {\n    return;\n  }\n\n  const serialized = whatwgURL.serializeURL(url);\n\n  fetchStylesheet(el, serialized, el.sheet);\n}\n\nfunction isExternalResourceLink(el) {\n  // for our purposes, only stylesheets can be external resource links\n  const wrapper = idlUtils.wrapperForImpl(el);\n  if (!/(?:[ \\t\\n\\r\\f]|^)stylesheet(?:[ \\t\\n\\r\\f]|$)/i.test(wrapper.rel)) {\n    // rel is a space-separated list of tokens, and the original rel types\n    // are case-insensitive.\n    return false;\n  }\n\n  return Boolean(el.href);\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/helpers/stylesheets.js":"\"use strict\";\nconst cssom = require(\"cssom\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst whatwgURL = require(\"whatwg-url\");\nconst resourceLoader = require(\"../../browser/resource-loader\");\n\nexports.fetchStylesheet = (elementImpl, urlString, sheet) => {\n  const parsedURL = whatwgURL.parseURL(urlString);\n  return fetchStylesheetInternal(elementImpl, urlString, parsedURL, sheet);\n};\n\nexports.evaluateStylesheet = (elementImpl, data, sheet, baseURL) => {\n  let newStyleSheet;\n  try {\n    newStyleSheet = cssom.parse(data);\n  } catch (e) {\n    if (elementImpl._ownerDocument._defaultView) {\n      const error = new Error(\"Could not parse CSS stylesheet\");\n      error.detail = data;\n      error.type = \"css parsing\";\n\n      elementImpl._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n    }\n\n    elementImpl._ownerDocument.styleSheets.push(sheet);\n    return;\n  }\n\n  const spliceArgs = newStyleSheet.cssRules;\n  spliceArgs.unshift(0, sheet.cssRules.length);\n  Array.prototype.splice.apply(sheet.cssRules, spliceArgs);\n\n  scanForImportRules(elementImpl, sheet.cssRules, baseURL);\n\n  elementImpl._ownerDocument.styleSheets.push(sheet);\n};\n\nfunction fetchStylesheetInternal(elementImpl, urlString, parsedURL, sheet) {\n  let defaultEncoding = elementImpl._ownerDocument._encoding;\n  if (elementImpl.localName === \"link\" && elementImpl.hasAttribute(\"charset\")) {\n    defaultEncoding = whatwgEncoding.labelToName(elementImpl.getAttribute(\"charset\"));\n  }\n\n  resourceLoader.load(elementImpl, urlString, { defaultEncoding }, data => {\n    // TODO: MIME type checking?\n    exports.evaluateStylesheet(elementImpl, data, sheet, parsedURL);\n  });\n}\n\nfunction scanForImportRules(elementImpl, cssRules, baseURL) {\n  if (!cssRules) {\n    return;\n  }\n\n  for (let i = 0; i < cssRules.length; ++i) {\n    if (cssRules[i].cssRules) {\n      // @media rule: keep searching inside it.\n      scanForImportRules(elementImpl, cssRules[i].cssRules, baseURL);\n    } else if (cssRules[i].href) {\n      // @import rule: fetch the resource and evaluate it.\n      // See http://dev.w3.org/csswg/cssom/#css-import-rule\n      //     If loading of the style sheet fails its cssRules list is simply\n      //     empty. I.e. an @import rule always has an associated style sheet.\n      const parsed = whatwgURL.parseURL(cssRules[i].href, { baseURL });\n      if (parsed === \"failure\") {\n        const window = elementImpl._ownerDocument._defaultView;\n        if (window) {\n          const error = new Error(`Could not parse CSS @import URL ${cssRules[i].href} relative to base URL ` +\n                                  `\"${whatwgURL.serializeURL(baseURL)}\"`);\n          error.type = \"css @import URL parsing\";\n          window._virtualConsole.emit(\"jsdomError\", error);\n        }\n      } else {\n        fetchStylesheetInternal(elementImpl, whatwgURL.serializeURL(parsed), parsed, elementImpl.sheet);\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLMapElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLMapElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLMapElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLMapElement.prototype.constructor = HTMLMapElement;\n\n\nHTMLMapElement.prototype.toString = function () {\n  if (this === HTMLMapElement.prototype) {\n    return \"[object HTMLMapElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLMapElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMapElement.prototype, \"areas\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].areas);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMapElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMapElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLMapElement,\n  expose: {\n    Window: { HTMLMapElement: HTMLMapElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLMapElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLMapElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLMapElementImpl extends HTMLElementImpl {\n  get areas() {\n    return this.getElementsByTagName(\"AREA\");\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLMapElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLMenuElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLMenuElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLMenuElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLMenuElement.prototype.constructor = HTMLMenuElement;\n\n\nHTMLMenuElement.prototype.toString = function () {\n  if (this === HTMLMenuElement.prototype) {\n    return \"[object HTMLMenuElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLMenuElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMenuElement.prototype, \"label\", {\n  get() {\n    const value = this.getAttribute(\"label\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"label\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMenuElement.prototype, \"compact\", {\n  get() {\n    return this.hasAttribute(\"compact\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"compact\", \"\");\n  } else {\n    this.removeAttribute(\"compact\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMenuElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMenuElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLMenuElement,\n  expose: {\n    Window: { HTMLMenuElement: HTMLMenuElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLMenuElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLMenuElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLMenuElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLMenuElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLMetaElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLMetaElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLMetaElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLMetaElement.prototype.constructor = HTMLMetaElement;\n\n\nHTMLMetaElement.prototype.toString = function () {\n  if (this === HTMLMetaElement.prototype) {\n    return \"[object HTMLMetaElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLMetaElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMetaElement.prototype, \"httpEquiv\", {\n  get() {\n    const value = this.getAttribute(\"http-equiv\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"http-equiv\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMetaElement.prototype, \"content\", {\n  get() {\n    const value = this.getAttribute(\"content\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"content\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLMetaElement.prototype, \"scheme\", {\n  get() {\n    const value = this.getAttribute(\"scheme\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"scheme\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMetaElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMetaElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLMetaElement,\n  expose: {\n    Window: { HTMLMetaElement: HTMLMetaElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLMetaElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLMetaElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLMetaElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLMetaElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLMeterElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLMeterElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLMeterElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLMeterElement.prototype.constructor = HTMLMeterElement;\n\n\nHTMLMeterElement.prototype.toString = function () {\n  if (this === HTMLMeterElement.prototype) {\n    return \"[object HTMLMeterElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMeterElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLMeterElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLMeterElement,\n  expose: {\n    Window: { HTMLMeterElement: HTMLMeterElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLMeterElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLMeterElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLMeterElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLMeterElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLModElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLModElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLModElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLModElement.prototype.constructor = HTMLModElement;\n\n\nHTMLModElement.prototype.toString = function () {\n  if (this === HTMLModElement.prototype) {\n    return \"[object HTMLModElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLModElement.prototype, \"cite\", {\n  get() {\n    const value = this.getAttribute(\"cite\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"cite\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLModElement.prototype, \"dateTime\", {\n  get() {\n    const value = this.getAttribute(\"dateTime\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"dateTime\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLModElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLModElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLModElement,\n  expose: {\n    Window: { HTMLModElement: HTMLModElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLModElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLModElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLModElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLModElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLObjectElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLObjectElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLObjectElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLObjectElement.prototype.constructor = HTMLObjectElement;\n\n\nHTMLObjectElement.prototype.toString = function () {\n  if (this === HTMLObjectElement.prototype) {\n    return \"[object HTMLObjectElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLObjectElement.prototype, \"data\", {\n  get() {\n    return this[impl].data;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].data = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"useMap\", {\n  get() {\n    const value = this.getAttribute(\"useMap\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"useMap\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"width\", {\n  get() {\n    const value = this.getAttribute(\"width\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"width\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"height\", {\n  get() {\n    const value = this.getAttribute(\"height\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"height\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"contentDocument\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].contentDocument);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"archive\", {\n  get() {\n    const value = this.getAttribute(\"archive\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"archive\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"code\", {\n  get() {\n    const value = this.getAttribute(\"code\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"code\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"declare\", {\n  get() {\n    return this.hasAttribute(\"declare\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"declare\", \"\");\n  } else {\n    this.removeAttribute(\"declare\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"hspace\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"hspace\"));\n    return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    V = V > 2147483647 ? 0 : V;\n    this.setAttribute(\"hspace\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"standby\", {\n  get() {\n    const value = this.getAttribute(\"standby\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"standby\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"vspace\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"vspace\"));\n    return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    V = V > 2147483647 ? 0 : V;\n    this.setAttribute(\"vspace\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"codeBase\", {\n  get() {\n    return this[impl].codeBase;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].codeBase = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"codeType\", {\n  get() {\n    const value = this.getAttribute(\"codeType\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"codeType\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLObjectElement.prototype, \"border\", {\n  get() {\n    const value = this.getAttribute(\"border\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"border\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLObjectElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLObjectElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLObjectElement,\n  expose: {\n    Window: { HTMLObjectElement: HTMLObjectElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLObjectElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLObjectElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\nconst closest = require(\"../helpers/traversal\").closest;\n\nclass HTMLObjectElementImpl extends HTMLElementImpl {\n  get form() {\n    return closest(this, \"form\");\n  }\n\n  get contentDocument() {\n    return null;\n  }\n\n  get data() {\n    return reflectURLAttribute(this, \"data\");\n  }\n\n  set data(V) {\n    this.setAttribute(\"data\", V);\n  }\n\n  get codeBase() {\n    return reflectURLAttribute(this, \"codebase\");\n  }\n\n  set codeBase(V) {\n    this.setAttribute(\"codebase\", V);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLObjectElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLOListElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLOListElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLOListElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLOListElement.prototype.constructor = HTMLOListElement;\n\n\nHTMLOListElement.prototype.toString = function () {\n  if (this === HTMLOListElement.prototype) {\n    return \"[object HTMLOListElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLOListElement.prototype, \"reversed\", {\n  get() {\n    return this.hasAttribute(\"reversed\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"reversed\", \"\");\n  } else {\n    this.removeAttribute(\"reversed\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOListElement.prototype, \"start\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"start\"));\n    return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this.setAttribute(\"start\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOListElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOListElement.prototype, \"compact\", {\n  get() {\n    return this.hasAttribute(\"compact\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"compact\", \"\");\n  } else {\n    this.removeAttribute(\"compact\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOListElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOListElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLOListElement,\n  expose: {\n    Window: { HTMLOListElement: HTMLOListElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLOListElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLOListElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLOListElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLOListElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLOptGroupElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLOptGroupElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLOptGroupElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLOptGroupElement.prototype.constructor = HTMLOptGroupElement;\n\n\nHTMLOptGroupElement.prototype.toString = function () {\n  if (this === HTMLOptGroupElement.prototype) {\n    return \"[object HTMLOptGroupElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLOptGroupElement.prototype, \"disabled\", {\n  get() {\n    return this.hasAttribute(\"disabled\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"disabled\", \"\");\n  } else {\n    this.removeAttribute(\"disabled\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptGroupElement.prototype, \"label\", {\n  get() {\n    const value = this.getAttribute(\"label\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"label\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOptGroupElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOptGroupElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLOptGroupElement,\n  expose: {\n    Window: { HTMLOptGroupElement: HTMLOptGroupElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLOptGroupElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLOptGroupElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLOptGroupElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLOptGroupElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLOptionElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLOptionElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLOptionElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLOptionElement.prototype.constructor = HTMLOptionElement;\n\n\nHTMLOptionElement.prototype.toString = function () {\n  if (this === HTMLOptionElement.prototype) {\n    return \"[object HTMLOptionElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLOptionElement.prototype, \"disabled\", {\n  get() {\n    return this.hasAttribute(\"disabled\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"disabled\", \"\");\n  } else {\n    this.removeAttribute(\"disabled\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionElement.prototype, \"label\", {\n  get() {\n    return this[impl].label;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].label = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionElement.prototype, \"defaultSelected\", {\n  get() {\n    return this.hasAttribute(\"selected\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"selected\", \"\");\n  } else {\n    this.removeAttribute(\"selected\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionElement.prototype, \"selected\", {\n  get() {\n    return this[impl].selected;\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    this[impl].selected = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionElement.prototype, \"value\", {\n  get() {\n    return this[impl].value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].value = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionElement.prototype, \"text\", {\n  get() {\n    return this[impl].text;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].text = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionElement.prototype, \"index\", {\n  get() {\n    return this[impl].index;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOptionElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOptionElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLOptionElement,\n  expose: {\n    Window: { HTMLOptionElement: HTMLOptionElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLOptionElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLOptionElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst stripAndCollapseASCIIWhitespace = require(\"../helpers/strings\").stripAndCollapseASCIIWhitespace;\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst closest = require(\"../helpers/traversal\").closest;\n\nclass HTMLOptionElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    // whenever selectedness is set to true, make sure all\n    // other options set selectedness to false\n    this._selectedness = false;\n    this._dirtyness = false;\n  }\n  _removeOtherSelectedness() {\n    // Remove the selectedness flag from all other options in this select\n    const select = this._selectNode;\n\n    if (select && !select.hasAttribute(\"multiple\")) {\n      const o = select.options;\n      for (let i = 0; i < o.length; i++) {\n        const option = idlUtils.implForWrapper(o[i]);\n        if (option !== this) {\n          option._selectedness = false;\n        }\n      }\n    }\n  }\n  _askForAReset() {\n    const select = this._selectNode;\n    if (select) {\n      select._askedForAReset();\n    }\n  }\n  _attrModified(name) {\n    if (!this._dirtyness && name === \"selected\") {\n      const wrapper = idlUtils.wrapperForImpl(this);\n      this._selectedness = wrapper.defaultSelected;\n      if (this._selectedness) {\n        this._removeOtherSelectedness();\n      }\n      this._askForAReset();\n    }\n    super._attrModified.apply(this, arguments);\n  }\n  get _selectNode() {\n    let select = domSymbolTree.parent(this);\n    if (!select) {\n      return null;\n    }\n\n    if (select.nodeName.toUpperCase() !== \"SELECT\") {\n      select = domSymbolTree.parent(select);\n      if (!select || select.nodeName.toUpperCase() !== \"SELECT\") {\n        return null;\n      }\n    }\n    return select;\n  }\n  get form() {\n    return closest(this, \"form\");\n  }\n  get text() {\n    // TODO is not correctly excluding script and SVG script descendants\n    return stripAndCollapseASCIIWhitespace(this.textContent);\n  }\n  set text(V) {\n    this.textContent = V;\n  }\n\n  get value() {\n    return this.hasAttribute(\"value\") ? this.getAttribute(\"value\") : this.text;\n  }\n  set value(val) {\n    this.setAttribute(\"value\", val);\n  }\n  get index() {\n    const select = closest(this, \"select\");\n    if (select === null) {\n      return 0;\n    }\n\n    return Array.prototype.indexOf.call(select.options, idlUtils.wrapperForImpl(this));\n  }\n  get selected() {\n    return this._selectedness;\n  }\n  set selected(s) {\n    this._dirtyness = true;\n    this._selectedness = Boolean(s);\n    if (this._selectedness) {\n      this._removeOtherSelectedness();\n    }\n    this._askForAReset();\n  }\n\n  // TODO this is quite wrong\n  get label() {\n    if (this.hasAttribute(\"label\")) {\n      return this.getAttribute(\"label\");\n    }\n    const select = this._selectNode;\n    if (select) {\n      return select.getAttribute(\"label\");\n    }\n    return null;\n  }\n\n  set label(V) {\n    const select = this._selectNode;\n    if (select) {\n      select.setAttribute(\"label\", V);\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLOptionElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLOutputElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLOutputElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLOutputElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLOutputElement.prototype.constructor = HTMLOutputElement;\n\n\nHTMLOutputElement.prototype.toString = function () {\n  if (this === HTMLOutputElement.prototype) {\n    return \"[object HTMLOutputElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLOutputElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOutputElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOutputElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLOutputElement,\n  expose: {\n    Window: { HTMLOutputElement: HTMLOutputElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLOutputElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLOutputElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLOutputElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLOutputElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLParagraphElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLParagraphElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLParagraphElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLParagraphElement.prototype.constructor = HTMLParagraphElement;\n\n\nHTMLParagraphElement.prototype.toString = function () {\n  if (this === HTMLParagraphElement.prototype) {\n    return \"[object HTMLParagraphElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLParagraphElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLParagraphElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLParagraphElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLParagraphElement,\n  expose: {\n    Window: { HTMLParagraphElement: HTMLParagraphElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLParagraphElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLParagraphElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLParagraphElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLParagraphElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLParamElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLParamElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLParamElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLParamElement.prototype.constructor = HTMLParamElement;\n\n\nHTMLParamElement.prototype.toString = function () {\n  if (this === HTMLParamElement.prototype) {\n    return \"[object HTMLParamElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLParamElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLParamElement.prototype, \"value\", {\n  get() {\n    const value = this.getAttribute(\"value\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"value\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLParamElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLParamElement.prototype, \"valueType\", {\n  get() {\n    const value = this.getAttribute(\"valueType\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"valueType\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLParamElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLParamElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLParamElement,\n  expose: {\n    Window: { HTMLParamElement: HTMLParamElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLParamElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLParamElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLParamElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLParamElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLPreElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLPreElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLPreElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLPreElement.prototype.constructor = HTMLPreElement;\n\n\nHTMLPreElement.prototype.toString = function () {\n  if (this === HTMLPreElement.prototype) {\n    return \"[object HTMLPreElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLPreElement.prototype, \"width\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"width\"));\n    return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this.setAttribute(\"width\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLPreElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLPreElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLPreElement,\n  expose: {\n    Window: { HTMLPreElement: HTMLPreElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLPreElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLPreElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLPreElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLPreElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLProgressElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLProgressElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLProgressElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLProgressElement.prototype.constructor = HTMLProgressElement;\n\n\nHTMLProgressElement.prototype.toString = function () {\n  if (this === HTMLProgressElement.prototype) {\n    return \"[object HTMLProgressElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLProgressElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLProgressElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLProgressElement,\n  expose: {\n    Window: { HTMLProgressElement: HTMLProgressElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLProgressElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLProgressElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLProgressElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLProgressElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLQuoteElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLQuoteElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLQuoteElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLQuoteElement.prototype.constructor = HTMLQuoteElement;\n\n\nHTMLQuoteElement.prototype.toString = function () {\n  if (this === HTMLQuoteElement.prototype) {\n    return \"[object HTMLQuoteElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLQuoteElement.prototype, \"cite\", {\n  get() {\n    const value = this.getAttribute(\"cite\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"cite\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLQuoteElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLQuoteElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLQuoteElement,\n  expose: {\n    Window: { HTMLQuoteElement: HTMLQuoteElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLQuoteElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLQuoteElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLQuoteElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLQuoteElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLScriptElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLScriptElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLScriptElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLScriptElement.prototype.constructor = HTMLScriptElement;\n\n\nHTMLScriptElement.prototype.toString = function () {\n  if (this === HTMLScriptElement.prototype) {\n    return \"[object HTMLScriptElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLScriptElement.prototype, \"src\", {\n  get() {\n    return this[impl].src;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].src = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLScriptElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLScriptElement.prototype, \"charset\", {\n  get() {\n    const value = this.getAttribute(\"charset\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"charset\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLScriptElement.prototype, \"defer\", {\n  get() {\n    return this.hasAttribute(\"defer\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"defer\", \"\");\n  } else {\n    this.removeAttribute(\"defer\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLScriptElement.prototype, \"crossOrigin\", {\n  get() {\n    const value = this.getAttribute(\"crossOrigin\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this.setAttribute(\"crossOrigin\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLScriptElement.prototype, \"text\", {\n  get() {\n    return this[impl].text;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].text = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLScriptElement.prototype, \"nonce\", {\n  get() {\n    const value = this.getAttribute(\"nonce\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"nonce\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLScriptElement.prototype, \"event\", {\n  get() {\n    const value = this.getAttribute(\"event\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"event\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLScriptElement.prototype, \"htmlFor\", {\n  get() {\n    const value = this.getAttribute(\"for\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"for\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLScriptElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLScriptElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLScriptElement,\n  expose: {\n    Window: { HTMLScriptElement: HTMLScriptElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLScriptElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLScriptElement-impl.js":"\"use strict\";\nconst vm = require(\"vm\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\nconst resourceLoader = require(\"../../browser/resource-loader\");\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst nodeTypes = require(\"../node-type\");\n\nconst jsMIMETypes = new Set([\n  \"application/ecmascript\",\n  \"application/javascript\",\n  \"application/x-ecmascript\",\n  \"application/x-javascript\",\n  \"text/ecmascript\",\n  \"text/javascript\",\n  \"text/javascript1.0\",\n  \"text/javascript1.1\",\n  \"text/javascript1.2\",\n  \"text/javascript1.3\",\n  \"text/javascript1.4\",\n  \"text/javascript1.5\",\n  \"text/jscript\",\n  \"text/livescript\",\n  \"text/x-ecmascript\",\n  \"text/x-javascript\"\n]);\n\nclass HTMLScriptElementImpl extends HTMLElementImpl {\n  _attach() {\n    super._attach();\n    if (this.src) {\n      resourceLoader.load(\n        this,\n        this.src,\n        { defaultEncoding: whatwgEncoding.labelToName(this.getAttribute(\"charset\")) || this._ownerDocument._encoding },\n        this._eval\n      );\n    } else if (this.text.trim().length > 0) {\n      resourceLoader.enqueue(this, this._ownerDocument.URL, this._eval)(null, this.text);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    super._attrModified(name, value, oldValue);\n\n    if (this._attached && name === \"src\" && oldValue === null && value !== null) {\n      resourceLoader.load(\n        this,\n        this.src,\n        { defaultEncoding: whatwgEncoding.labelToName(this.getAttribute(\"charset\")) || this._ownerDocument._encoding },\n        this._eval\n      );\n    }\n  }\n\n  _eval(text, filename) {\n    const typeString = this._getTypeString();\n\n    if (this._ownerDocument.implementation._hasFeature(\"ProcessExternalResources\", \"script\") &&\n        jsMIMETypes.has(typeString.toLowerCase())) {\n      this._ownerDocument._writeAfterElement = this;\n      processJavaScript(this, text, filename);\n      delete this._ownerDocument._writeAfterElement;\n    }\n  }\n\n  _getTypeString() {\n    const typeAttr = this.getAttribute(\"type\");\n    const langAttr = this.getAttribute(\"language\");\n\n    if (typeAttr === \"\") {\n      return \"text/javascript\";\n    }\n\n    if (typeAttr === null && langAttr === \"\") {\n      return \"text/javascript\";\n    }\n\n    if (typeAttr === null && langAttr === null) {\n      return \"text/javascript\";\n    }\n\n    if (typeAttr !== null) {\n      return typeAttr.trim();\n    }\n\n    if (langAttr !== null) {\n      return \"text/\" + langAttr;\n    }\n\n    return null;\n  }\n\n  get text() {\n    let text = \"\";\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.nodeType === nodeTypes.TEXT_NODE) {\n        text += child.nodeValue;\n      }\n    }\n    return text;\n  }\n\n  set text(text) {\n    this.textContent = text;\n  }\n\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n\n  set src(V) {\n    this.setAttribute(\"src\", V);\n  }\n}\n\nfunction processJavaScript(element, code, filename) {\n  const document = element.ownerDocument;\n  const window = document && document._global;\n\n  if (window) {\n    document._currentScript = element;\n\n    try {\n      vm.runInContext(code, window, { filename, displayErrors: false });\n    } catch (e) {\n      reportException(window, e, filename);\n    } finally {\n      document._currentScript = null;\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLScriptElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLSelectElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLSelectElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLSelectElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLSelectElement.prototype.constructor = HTMLSelectElement;\n\n\nHTMLSelectElement.prototype.add = function add(element) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'add' on 'HTMLSelectElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[1] === null || args[1] === undefined) {\n    args[1] = null;\n  } else {\n  }\n  return this[impl].add.apply(this[impl], args);\n};\n\nHTMLSelectElement.prototype.remove = function remove() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].remove.apply(this[impl], args);\n};\n\nHTMLSelectElement.prototype.toString = function () {\n  if (this === HTMLSelectElement.prototype) {\n    return \"[object HTMLSelectElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLSelectElement.prototype, \"autofocus\", {\n  get() {\n    return this.hasAttribute(\"autofocus\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"autofocus\", \"\");\n  } else {\n    this.removeAttribute(\"autofocus\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"disabled\", {\n  get() {\n    return this.hasAttribute(\"disabled\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"disabled\", \"\");\n  } else {\n    this.removeAttribute(\"disabled\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"multiple\", {\n  get() {\n    return this.hasAttribute(\"multiple\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"multiple\", \"\");\n  } else {\n    this.removeAttribute(\"multiple\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"required\", {\n  get() {\n    return this.hasAttribute(\"required\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"required\", \"\");\n  } else {\n    this.removeAttribute(\"required\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"size\", {\n  get() {\n    return this[impl].size;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].size = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"type\", {\n  get() {\n    return this[impl].type;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"options\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].options);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"length\", {\n  get() {\n    return this[impl].length;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].length = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"selectedIndex\", {\n  get() {\n    return this[impl].selectedIndex;\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this[impl].selectedIndex = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSelectElement.prototype, \"value\", {\n  get() {\n    return this[impl].value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].value = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLSelectElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLSelectElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLSelectElement,\n  expose: {\n    Window: { HTMLSelectElement: HTMLSelectElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLSelectElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLSelectElement-impl.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst NODE_TYPE = require(\"../node-type\");\nconst createHTMLCollection = require(\"../html-collection\").create;\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst descendantsByHTMLLocalName = require(\"../helpers/traversal\").descendantsByHTMLLocalName;\nconst closest = require(\"../helpers/traversal\").closest;\n\nclass HTMLSelectElementImpl extends HTMLElementImpl {\n  _formReset() {\n    Array.prototype.forEach.call(this.options, option => {\n      const optionImpl = idlUtils.implForWrapper(option);\n      optionImpl._selectedness = option.defaultSelected;\n      optionImpl._dirtyness = false;\n    });\n    this._askedForAReset();\n  }\n\n  _askedForAReset() {\n    if (this.hasAttribute(\"multiple\")) {\n      return;\n    }\n\n    const selected = Array.prototype.filter.call(this.options, option => {\n      option = idlUtils.implForWrapper(option);\n      return option._selectedness;\n    });\n\n    // size = 1 is default if not multiple\n    if ((!this.size || this.size === 1) && !selected.length) {\n      // select the first option that is not disabled\n      for (let i = 0; i < this.options.length; ++i) {\n        const option = idlUtils.implForWrapper(this.options[i]);\n        let disabled = this.options[i].disabled;\n        const parentNode = domSymbolTree.parent(option);\n        if (parentNode &&\n            parentNode.nodeName.toUpperCase() === \"OPTGROUP\" &&\n            idlUtils.wrapperForImpl(parentNode).disabled) {\n          disabled = true;\n        }\n\n        if (!disabled) {\n          // (do not set dirty)\n          option._selectedness = true;\n          break;\n        }\n      }\n    } else if (selected.length >= 2) {\n      // select the last selected option\n      selected.forEach((option, index) => {\n        option = idlUtils.implForWrapper(option);\n        option._selectedness = index === selected.length - 1;\n      });\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    if (child.nodeType === NODE_TYPE.ELEMENT_NODE) {\n      this._askedForAReset();\n    }\n\n    super._descendantAdded.apply(this, arguments);\n  }\n\n  _descendantRemoved(parent, child) {\n    if (child.nodeType === NODE_TYPE.ELEMENT_NODE) {\n      this._askedForAReset();\n    }\n\n    super._descendantRemoved.apply(this, arguments);\n  }\n\n  _attrModified(name) {\n    if (name === \"multiple\" || name === \"size\") {\n      this._askedForAReset();\n    }\n    super._attrModified.apply(this, arguments);\n  }\n\n  get options() {\n    // TODO: implement HTMLOptionsCollection\n    return createHTMLCollection(this, () => descendantsByHTMLLocalName(this, \"option\"));\n  }\n\n  get length() {\n    return this.options.length;\n  }\n\n  get selectedIndex() {\n    return Array.prototype.reduceRight.call(this.options, (prev, option, i) => {\n      option = idlUtils.implForWrapper(option);\n      return option.selected ? i : prev;\n    }, -1);\n  }\n\n  set selectedIndex(index) {\n    Array.prototype.forEach.call(this.options, (option, i) => {\n      option = idlUtils.implForWrapper(option);\n      option.selected = i === index;\n    });\n  }\n\n  get value() {\n    let i = this.selectedIndex;\n    if (this.options.length && (i === -1)) {\n      i = 0;\n    }\n    if (i === -1) {\n      return \"\";\n    }\n    return this.options[i].value;\n  }\n\n  set value(val) {\n    const self = this;\n    Array.prototype.forEach.call(this.options, option => {\n      option = idlUtils.implForWrapper(option);\n      if (option.value === val) {\n        option.selected = true;\n      } else if (!self.hasAttribute(\"multiple\")) {\n        // Remove the selected bit from all other options in this group\n        // if the multiple attr is not present on the select\n        option.selected = false;\n      }\n    });\n  }\n\n  get form() {\n    return closest(this, \"form\");\n  }\n\n  get type() {\n    return this.hasAttribute(\"multiple\") ? \"select-multiple\" : \"select-one\";\n  }\n\n  add(opt, before) {\n    if (before) {\n      this.insertBefore(opt, before);\n    } else {\n      this.appendChild(opt);\n    }\n  }\n\n  remove(index) {\n    const opts = this.options;\n    if (index >= 0 && index < opts.length) {\n      const el = idlUtils.implForWrapper(opts[index]);\n      domSymbolTree.parent(el).removeChild(el);\n    }\n  }\n\n  get size() {\n    if (!this.hasAttribute(\"size\")) {\n      return 0;\n    }\n    const size = conversions[\"unsigned long\"](this.getAttribute(\"size\"));\n    if (isNaN(size)) {\n      return 0;\n    }\n    return size;\n  }\n\n  set size(V) {\n    this.setAttribute(\"size\", V);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLSelectElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLSourceElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLSourceElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLSourceElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLSourceElement.prototype.constructor = HTMLSourceElement;\n\n\nHTMLSourceElement.prototype.toString = function () {\n  if (this === HTMLSourceElement.prototype) {\n    return \"[object HTMLSourceElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLSourceElement.prototype, \"src\", {\n  get() {\n    return this[impl].src;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].src = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSourceElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSourceElement.prototype, \"srcset\", {\n  get() {\n    const value = this.getAttribute(\"srcset\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"srcset\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSourceElement.prototype, \"sizes\", {\n  get() {\n    const value = this.getAttribute(\"sizes\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"sizes\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLSourceElement.prototype, \"media\", {\n  get() {\n    const value = this.getAttribute(\"media\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"media\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLSourceElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLSourceElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLSourceElement,\n  expose: {\n    Window: { HTMLSourceElement: HTMLSourceElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLSourceElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLSourceElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\n\nclass HTMLSourceElementImpl extends HTMLElementImpl {\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n\n  set src(value) {\n    this.setAttribute(\"src\", value);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLSourceElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLSpanElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLSpanElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLSpanElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLSpanElement.prototype.constructor = HTMLSpanElement;\n\n\nHTMLSpanElement.prototype.toString = function () {\n  if (this === HTMLSpanElement.prototype) {\n    return \"[object HTMLSpanElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLSpanElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLSpanElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLSpanElement,\n  expose: {\n    Window: { HTMLSpanElement: HTMLSpanElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLSpanElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLSpanElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLSpanElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLSpanElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLStyleElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst LinkStyle = require(\"./LinkStyle.js\");\n\nfunction HTMLStyleElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLStyleElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLStyleElement.prototype.constructor = HTMLStyleElement;\n\nmixin(HTMLStyleElement.prototype, LinkStyle.interface.prototype);\nLinkStyle.mixedInto.push(HTMLStyleElement);\n\nHTMLStyleElement.prototype.toString = function () {\n  if (this === HTMLStyleElement.prototype) {\n    return \"[object HTMLStyleElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLStyleElement.prototype, \"media\", {\n  get() {\n    const value = this.getAttribute(\"media\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"media\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLStyleElement.prototype, \"nonce\", {\n  get() {\n    const value = this.getAttribute(\"nonce\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"nonce\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLStyleElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLStyleElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLStyleElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLStyleElement,\n  expose: {\n    Window: { HTMLStyleElement: HTMLStyleElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLStyleElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLStyleElement-impl.js":"\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst LinkStyleImpl = require(\"./LinkStyle-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst NODE_TYPE = require(\"../node-type\");\nconst evaluateStylesheet = require(\"../helpers/stylesheets\").evaluateStylesheet;\nconst documentBaseURL = require(\"../helpers/document-base-url\").documentBaseURL;\n\nclass HTMLStyleElementImpl extends HTMLElementImpl {\n  _attach() {\n    if (this.type && this.type !== \"text/css\") {\n      return;\n    }\n\n    let content = \"\";\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.nodeType === NODE_TYPE.TEXT_NODE) {\n        content += child.nodeValue;\n      }\n    }\n\n    evaluateStylesheet(this, content, this.sheet, documentBaseURL(this._ownerDocument));\n\n    super._attach();\n  }\n}\n\nidlUtils.mixin(HTMLStyleElementImpl.prototype, LinkStyleImpl.prototype);\n\nmodule.exports = {\n  implementation: HTMLStyleElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTableCaptionElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTableCaptionElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTableCaptionElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTableCaptionElement.prototype.constructor = HTMLTableCaptionElement;\n\n\nHTMLTableCaptionElement.prototype.toString = function () {\n  if (this === HTMLTableCaptionElement.prototype) {\n    return \"[object HTMLTableCaptionElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTableCaptionElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableCaptionElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableCaptionElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTableCaptionElement,\n  expose: {\n    Window: { HTMLTableCaptionElement: HTMLTableCaptionElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTableCaptionElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTableCaptionElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLTableCaptionElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLTableCaptionElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTableCellElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTableCellElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTableCellElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTableCellElement.prototype.constructor = HTMLTableCellElement;\n\n\nHTMLTableCellElement.prototype.toString = function () {\n  if (this === HTMLTableCellElement.prototype) {\n    return \"[object HTMLTableCellElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTableCellElement.prototype, \"colSpan\", {\n  get() {\n    return this[impl].colSpan;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].colSpan = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"rowSpan\", {\n  get() {\n    return this[impl].rowSpan;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].rowSpan = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"headers\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].headers);\n  },\n  set(V) {\n    this.headers.value = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"cellIndex\", {\n  get() {\n    return this[impl].cellIndex;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"axis\", {\n  get() {\n    const value = this.getAttribute(\"axis\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"axis\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"height\", {\n  get() {\n    const value = this.getAttribute(\"height\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"height\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"width\", {\n  get() {\n    const value = this.getAttribute(\"width\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"width\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"ch\", {\n  get() {\n    const value = this.getAttribute(\"char\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"char\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"chOff\", {\n  get() {\n    const value = this.getAttribute(\"charoff\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"charoff\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"noWrap\", {\n  get() {\n    return this.hasAttribute(\"noWrap\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"noWrap\", \"\");\n  } else {\n    this.removeAttribute(\"noWrap\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"vAlign\", {\n  get() {\n    const value = this.getAttribute(\"vAlign\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"vAlign\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableCellElement.prototype, \"bgColor\", {\n  get() {\n    const value = this.getAttribute(\"bgColor\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"bgColor\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableCellElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableCellElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTableCellElement,\n  expose: {\n    Window: { HTMLTableCellElement: HTMLTableCellElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTableCellElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTableCellElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\n\nconst closest = require(\"../helpers/traversal\").closest;\nconst createDOMTokenList = require(\"../dom-token-list\").create;\nconst resetDOMTokenList = require(\"../dom-token-list\").reset;\n\nclass HTMLTableCellImpl extends HTMLElementImpl {\n  get headers() {\n    if (this._headers === undefined) {\n      this._headers = createDOMTokenList(this, \"headers\");\n    }\n    return this._headers;\n  }\n\n  get cellIndex() {\n    const tr = closest(this, \"tr\");\n    if (tr === null) {\n      return -1;\n    }\n\n    return Array.prototype.indexOf.call(tr.cells, idlUtils.wrapperForImpl(this));\n  }\n\n  get colSpan() {\n    const value = this.getAttribute(\"colspan\");\n    return value === null ? 1 : value;\n  }\n\n  set colSpan(V) {\n    this.setAttribute(\"colspan\", String(V));\n  }\n\n  get rowSpan() {\n    const value = this.getAttribute(\"rowspan\");\n    return value === null ? 1 : value;\n  }\n\n  set rowSpan(V) {\n    this.setAttribute(\"rowspan\", String(V));\n  }\n\n  _attrModified(name, value, oldValue) {\n    if (name === \"headers\" && this._headers) {\n      resetDOMTokenList(this._headers, value);\n    }\n\n    super._attrModified(name, value, oldValue);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLTableCellImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTableColElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTableColElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTableColElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTableColElement.prototype.constructor = HTMLTableColElement;\n\n\nHTMLTableColElement.prototype.toString = function () {\n  if (this === HTMLTableColElement.prototype) {\n    return \"[object HTMLTableColElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTableColElement.prototype, \"span\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"span\"));\n    return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    V = V > 2147483647 ? 0 : V;\n    this.setAttribute(\"span\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableColElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableColElement.prototype, \"ch\", {\n  get() {\n    const value = this.getAttribute(\"char\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"char\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableColElement.prototype, \"chOff\", {\n  get() {\n    const value = this.getAttribute(\"charoff\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"charoff\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableColElement.prototype, \"vAlign\", {\n  get() {\n    const value = this.getAttribute(\"vAlign\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"vAlign\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableColElement.prototype, \"width\", {\n  get() {\n    const value = this.getAttribute(\"width\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"width\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableColElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableColElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTableColElement,\n  expose: {\n    Window: { HTMLTableColElement: HTMLTableColElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTableColElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTableColElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLTableColElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLTableColElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTableDataCellElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLTableCellElement = require(\"./HTMLTableCellElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTableDataCellElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTableDataCellElement.prototype = Object.create(HTMLTableCellElement.interface.prototype);\nHTMLTableDataCellElement.prototype.constructor = HTMLTableDataCellElement;\n\n\nHTMLTableDataCellElement.prototype.toString = function () {\n  if (this === HTMLTableDataCellElement.prototype) {\n    return \"[object HTMLTableDataCellElementPrototype]\";\n  }\n  return HTMLTableCellElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTableDataCellElement.prototype, \"abbr\", {\n  get() {\n    const value = this.getAttribute(\"abbr\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"abbr\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableDataCellElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableDataCellElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLTableCellElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTableDataCellElement,\n  expose: {\n    Window: { HTMLTableDataCellElement: HTMLTableDataCellElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTableDataCellElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTableDataCellElement-impl.js":"\"use strict\";\n\nconst HTMLTableCellElementImpl = require(\"./HTMLTableCellElement-impl\").implementation;\n\nclass HTMLTableDataCellElementImpl extends HTMLTableCellElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLTableDataCellElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTableElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTableElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTableElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTableElement.prototype.constructor = HTMLTableElement;\n\n\nHTMLTableElement.prototype.createCaption = function createCaption() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].createCaption.apply(this[impl], args));\n};\n\nHTMLTableElement.prototype.deleteCaption = function deleteCaption() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].deleteCaption.apply(this[impl], args);\n};\n\nHTMLTableElement.prototype.createTHead = function createTHead() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].createTHead.apply(this[impl], args));\n};\n\nHTMLTableElement.prototype.deleteTHead = function deleteTHead() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].deleteTHead.apply(this[impl], args);\n};\n\nHTMLTableElement.prototype.createTFoot = function createTFoot() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].createTFoot.apply(this[impl], args));\n};\n\nHTMLTableElement.prototype.deleteTFoot = function deleteTFoot() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].deleteTFoot.apply(this[impl], args);\n};\n\nHTMLTableElement.prototype.insertRow = function insertRow() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"long\"](args[0]);\n  } else {\n    args[0] = -1;\n  }\n  return utils.tryWrapperForImpl(this[impl].insertRow.apply(this[impl], args));\n};\n\nHTMLTableElement.prototype.deleteRow = function deleteRow(index) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'deleteRow' on 'HTMLTableElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"long\"](args[0]);\n  return this[impl].deleteRow.apply(this[impl], args);\n};\n\nHTMLTableElement.prototype.toString = function () {\n  if (this === HTMLTableElement.prototype) {\n    return \"[object HTMLTableElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTableElement.prototype, \"caption\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].caption);\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    }\n    this[impl].caption = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"tHead\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].tHead);\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    }\n    this[impl].tHead = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"tFoot\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].tFoot);\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    }\n    this[impl].tFoot = utils.tryImplForWrapper(V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"tBodies\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].tBodies);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"rows\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].rows);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"border\", {\n  get() {\n    const value = this.getAttribute(\"border\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"border\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"frame\", {\n  get() {\n    const value = this.getAttribute(\"frame\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"frame\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"rules\", {\n  get() {\n    const value = this.getAttribute(\"rules\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"rules\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"summary\", {\n  get() {\n    const value = this.getAttribute(\"summary\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"summary\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"width\", {\n  get() {\n    const value = this.getAttribute(\"width\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"width\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"bgColor\", {\n  get() {\n    const value = this.getAttribute(\"bgColor\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"bgColor\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"cellPadding\", {\n  get() {\n    const value = this.getAttribute(\"cellPadding\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"cellPadding\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableElement.prototype, \"cellSpacing\", {\n  get() {\n    const value = this.getAttribute(\"cellSpacing\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"cellSpacing\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTableElement,\n  expose: {\n    Window: { HTMLTableElement: HTMLTableElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTableElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTableElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nconst firstChildWithHTMLLocalName = require(\"../helpers/traversal\").firstChildWithHTMLLocalName;\nconst childrenByHTMLLocalName = require(\"../helpers/traversal\").childrenByHTMLLocalName;\nconst createHTMLCollection = require(\"../../living/html-collection\").create;\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst idlUtils = require(\"../generated/utils\");\n\nclass HTMLTableElementImpl extends HTMLElementImpl {\n  get caption() {\n    return firstChildWithHTMLLocalName(this, \"caption\");\n  }\n\n  get tHead() {\n    return firstChildWithHTMLLocalName(this, \"thead\");\n  }\n\n  get tFoot() {\n    return firstChildWithHTMLLocalName(this, \"tfoot\");\n  }\n\n  get rows() {\n    if (!this._rows) {\n      this._rows = createHTMLCollection(this, () => {\n        const sections = [];\n        if (this.tHead) {\n          sections.push(this.tHead);\n        }\n        sections.push.apply(sections, childrenByHTMLLocalName(this, \"tbody\"));\n        if (this.tFoot) {\n          sections.push(this.tFoot);\n        }\n\n        if (sections.length === 0) {\n          return childrenByHTMLLocalName(this, \"tr\");\n        }\n\n        const rows = [];\n        for (const s of sections) {\n          rows.push.apply(rows, childrenByHTMLLocalName(s, \"tr\"));\n        }\n        return rows;\n      });\n    }\n    return this._rows;\n  }\n\n  get tBodies() {\n    if (!this._tBodies) {\n      this._tBodies = createHTMLCollection(this, () => childrenByHTMLLocalName(this, \"tbody\"));\n    }\n    return this._tBodies;\n  }\n\n  createTHead() {\n    let el = this.tHead;\n    if (!el) {\n      el = this._ownerDocument.createElement(\"THEAD\");\n      this.appendChild(el);\n    }\n    return el;\n  }\n\n  deleteTHead() {\n    const el = this.tHead;\n    if (el) {\n      el.parentNode.removeChild(el);\n    }\n  }\n\n  createTFoot() {\n    let el = this.tFoot;\n    if (!el) {\n      el = this._ownerDocument.createElement(\"TFOOT\");\n      this.appendChild(el);\n    }\n    return el;\n  }\n\n  deleteTFoot() {\n    const el = this.tFoot;\n    if (el) {\n      el.parentNode.removeChild(el);\n    }\n  }\n\n  createCaption() {\n    let el = this.caption;\n    if (!el) {\n      el = this._ownerDocument.createElement(\"CAPTION\");\n      this.appendChild(el);\n    }\n    return el;\n  }\n\n  deleteCaption() {\n    const c = this.caption;\n    if (c) {\n      c.parentNode.removeChild(c);\n    }\n  }\n\n  insertRow(index) {\n    if (index < -1 || index > this.rows.length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR,\n        \"Cannot insert a row at an index that is less than -1 or greater than the number of existing rows\");\n    }\n\n    const tr = this._ownerDocument.createElement(\"tr\");\n\n    if (this.rows.length === 0 && this.tBodies.length === 0) {\n      const tBody = this._ownerDocument.createElement(\"tbody\");\n      tBody.appendChild(tr);\n      this.appendChild(tBody);\n    } else if (this.rows.length === 0) {\n      const tBody = idlUtils.implForWrapper(this.tBodies[this.tBodies.length - 1]);\n      tBody.appendChild(tr);\n    } else if (index === -1 || index === this.rows.length) {\n      const tSection = idlUtils.implForWrapper(this.rows[this.rows.length - 1]).parentNode;\n      tSection.appendChild(tr);\n    } else {\n      const beforeTR = idlUtils.implForWrapper(this.rows[index]);\n      const tSection = beforeTR.parentNode;\n      tSection.insertBefore(tr, beforeTR);\n    }\n\n    return tr;\n  }\n\n  deleteRow(index) {\n    if (index === -1) {\n      index = this.rows.length - 1;\n    }\n\n    if (index < 0 || index >= this.rows.length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR, `Cannot delete a row at index ${index}, where no row exists`);\n    }\n\n    const tr = idlUtils.implForWrapper(this.rows[index]);\n    tr.parentNode.removeChild(tr);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLTableElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTableHeaderCellElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLTableCellElement = require(\"./HTMLTableCellElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTableHeaderCellElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTableHeaderCellElement.prototype = Object.create(HTMLTableCellElement.interface.prototype);\nHTMLTableHeaderCellElement.prototype.constructor = HTMLTableHeaderCellElement;\n\n\nHTMLTableHeaderCellElement.prototype.toString = function () {\n  if (this === HTMLTableHeaderCellElement.prototype) {\n    return \"[object HTMLTableHeaderCellElementPrototype]\";\n  }\n  return HTMLTableCellElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTableHeaderCellElement.prototype, \"scope\", {\n  get() {\n    const value = this.getAttribute(\"scope\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"scope\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableHeaderCellElement.prototype, \"abbr\", {\n  get() {\n    const value = this.getAttribute(\"abbr\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"abbr\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableHeaderCellElement.prototype, \"sorted\", {\n  get() {\n    const value = this.getAttribute(\"sorted\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"sorted\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableHeaderCellElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableHeaderCellElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLTableCellElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTableHeaderCellElement,\n  expose: {\n    Window: { HTMLTableHeaderCellElement: HTMLTableHeaderCellElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTableHeaderCellElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTableHeaderCellElement-impl.js":"\"use strict\";\n\nconst HTMLTableCellElementImpl = require(\"./HTMLTableCellElement-impl\").implementation;\n\nclass HTMLTableHeaderCellElementImpl extends HTMLTableCellElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLTableHeaderCellElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTimeElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTimeElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTimeElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTimeElement.prototype.constructor = HTMLTimeElement;\n\n\nHTMLTimeElement.prototype.toString = function () {\n  if (this === HTMLTimeElement.prototype) {\n    return \"[object HTMLTimeElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTimeElement.prototype, \"dateTime\", {\n  get() {\n    const value = this.getAttribute(\"dateTime\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"dateTime\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTimeElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTimeElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTimeElement,\n  expose: {\n    Window: { HTMLTimeElement: HTMLTimeElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTimeElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTimeElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLTimeElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLTimeElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTitleElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTitleElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTitleElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTitleElement.prototype.constructor = HTMLTitleElement;\n\n\nHTMLTitleElement.prototype.toString = function () {\n  if (this === HTMLTitleElement.prototype) {\n    return \"[object HTMLTitleElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTitleElement.prototype, \"text\", {\n  get() {\n    return this[impl].text;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].text = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTitleElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTitleElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTitleElement,\n  expose: {\n    Window: { HTMLTitleElement: HTMLTitleElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTitleElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTitleElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLTitleElementImpl extends HTMLElementImpl {\n  get text() {\n    // TODO this is quite incorrect\n    return this.innerHTML;\n  }\n\n  set text(s) {\n    this.textContent = s;\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLTitleElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTableRowElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTableRowElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTableRowElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTableRowElement.prototype.constructor = HTMLTableRowElement;\n\n\nHTMLTableRowElement.prototype.insertCell = function insertCell() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"long\"](args[0]);\n  } else {\n    args[0] = -1;\n  }\n  return utils.tryWrapperForImpl(this[impl].insertCell.apply(this[impl], args));\n};\n\nHTMLTableRowElement.prototype.deleteCell = function deleteCell(index) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'deleteCell' on 'HTMLTableRowElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"long\"](args[0]);\n  return this[impl].deleteCell.apply(this[impl], args);\n};\n\nHTMLTableRowElement.prototype.toString = function () {\n  if (this === HTMLTableRowElement.prototype) {\n    return \"[object HTMLTableRowElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTableRowElement.prototype, \"rowIndex\", {\n  get() {\n    return this[impl].rowIndex;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableRowElement.prototype, \"sectionRowIndex\", {\n  get() {\n    return this[impl].sectionRowIndex;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableRowElement.prototype, \"cells\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].cells);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableRowElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableRowElement.prototype, \"ch\", {\n  get() {\n    const value = this.getAttribute(\"char\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"char\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableRowElement.prototype, \"chOff\", {\n  get() {\n    const value = this.getAttribute(\"charoff\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"charoff\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableRowElement.prototype, \"vAlign\", {\n  get() {\n    const value = this.getAttribute(\"vAlign\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"vAlign\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableRowElement.prototype, \"bgColor\", {\n  get() {\n    const value = this.getAttribute(\"bgColor\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this.setAttribute(\"bgColor\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableRowElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableRowElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTableRowElement,\n  expose: {\n    Window: { HTMLTableRowElement: HTMLTableRowElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTableRowElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTableRowElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst createHTMLCollection = require(\"../../living/html-collection\").create;\nconst childrenByHTMLLocalNames = require(\"../helpers/traversal\").childrenByHTMLLocalNames;\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst closest = require(\"../helpers/traversal\").closest;\n\nconst cellLocalNames = new Set([\"td\", \"th\"]);\n\nclass HTMLTableRowElementImpl extends HTMLElementImpl {\n  get cells() {\n    if (!this._cells) {\n      this._cells = createHTMLCollection(this, () => childrenByHTMLLocalNames(this, cellLocalNames));\n    }\n    return this._cells;\n  }\n\n  get rowIndex() {\n    const table = closest(this, \"table\");\n    return table ? Array.prototype.indexOf.call(table.rows, idlUtils.wrapperForImpl(this)) : -1;\n  }\n\n  get sectionRowIndex() {\n    const parent = domSymbolTree.parent(this);\n    if (parent === null) {\n      return -1;\n    }\n\n    const rows = parent.rows;\n    if (!rows) {\n      return -1;\n    }\n\n    return Array.prototype.indexOf.call(rows, idlUtils.wrapperForImpl(this));\n  }\n\n  insertCell(index) {\n    const td = this._ownerDocument.createElement(\"TD\");\n    const cells = this.cells;\n    if (index < -1 || index > cells.length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n    if (index === -1 || index === cells.length) {\n      this.appendChild(td);\n    } else {\n      const ref = idlUtils.implForWrapper(cells[index]);\n      this.insertBefore(td, ref);\n    }\n    return td;\n  }\n\n  deleteCell(index) {\n    const cells = this.cells;\n    if (index === -1) {\n      index = cells.length - 1;\n    }\n    if (index < 0 || index >= cells.length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n    const td = idlUtils.implForWrapper(cells[index]);\n    this.removeChild(td);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLTableRowElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTableSectionElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTableSectionElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTableSectionElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTableSectionElement.prototype.constructor = HTMLTableSectionElement;\n\n\nHTMLTableSectionElement.prototype.insertRow = function insertRow() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"long\"](args[0]);\n  } else {\n    args[0] = -1;\n  }\n  return utils.tryWrapperForImpl(this[impl].insertRow.apply(this[impl], args));\n};\n\nHTMLTableSectionElement.prototype.deleteRow = function deleteRow(index) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'deleteRow' on 'HTMLTableSectionElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"long\"](args[0]);\n  return this[impl].deleteRow.apply(this[impl], args);\n};\n\nHTMLTableSectionElement.prototype.toString = function () {\n  if (this === HTMLTableSectionElement.prototype) {\n    return \"[object HTMLTableSectionElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTableSectionElement.prototype, \"rows\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].rows);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableSectionElement.prototype, \"align\", {\n  get() {\n    const value = this.getAttribute(\"align\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"align\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableSectionElement.prototype, \"ch\", {\n  get() {\n    const value = this.getAttribute(\"char\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"char\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableSectionElement.prototype, \"chOff\", {\n  get() {\n    const value = this.getAttribute(\"charoff\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"charoff\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTableSectionElement.prototype, \"vAlign\", {\n  get() {\n    const value = this.getAttribute(\"vAlign\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"vAlign\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableSectionElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTableSectionElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTableSectionElement,\n  expose: {\n    Window: { HTMLTableSectionElement: HTMLTableSectionElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTableSectionElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTableSectionElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst childrenByHTMLLocalName = require(\"../helpers/traversal\").childrenByHTMLLocalName;\nconst createHTMLCollection = require(\"../../living/html-collection\").create;\nconst DOMException = require(\"../../web-idl/DOMException\");\n\nclass HTMLTableSectionElementImpl extends HTMLElementImpl {\n  get rows() {\n    if (!this._rows) {\n      this._rows = createHTMLCollection(this, () => childrenByHTMLLocalName(this, \"tr\"));\n    }\n    return this._rows;\n  }\n\n  insertRow(index) {\n    if (index < -1 || index > this.rows.length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR,\n        \"Cannot insert a row at an index that is less than -1 or greater than the number of existing rows\");\n    }\n\n    const tr = this._ownerDocument.createElement(\"tr\");\n\n    if (index === -1 || index === this.rows.length) {\n      this.appendChild(tr);\n    } else {\n      const beforeTR = idlUtils.implForWrapper(this.rows[index]);\n      this.insertBefore(tr, beforeTR);\n    }\n\n    return tr;\n  }\n\n  deleteRow(index) {\n    if (index < -1 || index >= this.rows.length) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR, `Cannot delete a row at index ${index}, where no row exists`);\n    }\n\n    if (index === -1) {\n      if (this.rows.length > 0) {\n        const tr = idlUtils.implForWrapper(this.rows[this.rows.length - 1]);\n        this.removeChild(tr);\n      }\n    } else {\n      const tr = idlUtils.implForWrapper(this.rows[index]);\n      this.removeChild(tr);\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLTableSectionElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTemplateElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTemplateElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTemplateElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTemplateElement.prototype.constructor = HTMLTemplateElement;\n\n\nHTMLTemplateElement.prototype.toString = function () {\n  if (this === HTMLTemplateElement.prototype) {\n    return \"[object HTMLTemplateElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTemplateElement.prototype, \"content\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].content);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTemplateElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTemplateElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTemplateElement,\n  expose: {\n    Window: { HTMLTemplateElement: HTMLTemplateElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTemplateElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTemplateElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nconst cloningSteps = require(\"../helpers/internal-constants\").cloningSteps;\nconst clone = require(\"../node\").clone;\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\n\nclass HTMLTemplateElementImpl extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n    this._templateContents = this._ownerDocument.createDocumentFragment();\n  }\n\n  get content() {\n    return this._templateContents;\n  }\n\n  [cloningSteps](copy, node, document, cloneChildren) {\n    if (!cloneChildren) {\n      return;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(node._templateContents)) {\n      const childCopy = clone(this._core, child, copy._templateContents._ownerDocument, true);\n      copy._templateContents.appendChild(childCopy);\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLTemplateElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTextAreaElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTextAreaElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTextAreaElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTextAreaElement.prototype.constructor = HTMLTextAreaElement;\n\n\nHTMLTextAreaElement.prototype.select = function select() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].select.apply(this[impl], args);\n};\n\nHTMLTextAreaElement.prototype.setRangeText = function setRangeText(replacement) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'setRangeText' on 'HTMLTextAreaElement': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 4; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  return this[impl].setRangeText.apply(this[impl], args);\n};\n\nHTMLTextAreaElement.prototype.setSelectionRange = function setSelectionRange(start, end) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'setSelectionRange' on 'HTMLTextAreaElement': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"unsigned long\"](args[0]);\n  args[1] = conversions[\"unsigned long\"](args[1]);\n  if (args[2] !== undefined) {\n  args[2] = conversions[\"DOMString\"](args[2]);\n  }\n  return this[impl].setSelectionRange.apply(this[impl], args);\n};\n\nHTMLTextAreaElement.prototype.toString = function () {\n  if (this === HTMLTextAreaElement.prototype) {\n    return \"[object HTMLTextAreaElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTextAreaElement.prototype, \"autocomplete\", {\n  get() {\n    const value = this.getAttribute(\"autocomplete\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"autocomplete\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"autofocus\", {\n  get() {\n    return this.hasAttribute(\"autofocus\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"autofocus\", \"\");\n  } else {\n    this.removeAttribute(\"autofocus\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"cols\", {\n  get() {\n    return this[impl].cols;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].cols = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"dirName\", {\n  get() {\n    const value = this.getAttribute(\"dirName\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"dirName\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"disabled\", {\n  get() {\n    return this.hasAttribute(\"disabled\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"disabled\", \"\");\n  } else {\n    this.removeAttribute(\"disabled\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"form\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].form);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"inputMode\", {\n  get() {\n    const value = this.getAttribute(\"inputMode\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"inputMode\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"maxLength\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"maxLength\"));\n    return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this.setAttribute(\"maxLength\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"minLength\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"minLength\"));\n    return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"long\"](V);\n    this.setAttribute(\"minLength\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"name\", {\n  get() {\n    const value = this.getAttribute(\"name\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"name\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"placeholder\", {\n  get() {\n    const value = this.getAttribute(\"placeholder\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"placeholder\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"readOnly\", {\n  get() {\n    return this.hasAttribute(\"readOnly\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"readOnly\", \"\");\n  } else {\n    this.removeAttribute(\"readOnly\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"required\", {\n  get() {\n    return this.hasAttribute(\"required\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"required\", \"\");\n  } else {\n    this.removeAttribute(\"required\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"rows\", {\n  get() {\n    return this[impl].rows;\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    this[impl].rows = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"wrap\", {\n  get() {\n    const value = this.getAttribute(\"wrap\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"wrap\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"type\", {\n  get() {\n    return this[impl].type;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"defaultValue\", {\n  get() {\n    return this[impl].defaultValue;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].defaultValue = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"value\", {\n  get() {\n    return this[impl].value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].value = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"textLength\", {\n  get() {\n    return this[impl].textLength;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"selectionStart\", {\n  get() {\n    return this[impl].selectionStart;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"unsigned long\"](V);\n    }\n    this[impl].selectionStart = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"selectionEnd\", {\n  get() {\n    return this[impl].selectionEnd;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"unsigned long\"](V);\n    }\n    this[impl].selectionEnd = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTextAreaElement.prototype, \"selectionDirection\", {\n  get() {\n    return this[impl].selectionDirection;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this[impl].selectionDirection = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTextAreaElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTextAreaElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTextAreaElement,\n  expose: {\n    Window: { HTMLTextAreaElement: HTMLTextAreaElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTextAreaElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTextAreaElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst closest = require(\"../helpers/traversal\").closest;\nconst normalizeToCRLF = require(\"../helpers/form-controls\").normalizeToCRLF;\n\nclass HTMLTextAreaElement extends HTMLElementImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._rawValue = \"\";\n    this._dirtyValue = false;\n  }\n\n  _formReset() {\n    this._rawValue = this.textContent;\n    this._dirtyValue = false;\n  }\n\n  _getAPIValue() {\n    return this._rawValue.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n  }\n\n  _getValue() {\n    // Hard-wrapping omitted, for now.\n    return normalizeToCRLF(this._rawValue);\n  }\n\n  _modified() {\n    super._modified();\n\n    if (this._dirtyValue === false) {\n      this._rawValue = this.textContent;\n    }\n  }\n\n  get form() {\n    return closest(this, \"form\");\n  }\n\n  get defaultValue() {\n    return this.textContent;\n  }\n\n  set defaultValue(val) {\n    this.textContent = val;\n  }\n\n  get value() {\n    return this._getAPIValue();\n  }\n\n  set value(val) {\n    this._rawValue = val;\n    this._dirtyValue = true;\n\n    this._selectionStart = 0;\n    this._selectionEnd = 0;\n    this._selectionDirection = \"none\";\n  }\n\n  get textLength() {\n    return this.value.length; // code unit length (16 bit)\n  }\n  get type() {\n    return \"textarea\";\n  }\n\n  _dispatchSelectEvent() {\n    const event = this._ownerDocument.createEvent(\"HTMLEvents\");\n    event.initEvent(\"select\", true, true);\n    this.dispatchEvent(event);\n  }\n  _getValueLength() {\n    return typeof this.value === \"string\" ? this.value.length : 0;\n  }\n  select() {\n    this._selectionStart = 0;\n    this._selectionEnd = this._getValueLength();\n    this._selectionDirection = \"none\";\n    this._dispatchSelectEvent();\n  }\n  get selectionStart() {\n    return this._selectionStart;\n  }\n  set selectionStart(start) {\n    this.setSelectionRange(start, Math.max(start, this._selectionEnd), this._selectionDirection);\n  }\n  get selectionEnd() {\n    return this._selectionEnd;\n  }\n  set selectionEnd(end) {\n    this.setSelectionRange(this._selectionStart, end, this._selectionDirection);\n  }\n  get selectionDirection() {\n    return this._selectionDirection;\n  }\n  set selectionDirection(dir) {\n    this.setSelectionRange(this._selectionStart, this._selectionEnd, dir);\n  }\n  setSelectionRange(start, end, dir) {\n    this._selectionEnd = Math.min(end, this._getValueLength());\n    this._selectionStart = Math.min(start, this._selectionEnd);\n    this._selectionDirection = dir === \"forward\" || dir === \"backward\" ? dir : \"none\";\n    this._dispatchSelectEvent();\n  }\n  setRangeText(repl, start, end, selectionMode) {\n    if (arguments.length < 2) {\n      start = this._selectionStart;\n      end = this._selectionEnd;\n    } else if (start > end) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n\n    start = Math.min(start, this._getValueLength());\n    end = Math.min(end, this._getValueLength());\n\n    const val = this.value;\n    let selStart = this._selectionStart;\n    let selEnd = this._selectionEnd;\n\n    this.value = val.slice(0, start) + repl + val.slice(end);\n\n    const newEnd = start + this.value.length;\n\n    if (selectionMode === \"select\") {\n      this.setSelectionRange(start, newEnd);\n    } else if (selectionMode === \"start\") {\n      this.setSelectionRange(start, start);\n    } else if (selectionMode === \"end\") {\n      this.setSelectionRange(newEnd, newEnd);\n    } else { // preserve\n      const delta = repl.length - (end - start);\n\n      if (selStart > end) {\n        selStart += delta;\n      } else if (selStart > start) {\n        selStart = start;\n      }\n\n      if (selEnd > end) {\n        selEnd += delta;\n      } else if (selEnd > start) {\n        selEnd = newEnd;\n      }\n\n      this.setSelectionRange(selStart, selEnd);\n    }\n  }\n\n  get cols() {\n    if (!this.hasAttribute(\"cols\")) {\n      return 20;\n    }\n    return parseInt(this.getAttribute(\"cols\"));\n  }\n\n  set cols(value) {\n    if (value <= 0) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n    this.setAttribute(\"cols\", String(value));\n  }\n\n  get rows() {\n    if (!this.hasAttribute(\"rows\")) {\n      return 2;\n    }\n    return parseInt(this.getAttribute(\"rows\"));\n  }\n\n  set rows(value) {\n    if (value <= 0) {\n      throw new DOMException(DOMException.INDEX_SIZE_ERR);\n    }\n    this.setAttribute(\"rows\", String(value));\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLTextAreaElement\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLTrackElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLTrackElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLTrackElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLTrackElement.prototype.constructor = HTMLTrackElement;\n\n\nHTMLTrackElement.prototype.toString = function () {\n  if (this === HTMLTrackElement.prototype) {\n    return \"[object HTMLTrackElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLTrackElement.prototype, \"kind\", {\n  get() {\n    const value = this.getAttribute(\"kind\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"kind\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTrackElement.prototype, \"src\", {\n  get() {\n    return this[impl].src;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].src = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTrackElement.prototype, \"srclang\", {\n  get() {\n    const value = this.getAttribute(\"srclang\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"srclang\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTrackElement.prototype, \"label\", {\n  get() {\n    const value = this.getAttribute(\"label\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"label\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTrackElement.prototype, \"default\", {\n  get() {\n    return this.hasAttribute(\"default\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"default\", \"\");\n  } else {\n    this.removeAttribute(\"default\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLTrackElement, \"NONE\", {\n  value: 0,\n  enumerable: true\n});\nObject.defineProperty(HTMLTrackElement.prototype, \"NONE\", {\n  value: 0,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLTrackElement, \"LOADING\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(HTMLTrackElement.prototype, \"LOADING\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLTrackElement, \"LOADED\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(HTMLTrackElement.prototype, \"LOADED\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLTrackElement, \"ERROR\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(HTMLTrackElement.prototype, \"ERROR\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(HTMLTrackElement.prototype, \"readyState\", {\n  get() {\n    return this[impl].readyState;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTrackElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLTrackElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLTrackElement,\n  expose: {\n    Window: { HTMLTrackElement: HTMLTrackElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLTrackElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLTrackElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\n\nclass HTMLTrackElementImpl extends HTMLElementImpl {\n  get readyState() {\n    return 0;\n  }\n\n  get src() {\n    return reflectURLAttribute(this, \"src\");\n  }\n  set src(value) {\n    this.setAttribute(\"src\", value);\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLTrackElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLUListElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLElement = require(\"./HTMLElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLUListElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLUListElement.prototype = Object.create(HTMLElement.interface.prototype);\nHTMLUListElement.prototype.constructor = HTMLUListElement;\n\n\nHTMLUListElement.prototype.toString = function () {\n  if (this === HTMLUListElement.prototype) {\n    return \"[object HTMLUListElementPrototype]\";\n  }\n  return HTMLElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLUListElement.prototype, \"compact\", {\n  get() {\n    return this.hasAttribute(\"compact\");\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    if (V) {\n    this.setAttribute(\"compact\", \"\");\n  } else {\n    this.removeAttribute(\"compact\");\n  }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLUListElement.prototype, \"type\", {\n  get() {\n    const value = this.getAttribute(\"type\");\n    return value === null ? \"\" : value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this.setAttribute(\"type\", V);\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLUListElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLUListElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLUListElement,\n  expose: {\n    Window: { HTMLUListElement: HTMLUListElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLUListElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLUListElement-impl.js":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nclass HTMLUListElementImpl extends HTMLElementImpl { }\n\nmodule.exports = {\n  implementation: HTMLUListElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/generated/HTMLVideoElement.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst HTMLMediaElement = require(\"./HTMLMediaElement.js\");\nconst impl = utils.implSymbol;\n\nfunction HTMLVideoElement() {\n  throw new TypeError(\"Illegal constructor\");\n}\nHTMLVideoElement.prototype = Object.create(HTMLMediaElement.interface.prototype);\nHTMLVideoElement.prototype.constructor = HTMLVideoElement;\n\n\nHTMLVideoElement.prototype.toString = function () {\n  if (this === HTMLVideoElement.prototype) {\n    return \"[object HTMLVideoElementPrototype]\";\n  }\n  return HTMLMediaElement.interface.prototype.toString.call(this);\n};\nObject.defineProperty(HTMLVideoElement.prototype, \"width\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"width\"));\n    return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    V = V > 2147483647 ? 0 : V;\n    this.setAttribute(\"width\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLVideoElement.prototype, \"height\", {\n  get() {\n    const value = parseInt(this.getAttribute(\"height\"));\n    return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value\n  },\n  set(V) {\n    V = conversions[\"unsigned long\"](V);\n    V = V > 2147483647 ? 0 : V;\n    this.setAttribute(\"height\", String(V));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLVideoElement.prototype, \"videoWidth\", {\n  get() {\n    return this[impl].videoWidth;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLVideoElement.prototype, \"videoHeight\", {\n  get() {\n    return this[impl].videoHeight;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLVideoElement.prototype, \"poster\", {\n  get() {\n    return this[impl].poster;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].poster = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLVideoElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLVideoElement.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLMediaElement._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: HTMLVideoElement,\n  expose: {\n    Window: { HTMLVideoElement: HTMLVideoElement }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLVideoElement-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/nodes/HTMLVideoElement-impl.js":"\"use strict\";\n\nconst HTMLMediaElementImpl = require(\"./HTMLMediaElement-impl\").implementation;\nconst reflectURLAttribute = require(\"../../utils\").reflectURLAttribute;\n\nclass HTMLVideoElementImpl extends HTMLMediaElementImpl {\n  get poster() {\n    return reflectURLAttribute(this, \"poster\");\n  }\n\n  set poster(value) {\n    this.setAttribute(\"poster\", value);\n  }\n\n  get videoWidth() {\n    return 0;\n  }\n\n  get videoHeight() {\n    return 0;\n  }\n}\n\nmodule.exports = {\n  implementation: HTMLVideoElementImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/level2/style.js":"\"use strict\";\nconst cssom = require(\"cssom\");\nconst cssstyle = require(\"cssstyle\");\n\nmodule.exports = core => {\n\n  // What works now:\n  // - Accessing the rules defined in individual stylesheets\n  // - Modifications to style content attribute are reflected in style property\n  // - Modifications to style property are reflected in style content attribute\n  // TODO\n  // - Modifications to style element's textContent are reflected in sheet property.\n  // - Modifications to style element's sheet property are reflected in textContent.\n  // - Modifications to link.href property are reflected in sheet property.\n  // - Less-used features of link: disabled\n  // - Less-used features of style: disabled, scoped, title\n  // - CSSOM-View\n  //   - getComputedStyle(): requires default stylesheet, cascading, inheritance,\n  //     filtering by @media (screen? print?), layout for widths/heights\n  // - Load events are not in the specs, but apparently some browsers\n  //   implement something. Should onload only fire after all @imports have been\n  //   loaded, or only the primary sheet?\n\n  core.StyleSheet = cssom.StyleSheet;\n  core.MediaList = cssom.MediaList;\n  core.CSSStyleSheet = cssom.CSSStyleSheet;\n  core.CSSRule = cssom.CSSRule;\n  core.CSSStyleRule = cssom.CSSStyleRule;\n  core.CSSMediaRule = cssom.CSSMediaRule;\n  core.CSSImportRule = cssom.CSSImportRule;\n  core.CSSStyleDeclaration = cssstyle.CSSStyleDeclaration;\n\n  // Relavant specs\n  // http://www.w3.org/TR/DOM-Level-2-Style (2000)\n  // http://www.w3.org/TR/cssom-view/ (2008)\n  // http://dev.w3.org/csswg/cssom/ (2010) Meant to replace DOM Level 2 Style\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/ HTML5, of course\n  // http://dev.w3.org/csswg/css-style-attr/  not sure what's new here\n\n  // Objects that aren't in cssom library but should be:\n  //   CSSRuleList  (cssom just uses array)\n  //   CSSFontFaceRule\n  //   CSSPageRule\n\n  // These rules don't really make sense to implement, so CSSOM draft makes them\n  // obsolete.\n  //   CSSCharsetRule\n  //   CSSUnknownRule\n\n  // These objects are considered obsolete by CSSOM draft, although modern\n  // browsers implement them.\n  //   CSSValue\n  //   CSSPrimitiveValue\n  //   CSSValueList\n  //   RGBColor\n  //   Rect\n  //   Counter\n\n  // http://dev.w3.org/csswg/cssom/#stylesheetlist\n  function StyleSheetList() {}\n\n  StyleSheetList.prototype.__proto__ = Array.prototype;\n\n  StyleSheetList.prototype.item = function item(i) {\n    return Object.prototype.hasOwnProperty.call(this, i) ? this[i] : null;\n  };\n\n  core.StyleSheetList = StyleSheetList;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/level3/xpath.js":"/** Here is yet another implementation of XPath 1.0 in Javascript.\n *\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\n * the axes became more and more complicated. :-(.\n *\n * I have not implemented namespaces or case-sensitive axes for XML yet.\n *\n * How to test it in Chrome: You can make a Chrome extension that replaces\n * the WebKit XPath parser with this one. But it takes a bit of effort to\n * get around isolated world and same-origin restrictions:\n * manifest.json:\n    {\n      \"name\": \"XPathTest\",\n      \"version\": \"0.1\",\n      \"content_scripts\": [{\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\n        \"js\": [\"xpath.js\", \"injection.js\"],\n        \"all_frames\": true, \"run_at\": \"document_start\"\n      }]\n    }\n * injection.js:\n    // goal: give my xpath object to the website's JS context.\n    var script = document.createElement('script');\n    script.textContent =\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\n        \"  console.log('extending document with xpath...');\\n\" +\n        \"  e.detail(window);\" +\n        \"});\";\n    document.documentElement.appendChild(script);\n    document.documentElement.removeChild(script);\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\n    document.dispatchEvent(evt);\n */\nmodule.exports = core => {\n  var xpath = {};\n\n  // Helper function to deal with the migration of Attr to no longer have a nodeName property despite this codebase\n  // assuming it does.\n  function getNodeName(nodeOrAttr) {\n    return nodeOrAttr.constructor.name === 'Attr' ? nodeOrAttr.name : nodeOrAttr.nodeName;\n  }\n\n  /***************************************************************************\n   *                            Tokenization                                 *\n   ***************************************************************************/\n  /**\n   * The XPath lexer is basically a single regular expression, along with\n   * some helper functions to pop different types.\n   */\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null;\n    // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n    this.prev = null;  // for debugging\n    this.prevprev = null;\n  }\n  Stream.prototype = {\n    peek: function() {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n    /** Peek 2 tokens ahead. */\n    peek2: function() {\n      this.peek();  // make sure this.peeked is set\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function() {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function(tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();;\n        }\n      }\n    },\n    trypopfuncname: function() {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok))\n        return null;\n      switch (tok) {\n        case 'comment': case 'text': case 'processing-instruction': case 'node':\n          return null;\n      }\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function() {\n      var tok = this.peek();\n      switch (tok) {\n        case 'ancestor': case 'ancestor-or-self': case 'attribute':\n        case 'child': case 'descendant': case 'descendant-or-self':\n        case 'following': case 'following-sibling': case 'namespace':\n        case 'parent': case 'preceding': case 'preceding-sibling': case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n      return null;\n    },\n    trypopnametest: function() {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n      if ('\"' === first && '\"' === last ||\n          \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function() {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());\n      else return null;\n    },\n    trypopvarref: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);\n      else return null;\n    },\n    position: function() {\n      return this.original.length - this.str.length;\n    }\n  };\n  (function() {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon =\n        'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' +\n        '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' +\n        '\\uFDF0-\\uFFFD';  // JS doesn't support [#x10000-#xEFFFF]\n    var nameCharExceptColon = nameStartCharsExceptColon +\n        '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon +\n        '][' + nameCharExceptColon + ']*'\n    // http://www.w3.org/TR/REC-xml-names/#NT-QName\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::';  // .. must come before [.]\n    var operatorChars =\n        'and|or|mod|div|' +\n        '//|!=|<=|>=|[*/|+\\\\-=<>]';  // //, !=, <=, >= before individual ones.\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*';  // stricter than regexp \\s.\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp(\n        // numberChars before otherChars so that leading-decimal doesn't become .\n        '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' +\n        nameTestChars + '|' + operatorChars + '|' + literal + '|' +\n        variableReference + ')'\n        // operatorName | nodeType | functionName | axisName are lumped into\n        // qName for now; we'll check them on pop.\n    );\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n\n  /***************************************************************************\n   *                               Parsing                                   *\n   ***************************************************************************/\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream,a);\n    var x, unparsed = [];\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n    if (unparsed.length)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  }\n\n  /**\n   * binaryL  ::= subExpr\n   *            | binaryL op subExpr\n   * so a op b op c becomes ((a op b) op c)\n   */\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n    return lhs;\n  }\n  /**\n   * Too bad this is never used. If they made a ** operator (raise to power),\n   ( we would use it.\n   * binaryR  ::= subExpr\n   *            | subExpr op binaryR\n   * so a op b op c becomes (a op (b op c))\n   */\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs;// TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\n   * e.g. a, a/b, //a/b\n   */\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) ||\n           relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\n   */\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\n   *                            | AbbreviatedRelativeLocationPath\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\n   * e.g. p/a, etc.\n   */\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n    var op;\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs,\n                     a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;\n      else isOnlyRootOk = false;\n      if (null == rhs)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\n   *  [12] AbbreviatedStep::= '.' | '..'\n   * e.g. @href, self::p, p, a[@href], ., ..\n   */\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep)  // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep)  // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName)\n        throw new XPathException(\n            XPathException.INVALID_EXPRESSION_ERR,\n            'Position ' + stream.position() +\n            ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';\n      else if ('namespace' === axis) nodeType = 'namespace';\n      else nodeType = 'element';\n    }\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\n   *                | 'descendant' | 'descendant-or-self' | 'following'\n   *                | 'following-sibling' | 'namespace' | 'parent' |\n   *                | 'preceding' | 'preceding-sibling' | 'self'\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\n   */\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\n   * I've split nodeTypeTest from nodeNameTest for convenience.\n   */\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n    if (null != type) {\n      if (null == stream.trypop('('))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen.');\n      var param = undefined;\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected close parens.');\n      return type\n    }\n  }\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;\n    else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\n   *  [9] PredicateExpr::= Expr\n   */\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected expression after [');\n    if (null == stream.trypop(']'))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\n   */\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\n   */\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x)\n      x = stream.trypopnumber();\n    if (null != x) {\n      return x;\n    }\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n    if (null != funCall) {\n      return funCall;\n    }\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression after (.');\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected ) after expression.');\n      return e;\n    }\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\n   *  [17] Argument::= Expr\n   */\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('('))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(','))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression as argument of function.');\n      params.push(param);\n    }\n    return a.node('FunctionCall', name, params);\n  }\n\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\n   */\n  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, '|'); }\n  /** [19] PathExpr ::= LocationPath\n   *                  | FilterExpr\n   *                  | FilterExpr '/' RelativeLocationPath\n   *                  | FilterExpr '//' RelativeLocationPath\n   * Unlike most other nodes, this one always generates a node because\n   * at this point all reverse nodesets must turn into a forward nodeset\n   */\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n      if (null == loc) {\n        throw new Error\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': The expression shouldn\\'t be empty...');\n      }\n      return a.node('PathExpr', loc);\n    }\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;\n    else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\n   */\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred, lhs = primary;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\n   */\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\n   */\n  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, 'and'); }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\n   *                     | EqualityExpr '!=' RelationalExpr\n   */\n  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, ['=','!=']); }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\n   *                       | RelationalExpr '>' AdditiveExpr\n   *                       | RelationalExpr '<=' AdditiveExpr\n   *                       | RelationalExpr '>=' AdditiveExpr\n   */\n  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, ['<','>','<=','>=']); }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\n   *                     | AdditiveExpr '+' MultiplicativeExpr\n   *                     | AdditiveExpr '-' MultiplicativeExpr\n   */\n  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, ['+','-']); }\n  /** [26] MultiplicativeExpr::= UnaryExpr\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\n   *                           | MultiplicativeExpr 'div' UnaryExpr\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\n   */\n  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, ['*','div','mod']); }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\n   */\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    }\n    else return unionExpr(stream, a);\n  }\n  var astFactory = {\n    node: function() {return Array.prototype.slice.call(arguments);}\n  };\n\n\n  /***************************************************************************\n   *                            Optimizations (TODO)                         *\n   ***************************************************************************/\n  /**\n   * Some things I've been considering:\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\n   *    position() or last()\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\n   *    node in the node-set rather than once per (node, position, last).\n   * For more optimizations, look up Gecko's optimizer:\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\n   */\n  // TODO\n  function optimize(ast) {\n  }\n\n  /***************************************************************************\n   *                           Evaluation: axes                              *\n   ***************************************************************************/\n\n  /**\n   * Data types: For string, number, boolean, we just use Javascript types.\n   * Node-sets have the form\n   *    {nodes: [node, ...]}\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\n   *\n   * Most of the time, only the node is used and the position information is\n   * discarded. But if you use a predicate, we need to try every value of\n   * position and last in case the predicate calls position() or last().\n   */\n\n  /**\n   * The NodeMultiSet is a helper class to help generate\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\n   * descendant, descendant-or-self, following-sibling, and\n   * preceding-sibling axes for which we can use a stack to organize things.\n   */\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = [];  // index within nodes that each series begins.\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n          indexInPos = this.nextPos.length,\n          seriesBeginIndex = this.seriesIndexes.pop(),\n          seriesEndIndex = this.nodes.length;\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function() {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n      var lastsJSON = JSON.stringify(this.lasts);\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + lastsJSON);\n        }\n      }\n      this.pushSeries = this.popSeries = this.addNode = function() {\n        throw new Error('Already finalized.');\n      };\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n      this._pushToNodes.call(this.nodes, node)\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function() {\n      this.finalize();\n      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};\n    }\n  };\n  function eachContext(nodeMultiSet) {\n    var r = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n      if (!nodeMultiSet.pos) {\n        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});\n        }\n      }\n    }\n    return r;\n  }\n  /** Matcher used in the axes.\n   */\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest =\n      null == nodeName ? this._alwaysTrue :\n      shouldLowerCase ? this._nodeNameLowerCaseEquals :\n      this._nodeNameEquals;\n  }\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      if (0 === this.nodeTypeNum || this._nodeTypeMatches(node)) {\n        return this.nodeNameTest(getNodeName(node));\n      }\n\n      return false;\n    },\n    _nodeTypeMatches(nodeOrAttr) {\n      if (nodeOrAttr.constructor.name === 'Attr' && this.nodeTypeNum === 2) {\n        return true;\n      }\n      return nodeOrAttr.nodeType === this.nodeTypeNum;\n    },\n    _alwaysTrue: function(name) {return true;},\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n\n  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n    while (0 < nodeList.length) {  // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n      while (null != node) {\n        if (! andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n        if (andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n      while (0 < numPushed--)\n        nodeMultiSet.popSeries();\n    }\n    return nodeMultiSet;\n  }\n\n  /** Returns the next non-descendant node in document order.\n   * This is the first node in following::node(), if node is the context.\n   */\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild)\n        return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n    return null;\n  }\n\n  /** Returns the next node in a document-order depth-first search.\n   * See the definition of document order[1]:\n   *   1) element\n   *   2) namespace nodes\n   *   3) attributes\n   *   4) children\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\n   */\n  function followingNode(node) {\n    if (node.ownerElement)  // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild)\n      return node.firstChild;\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n      node = node.parentNode;\n    } while (node);\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\n   * and namespace nodes).\n   */\n  function precedingNode(node) {\n    if (node.ownerElement)\n      return node.ownerElement;\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n      return node;\n    }\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\n   * But I think it's a pretty useless axis so it's ok. */\n  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start)\n        unorderedFollowingStarts.push(start);\n    }\n    if (0 === unorderedFollowingStarts.length)\n      return {nodes:[]};\n    var pos = [], nextPos = [];\n    var started = 0;\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--){\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i,i+1);\n          started++;\n        }\n      }\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n    console.assert(0 === unorderedFollowingStarts.length);\n    for (var i = 0; i < started; i++)\n      nodeMultiSet.popSeries();\n    return nodeMultiSet.finalize();\n  }\n  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {nodes:{}};\n    var r = {nodes:[], pos:[], lasts:[]};\n    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n      var matches = matcher.matches(cursor);\n      var pos, someoneUsed = false;\n      if (matches)\n        pos = nextPos.slice();\n\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j+1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n    return r;\n  }\n\n  /** node-set, axis -> node-set */\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n    if (null != node && !andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    var pushed = false;\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n    if (andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n    var nodeList = node.childNodes;\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [], attrNodes = [];\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n    nodeMultiSet.finalize();\n    for (var i = attrNodes.length-1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n    return nodeMultiSet;\n  }\n  /**\n   */\n  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node))\n            a.push(node);\n        }\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n      if (0 < a.length)\n        ancestors.push(a);\n    }\n    var lasts = [];\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {nodes:[], pos:[], lasts:[]};\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i+1);\n            lasts.splice(i, i+1);\n          }\n        }\n      }\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\n   * node to the root, of positions within parent.\n   * For convenience, the node is the first element of the array.\n   */\n  function addressVector(node) {\n    var r = [node];\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n    while (null != node) {\n      var i = 0;\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n      r.push(i);\n      node = node.parentNode\n    }\n    return r;\n  }\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node\n        alen = a.length,\n        blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c)\n        break;\n    }\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n    if (0 === c)\n      c = getNodeName(a) - getNodeName(b);\n    if (0 === c)\n      c = 1;\n    return c;\n  }\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {\n    var a = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n    a.sort(addressComparator);\n    var b = [];\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0])\n        continue;\n      b.push(a[i][0]);\n    }\n    return b;\n  }\n  /** Sort node multiset. Does not do any de-duping. */\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({v:v, n:nodeMultiSet.nodes[i],\n              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});\n    }\n    a.sort(compare);\n    var r = {nodes:[], pos:[], lasts:[]};\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\n   * The array starts with document.\n   */\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n    return ancestors;\n  }\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n    while (c = c.previousSibling) {\n      if (c === b)\n        return 1;  // b < a\n    }\n    c = b;\n    while (c = c.previousSibling) {\n      if (c === a)\n        return -1;  // a < b\n    }\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n  function mergeNodeLists(x, y) {\n    var a, b, aanc, banc, r = [];\n    if ('object' !== typeof x)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + x);\n    if ('object' !== typeof y)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + y);\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a)\n          aanc = addressVector(a);\n      }\n      if (null == b) {\n        b = y.shift();\n        if (null != b)\n          banc = addressVector(b);\n      }\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (getNodeName(a) < getNodeName(b)) {  // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (getNodeName(a) > getNodeName(b)) {  // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c);\n        // just skip b without pushing it.\n        b = null;\n        banc = null;\n      }\n    }\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n    return r;\n  }\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison)\n      coersion = fn.number;\n    else coersion =\n      'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] :\n      'number' === typeof x || 'number' === typeof y ? fn.number :\n      fn.string;\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]});\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({nodes:[y.nodes[j]]});\n          if (test(xi, yj)) return true;\n        }\n      }\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);\n        if (test(xi, yc))\n          return true;\n      }\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);\n        if (test(xc, yi))\n          return true;\n      }\n      return false;\n    } else {\n      var xc = coersion(x), yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n  var axes = xpath.axes = {\n    'ancestor':\n      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'ancestor-or-self':\n      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'attribute':\n      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO: figure out whether positions should be undefined here.\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        if (null != nodeName) {\n          // TODO: with namespace\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null == node.getAttributeNode)\n              continue;  // only Element has .getAttributeNode\n            var attr = node.getAttributeNode(nodeName);\n            if (null != attr && matcher.matches(attr)) {\n              nodeMultiSet.pushSeries();\n              nodeMultiSet.addNode(attr);\n              nodeMultiSet.popSeries();\n            }\n          }\n        } else {\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null != node.attributes) {\n              nodeMultiSet.pushSeries();\n              for (var j = 0; j < node.attributes.length; j++) {  // all nodes have .attributes\n                var attr = node.attributes[j];\n                if (matcher.matches(attr))  // TODO: I think this check is unnecessary\n                  nodeMultiSet.addNode(attr);\n              }\n              nodeMultiSet.popSeries();\n            }\n          }\n        }\n        return nodeMultiSet.finalize();\n      },\n    'child':\n      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        for (var i = 0; i < nodeList.length; ++i) {\n          var n = nodeList[i];\n          if (n.ownerElement)  // skip attribute nodes' text child.\n            continue;\n          if (n.childNodes) {\n            nodeMultiSet.pushSeries();\n            var childList = 1 === nodeTypeNum && null != n.children ?\n                n.children : n.childNodes;\n            for (var j = 0; j < childList.length; ++j) {\n              var child = childList[j];\n              if (matcher.matches(child)) {\n                nodeMultiSet.addNode(child);\n              }\n              // don't have to do de-duping because children have parent,\n              // which are current context.\n            }\n            nodeMultiSet.popSeries();\n          }\n        }\n        nodeMultiSet.finalize();\n        return sortNodeMultiSet(nodeMultiSet);\n      },\n    'descendant':\n      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'descendant-or-self':\n      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'following':\n      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'following-sibling':\n      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.shift, function() {return this[0];},\n          function(node) {return node.nextSibling;});\n      },\n    'namespace':\n      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO\n      },\n    'parent':\n      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodes = [], pos = [];\n        for (var i = 0; i < nodeList.length; ++i) {\n          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n          if (null == parent)\n            continue;\n          if (!matcher.matches(parent))\n            continue;\n          if (nodes.length > 0 && parent === nodes[nodes.length-1])\n            continue;\n          nodes.push(parent);\n          pos.push([1]);\n        }\n        return {nodes:nodes, pos:pos, lasts:pos};\n      },\n    'preceding':\n      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return precedingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'preceding-sibling':\n      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.pop, function() {return this[this.length-1];},\n          function(node) {return node.previousSibling},\n          false, true);\n      },\n    'self':\n      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var nodes = [], pos = [];\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        for (var i = 0; i < nodeList.length; ++i) {\n          if (matcher.matches(nodeList[i])) {\n            nodes.push(nodeList[i]);\n            pos.push([1]);\n          }\n        }\n        return {nodes: nodes, pos: pos, lasts: pos}\n      }\n  };\n\n  /***************************************************************************\n   *                         Evaluation: functions                           *\n   ***************************************************************************/\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject)\n        return optObject;\n      if ('string' === typeof optObject)\n        return parseFloat(optObject);  // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n      if ('boolean' === typeof optObject)\n        return +optObject;\n      return fn.number(fn.string.call(this, optObject));  // for node-sets\n    },\n    'string': function string(optObject) {\n      if (null == optObject)\n        return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject ||\n          'number' === typeof optObject)\n        return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent)\n        return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Function count(node-set) ' +\n                                 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {nodes: []};\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({nodes:[idNode]});\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length)\n          continue;\n        var node = doc.getElementById(id);\n        if (null != node)\n          r.nodes.push(node);\n      }\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      // TODO: namespaced version\n      return nodeSet.nodes[0].localName;\n    },\n    'namespace-uri': function(nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      return nodeSet.nodes[0].name;\n    },\n    'concat': function concat(x) {\n      var l = [];\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Must be at least 2 arguments to string()');\n      }\n      var sString = fn.string(string),\n          iStart = fn.round(start),\n          iEnd = optEnd == null ? null : fn.round(optEnd);\n      // Note that xpath string positions user 1-based index\n      if (iEnd == null)\n        return sString.substr(iStart - 1);\n      else\n        return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n          sFrom = fn.string(from),\n          sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i);  // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n        eachCharRe.push(\n          c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').\n            replace(/\\x08/g, '\\\\x08'));\n      }\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function(c) {return map[c];});\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() { return true; },\n    'false': function falseVal() { return false; },\n    // TODO\n    'lang': function lang(string) { throw new Error('Not implemented');},\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this);\n      // for node-sets, map id over each node value.\n      var sum = 0;\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({nodes:[node]});\n        sum += x;\n      }\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: operators                           *\n   ***************************************************************************/\n  var more = {\n    UnaryMinus: function(x) { return -fn.number(x); },\n    '+': function(x, y) { return fn.number(x) + fn.number(y); },\n    '-': function(x, y) { return fn.number(x) - fn.number(y); },\n    '*': function(x, y) { return fn.number(x) * fn.number(y); },\n    'div': function(x, y) { return fn.number(x) / fn.number(y); },\n    'mod': function(x, y) { return fn.number(x) % fn.number(y); },\n    '<': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) < fn.number(y);}, x, y, true);\n    },\n    '<=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) <= fn.number(y);}, x, y, true);\n    },\n    '>':  function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) > fn.number(y);}, x, y, true);\n    },\n    '>=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) >= fn.number(y);}, x, y, true);\n    },\n    'and': function(x, y) { return fn['boolean'](x) && fn['boolean'](y); },\n    'or': function(x, y) { return fn['boolean'](x) || fn['boolean'](y); },\n    '|': function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },\n    '=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x === y;}, x, y);\n      }\n    },\n    '!=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (!aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x !== y;}, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8, // this.doc.COMMENT_NODE,\n    'text': 3, // this.doc.TEXT_NODE,\n    'processing-instruction': 7, // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1  //this.doc.ELEMENT_NODE\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\n   * argument. */\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random()*1000000000);\n    return JSON.stringify(helper(ctx));\n\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function(x) {return helper(x);});\n      }\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx;\n    //  if (ctx.toString) return ctx.toString();\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n      for (var key in ctx) {\n        if (seenKey === key)\n          continue;\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n      delete ctx[seenKey];\n      return nicer;\n    }\n  }\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  }\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n      switch (ast[0]) {\n        case 'Root': return {nodes: [this.doc]};\n        case 'FunctionCall':\n          var functionName = ast[1], functionParams = ast[2];\n          if (null == fn[functionName])\n            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                     'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {nodes: []};\n          var contexts = eachContext(lhs);\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node);\n              // skip over all the rest of the same node.\n              while (i+1 < contexts.length && node === contexts[i+1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n          return ret;\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx);\n          // Make the nodeset a forward-direction-only one.\n          if (x.finalize) {  // it is a NodeMultiSet\n            return {nodes: x.nodes};\n          } else {\n            return x;\n          }\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n              nodeType = ast[2],\n              nodeTypeNum = nodeTypes[nodeType],\n              shouldLowerCase = true,  // TODO: give option\n              nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {nodes:[], pos:[]};\n          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?\n          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {nodes: [context]});\n    return val;\n  }\n\n  /***************************************************************************\n   *                           DOM interface                                 *\n   ***************************************************************************/\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  }\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n\n\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}\n  XPathEvaluator.prototype = {\n    createExpression: function(expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function(nodeResolver) {\n      // TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n\n\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  }\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType)\n        throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(\n            core.DOMException.WRONG_DOCUMENT_ERR,\n            'The document must be the same as the context node\\'s document.');\n      }\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {nodes: [contextNode]});\n      if (XPathResult.NUMBER_TYPE === type)\n        value = fn.number(value);\n      else if (XPathResult.STRING_TYPE === type)\n        value = fn.string(value);\n      else if (XPathResult.BOOLEAN_TYPE === type)\n        value = fn['boolean'](value);\n      else if (XPathResult.ANY_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &&\n               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)\n        throw new core.DOMException(\n            core.DOMException.NOT_SUPPORTED_ERR,\n            'You must provide an XPath result type (0=any).');\n      else if (XPathResult.ANY_TYPE !== type &&\n               'object' !== typeof value)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  }\n\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0;\n\n    // TODO: we removed mutation events but didn't take care of this. No tests fail, so that's nice, but eventually we\n    // should fix this, preferably by entirely replacing our XPath implementation.\n    // this._invalidated = false;\n    // if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\n    //     this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n    //   doc.addEventListener('DOMSubtreeModified', invalidate, true);\n    //   var self = this;\n    //   function invalidate() {\n    //     self._invalidated = true;\n    //     doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n    //   }\n    // }\n  }\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n      switch (typeof this._value) {\n        case 'number': return XPathResult.NUMBER_TYPE;\n        case 'string': return XPathResult.STRING_TYPE;\n        case 'boolean': return XPathResult.BOOLEAN_TYPE;\n        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &&\n          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        return false;\n      return !!this._invalidated;\n    },\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState)\n        throw new core.DOMException(\n            core.DOMException.INVALID_STATE_ERR,\n            'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  };\n  // so you can access ANY_TYPE etc. from the instances:\n  XPathResult.prototype = Object.create(XPathResult,\n      Object.keys(proto).reduce(function (descriptors, name) {\n        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n        return descriptors;\n      }, {\n        constructor: {\n          value: XPathResult,\n          writable: true,\n          configurable: true\n        }\n      }));\n\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n\n  core.Document.prototype.createExpression =\n    XPathEvaluator.prototype.createExpression;\n\n  core.Document.prototype.createNSResolver =\n      XPathEvaluator.prototype.createNSResolver;\n\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n\n  return xpath; // for tests\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/node-filter.js":"\"use strict\";\nconst addConstants = require(\"../utils\").addConstants;\n\nmodule.exports = function (core) {\n  // https://dom.spec.whatwg.org/#interface-nodefilter\n  core.NodeFilter = function () {\n    throw new TypeError(\"Illegal constructor\");\n  };\n\n  /**\n   * Returns an unsigned short that will be used to tell if a given Node must\n   * be accepted or not by the NodeIterator or TreeWalker iteration\n   * algorithm. This method is expected to be written by the user of a\n   * NodeFilter.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter\n   * @interface\n   *\n   * @param  {Node} node DOM Node\n   * @return {FILTER_ACCEPT|FILTER_REJECT|FILTER_SKIP}\n   */\n  core.NodeFilter.acceptNode = function (/* node */) {\n    throw new Error(\"This method is expected to be written by the user of a NodeFilter.\");\n  };\n\n  addConstants(core.NodeFilter, {\n    // Constants for whatToShow\n    SHOW_ALL: 0xFFFFFFFF,\n    SHOW_ELEMENT: 0x00000001,\n    SHOW_ATTRIBUTE: 0x00000002,\n    SHOW_TEXT: 0x00000004,\n    SHOW_CDATA_SECTION: 0x00000008,\n    SHOW_ENTITY_REFERENCE: 0x00000010,\n    SHOW_ENTITY: 0x00000020,\n    SHOW_PROCESSING_INSTRUCTION: 0x00000040,\n    SHOW_COMMENT: 0x00000080,\n    SHOW_DOCUMENT: 0x00000100,\n    SHOW_DOCUMENT_TYPE: 0x00000200,\n    SHOW_DOCUMENT_FRAGMENT: 0x00000400,\n    SHOW_NOTATION: 0x00000800,\n\n    // Constants returned by acceptNode\n    FILTER_ACCEPT: 1,\n    FILTER_REJECT: 2,\n    FILTER_SKIP: 3\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/node-iterator.js":"\"use strict\";\n\nconst idlUtils = require(\"./generated/utils\");\nconst domSymbolTree = require(\"./helpers/internal-constants\").domSymbolTree;\nconst defineGetter = require(\"../utils\").defineGetter;\nconst INTERNAL = Symbol(\"NodeIterator internal\");\nconst DocumentImpl = require(\"./nodes/Document-impl\").implementation;\n\nmodule.exports = function (core) {\n  // https://dom.spec.whatwg.org/#interface-nodeiterator\n\n  function NodeIteratorInternal(document, root, whatToShow, filter) {\n    this.active = true;\n    this.document = document;\n    this.root = root;\n    this.referenceNode = root;\n    this.pointerBeforeReferenceNode = true;\n    this.whatToShow = whatToShow;\n    this.filter = filter;\n  }\n\n  NodeIteratorInternal.prototype.throwIfNotActive = function () {\n    // (only thrown for getters/methods that are affected by removing steps)\n    if (!this.active) {\n      throw Error(\"This NodeIterator is no longer active. \" +\n                  \"More than \" + this.document._activeNodeIteratorsMax +\n                  \" iterators are being used concurrently. \" +\n                  \"You can increase the 'concurrentNodeIterators' option to \" +\n                  \"make this error go away.\"\n      );\n      // Alternatively, you can pester Ecma to add support for weak references,\n      // the DOM standard assumes the implementor has control over object life cycles.\n    }\n  };\n\n  NodeIteratorInternal.prototype.traverse = function (next) {\n    let node = this.referenceNode;\n    let beforeNode = this.pointerBeforeReferenceNode;\n\n    do {\n      if (next) {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = false;\n      } else { // previous\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = true;\n      }\n    }\n    while (this.filterNode(node) !== core.NodeFilter.FILTER_ACCEPT);\n\n    this.pointerBeforeReferenceNode = beforeNode;\n    this.referenceNode = node;\n    return node;\n  };\n\n  NodeIteratorInternal.prototype.filterNode = function (node) {\n    const n = node.nodeType - 1;\n    if (!(this.whatToShow & (1 << n))) {\n      return core.NodeFilter.FILTER_SKIP;\n    }\n\n    let ret = core.NodeFilter.FILTER_ACCEPT;\n    const filter = this.filter;\n    if (typeof filter === \"function\") {\n      ret = filter(node);\n    } else if (filter && typeof filter.acceptNode === \"function\") {\n      ret = filter.acceptNode(node);\n    }\n\n    if (ret === true) {\n      return core.NodeFilter.FILTER_ACCEPT;\n    } else if (ret === false) {\n      return core.NodeFilter.FILTER_REJECT;\n    }\n\n    return ret;\n  };\n\n  NodeIteratorInternal.prototype.runRemovingSteps = function (oldNode, oldParent, oldPreviousSibling) {\n    if (oldNode.contains(this.root)) {\n      return;\n    }\n\n    // If oldNode is not an inclusive ancestor of the referenceNode\n    // attribute value, terminate these steps.\n    if (!oldNode.contains(this.referenceNode)) {\n      return;\n    }\n\n    if (this.pointerBeforeReferenceNode) {\n      // Let nextSibling be oldPreviousSibling’s next sibling, if oldPreviousSibling is non-null,\n      // and oldParent’s first child otherwise.\n      const nextSibling = oldPreviousSibling ?\n                          oldPreviousSibling.nextSibling :\n                          oldParent.firstChild;\n\n      // If nextSibling is non-null, set the referenceNode attribute to nextSibling\n      // and terminate these steps.\n      if (nextSibling) {\n        this.referenceNode = nextSibling;\n        return;\n      }\n\n      // Let next be the first node following oldParent (excluding any children of oldParent).\n      const next = domSymbolTree.following(oldParent, { skipChildren: true });\n\n      // If root is an inclusive ancestor of next, set the referenceNode\n      // attribute to next and terminate these steps.\n      if (this.root.contains(next)) {\n        this.referenceNode = next;\n        return;\n      }\n\n      // Otherwise, set the pointerBeforeReferenceNode attribute to false.\n      this.pointerBeforeReferenceNode = false;\n\n      // Note: Steps are not terminated here.\n    }\n\n    // Set the referenceNode attribute to the last inclusive descendant in tree order of oldPreviousSibling,\n    // if oldPreviousSibling is non-null, and to oldParent otherwise.\n    this.referenceNode = oldPreviousSibling ?\n                             domSymbolTree.lastInclusiveDescendant(oldPreviousSibling) :\n                             oldParent;\n  };\n\n  DocumentImpl._removingSteps.push((document, oldNode, oldParent, oldPreviousSibling) => {\n    for (let i = 0; i < document._activeNodeIterators.length; ++i) {\n      const internal = document._activeNodeIterators[i];\n      internal.runRemovingSteps(oldNode, oldParent, oldPreviousSibling);\n    }\n  });\n\n  core.Document.prototype.createNodeIterator = function (root, whatToShow, filter) {\n    if (!root) {\n      throw new TypeError(\"Not enough arguments to Document.createNodeIterator.\");\n    }\n    root = idlUtils.implForWrapper(root);\n\n    if (filter === undefined) {\n      filter = null;\n    }\n\n    if (filter !== null &&\n        typeof filter !== \"function\" &&\n        typeof filter.acceptNode !== \"function\") {\n      throw new TypeError(\"Argument 3 of Document.createNodeIterator should be a function or implement NodeFilter.\");\n    }\n\n    const document = root._ownerDocument;\n\n    whatToShow = whatToShow === undefined ?\n      core.NodeFilter.SHOW_ALL :\n      (whatToShow & core.NodeFilter.SHOW_ALL) >>> 0; // >>> makes sure the result is unsigned\n\n    filter = filter || null;\n\n    const it = Object.create(core.NodeIterator.prototype);\n    const internal = new NodeIteratorInternal(document, root, whatToShow, filter);\n    it[INTERNAL] = internal;\n\n    document._activeNodeIterators.push(internal);\n    while (document._activeNodeIterators.length > document._activeNodeIteratorsMax) {\n      const internalOther = document._activeNodeIterators.shift();\n      internalOther.active = false;\n    }\n\n    return it;\n  };\n\n  core.NodeIterator = function NodeIterator() {\n    throw new TypeError(\"Illegal constructor\");\n  };\n\n  defineGetter(core.NodeIterator.prototype, \"root\", function () {\n    return idlUtils.wrapperForImpl(this[INTERNAL].root);\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"referenceNode\", function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return idlUtils.wrapperForImpl(internal.referenceNode);\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"pointerBeforeReferenceNode\", function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return internal.pointerBeforeReferenceNode;\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"whatToShow\", function () {\n    return this[INTERNAL].whatToShow;\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"filter\", function () {\n    return this[INTERNAL].filter;\n  });\n\n  core.NodeIterator.prototype.previousNode = function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return idlUtils.wrapperForImpl(internal.traverse(false));\n  };\n\n  core.NodeIterator.prototype.nextNode = function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return idlUtils.wrapperForImpl(internal.traverse(true));\n  };\n\n  core.NodeIterator.prototype.detach = function () {\n    // noop\n  };\n\n  core.NodeIterator.prototype.toString = function () {\n    return \"[object NodeIterator]\";\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/xmlhttprequest-event-target.js":"\"use strict\";\n\nconst EventTarget = require(\"./generated/EventTarget\");\n\nfunction XMLHttpRequestEventTarget() {\n  if (!(this instanceof XMLHttpRequestEventTarget)) {\n    throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n  }\n  EventTarget.setup(this);\n  this.onabort = null;\n  this.onerror = null;\n  this.onload = null;\n  this.onloadend = null;\n  this.onloadstart = null;\n  this.onprogress = null;\n  this.ontimeout = null;\n}\n\nXMLHttpRequestEventTarget.prototype = Object.create(EventTarget.interface.prototype);\n\nmodule.exports = function (core) {\n  core.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/living/xmlhttprequest-upload.js":"\"use strict\";\n\nmodule.exports = function (core) {\n  const XMLHttpRequestEventTarget = core.XMLHttpRequestEventTarget;\n\n  class XMLHttpRequestUpload extends XMLHttpRequestEventTarget {\n    constructor() {\n      super();\n      if (!(this instanceof XMLHttpRequestUpload)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n    }\n  }\n\n  core.XMLHttpRequestUpload = XMLHttpRequestUpload;\n};\n\n","/home/travis/build/npmtest/node-npmtest-jsdom/jsdom/lib/jsdom/browser/default-stylesheet.js":"// Ideally, we would use\n// https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints\n// but for now, just use the version from blink. This file is copied from\n// https://chromium.googlesource.com/chromium/blink/+/96aa3a280ab7d67178c8f122a04949ce5f8579e0/Source/core/css/html.css\n// (removed a line which had octal literals inside since octal literals are not allowed in template strings)\n\n// We use a .js file because otherwise we can't browserify this. (brfs is unusable due to lack of ES2015 support)\n\nmodule.exports = `\n/*\n * The default style sheet used to render HTML.\n *\n * Copyright (C) 2000 Lars Knoll (knoll@kde.org)\n * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public License\n * along with this library; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA.\n *\n */\n\n@namespace \"http://www.w3.org/1999/xhtml\";\n\nhtml {\n    display: block\n}\n\n:root {\n    scroll-blocks-on: start-touch wheel-event\n}\n\n/* children of the <head> element all have display:none */\nhead {\n    display: none\n}\n\nmeta {\n    display: none\n}\n\ntitle {\n    display: none\n}\n\nlink {\n    display: none\n}\n\nstyle {\n    display: none\n}\n\nscript {\n    display: none\n}\n\n/* generic block-level elements */\n\nbody {\n    display: block;\n    margin: 8px\n}\n\nbody:-webkit-full-page-media {\n    background-color: rgb(0, 0, 0)\n}\n\np {\n    display: block;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1__qem;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n}\n\ndiv {\n    display: block\n}\n\nlayer {\n    display: block\n}\n\narticle, aside, footer, header, hgroup, main, nav, section {\n    display: block\n}\n\nmarquee {\n    display: inline-block;\n}\n\naddress {\n    display: block\n}\n\nblockquote {\n    display: block;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 40px;\n    -webkit-margin-end: 40px;\n}\n\nfigcaption {\n    display: block\n}\n\nfigure {\n    display: block;\n    -webkit-margin-before: 1em;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 40px;\n    -webkit-margin-end: 40px;\n}\n\nq {\n    display: inline\n}\n\nq:before {\n    content: open-quote;\n}\n\nq:after {\n    content: close-quote;\n}\n\ncenter {\n    display: block;\n    /* special centering to be able to emulate the html4/netscape behaviour */\n    text-align: -webkit-center\n}\n\nhr {\n    display: block;\n    -webkit-margin-before: 0.5em;\n    -webkit-margin-after: 0.5em;\n    -webkit-margin-start: auto;\n    -webkit-margin-end: auto;\n    border-style: inset;\n    border-width: 1px;\n    box-sizing: border-box\n}\n\nmap {\n    display: inline\n}\n\nvideo {\n    object-fit: contain;\n}\n\n/* heading elements */\n\nh1 {\n    display: block;\n    font-size: 2em;\n    -webkit-margin-before: 0.67__qem;\n    -webkit-margin-after: 0.67em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\n:-webkit-any(article,aside,nav,section) h1 {\n    font-size: 1.5em;\n    -webkit-margin-before: 0.83__qem;\n    -webkit-margin-after: 0.83em;\n}\n\n:-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) h1 {\n    font-size: 1.17em;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n}\n\n:-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) h1 {\n    font-size: 1.00em;\n    -webkit-margin-before: 1.33__qem;\n    -webkit-margin-after: 1.33em;\n}\n\n:-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) h1 {\n    font-size: .83em;\n    -webkit-margin-before: 1.67__qem;\n    -webkit-margin-after: 1.67em;\n}\n\n:-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) h1 {\n    font-size: .67em;\n    -webkit-margin-before: 2.33__qem;\n    -webkit-margin-after: 2.33em;\n}\n\nh2 {\n    display: block;\n    font-size: 1.5em;\n    -webkit-margin-before: 0.83__qem;\n    -webkit-margin-after: 0.83em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\nh3 {\n    display: block;\n    font-size: 1.17em;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\nh4 {\n    display: block;\n    -webkit-margin-before: 1.33__qem;\n    -webkit-margin-after: 1.33em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\nh5 {\n    display: block;\n    font-size: .83em;\n    -webkit-margin-before: 1.67__qem;\n    -webkit-margin-after: 1.67em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\nh6 {\n    display: block;\n    font-size: .67em;\n    -webkit-margin-before: 2.33__qem;\n    -webkit-margin-after: 2.33em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\n/* tables */\n\ntable {\n    display: table;\n    border-collapse: separate;\n    border-spacing: 2px;\n    border-color: gray\n}\n\nthead {\n    display: table-header-group;\n    vertical-align: middle;\n    border-color: inherit\n}\n\ntbody {\n    display: table-row-group;\n    vertical-align: middle;\n    border-color: inherit\n}\n\ntfoot {\n    display: table-footer-group;\n    vertical-align: middle;\n    border-color: inherit\n}\n\n/* for tables without table section elements (can happen with XHTML or dynamically created tables) */\ntable > tr {\n    vertical-align: middle;\n}\n\ncol {\n    display: table-column\n}\n\ncolgroup {\n    display: table-column-group\n}\n\ntr {\n    display: table-row;\n    vertical-align: inherit;\n    border-color: inherit\n}\n\ntd, th {\n    display: table-cell;\n    vertical-align: inherit\n}\n\nth {\n    font-weight: bold\n}\n\ncaption {\n    display: table-caption;\n    text-align: -webkit-center\n}\n\n/* lists */\n\nul, menu, dir {\n    display: block;\n    list-style-type: disc;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    -webkit-padding-start: 40px\n}\n\nol {\n    display: block;\n    list-style-type: decimal;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    -webkit-padding-start: 40px\n}\n\nli {\n    display: list-item;\n    text-align: -webkit-match-parent;\n}\n\nul ul, ol ul {\n    list-style-type: circle\n}\n\nol ol ul, ol ul ul, ul ol ul, ul ul ul {\n    list-style-type: square\n}\n\ndd {\n    display: block;\n    -webkit-margin-start: 40px\n}\n\ndl {\n    display: block;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n}\n\ndt {\n    display: block\n}\n\nol ul, ul ol, ul ul, ol ol {\n    -webkit-margin-before: 0;\n    -webkit-margin-after: 0\n}\n\n/* form elements */\n\nform {\n    display: block;\n    margin-top: 0__qem;\n}\n\nlabel {\n    cursor: default;\n}\n\nlegend {\n    display: block;\n    -webkit-padding-start: 2px;\n    -webkit-padding-end: 2px;\n    border: none\n}\n\nfieldset {\n    display: block;\n    -webkit-margin-start: 2px;\n    -webkit-margin-end: 2px;\n    -webkit-padding-before: 0.35em;\n    -webkit-padding-start: 0.75em;\n    -webkit-padding-end: 0.75em;\n    -webkit-padding-after: 0.625em;\n    border: 2px groove ThreeDFace;\n    min-width: -webkit-min-content;\n}\n\nbutton {\n    -webkit-appearance: button;\n}\n\n/* Form controls don't go vertical. */\ninput, textarea, keygen, select, button, meter, progress {\n    -webkit-writing-mode: horizontal-tb !important;\n}\n\ninput, textarea, keygen, select, button {\n    margin: 0__qem;\n    font: -webkit-small-control;\n    text-rendering: auto; /* FIXME: Remove when tabs work with optimizeLegibility. */\n    color: initial;\n    letter-spacing: normal;\n    word-spacing: normal;\n    line-height: normal;\n    text-transform: none;\n    text-indent: 0;\n    text-shadow: none;\n    display: inline-block;\n    text-align: start;\n}\n\ninput[type=\"hidden\" i] {\n    display: none\n}\n\ninput {\n    -webkit-appearance: textfield;\n    padding: 1px;\n    background-color: white;\n    border: 2px inset;\n    -webkit-rtl-ordering: logical;\n    -webkit-user-select: text;\n    cursor: auto;\n}\n\ninput[type=\"search\" i] {\n    -webkit-appearance: searchfield;\n    box-sizing: border-box;\n}\n\ninput::-webkit-textfield-decoration-container {\n    display: flex;\n    align-items: center;\n    -webkit-user-modify: read-only !important;\n    content: none !important;\n}\n\ninput[type=\"search\" i]::-webkit-textfield-decoration-container {\n    direction: ltr;\n}\n\ninput::-webkit-clear-button {\n    -webkit-appearance: searchfield-cancel-button;\n    display: inline-block;\n    flex: none;\n    -webkit-user-modify: read-only !important;\n    -webkit-margin-start: 2px;\n    opacity: 0;\n    pointer-events: none;\n}\n\ninput:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-clear-button {\n    opacity: 1;\n    pointer-events: auto;\n}\n\ninput[type=\"search\" i]::-webkit-search-cancel-button {\n    -webkit-appearance: searchfield-cancel-button;\n    display: block;\n    flex: none;\n    -webkit-user-modify: read-only !important;\n    -webkit-margin-start: 1px;\n    opacity: 0;\n    pointer-events: none;\n}\n\ninput[type=\"search\" i]:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-search-cancel-button {\n    opacity: 1;\n    pointer-events: auto;\n}\n\ninput[type=\"search\" i]::-webkit-search-decoration {\n    -webkit-appearance: searchfield-decoration;\n    display: block;\n    flex: none;\n    -webkit-user-modify: read-only !important;\n    -webkit-align-self: flex-start;\n    margin: auto 0;\n}\n\ninput[type=\"search\" i]::-webkit-search-results-decoration {\n    -webkit-appearance: searchfield-results-decoration;\n    display: block;\n    flex: none;\n    -webkit-user-modify: read-only !important;\n    -webkit-align-self: flex-start;\n    margin: auto 0;\n}\n\ninput::-webkit-inner-spin-button {\n    -webkit-appearance: inner-spin-button;\n    display: inline-block;\n    cursor: default;\n    flex: none;\n    align-self: stretch;\n    -webkit-user-select: none;\n    -webkit-user-modify: read-only !important;\n    opacity: 0;\n    pointer-events: none;\n}\n\ninput:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-inner-spin-button {\n    opacity: 1;\n    pointer-events: auto;\n}\n\nkeygen, select {\n    border-radius: 5px;\n}\n\nkeygen::-webkit-keygen-select {\n    margin: 0px;\n}\n\ntextarea {\n    -webkit-appearance: textarea;\n    background-color: white;\n    border: 1px solid;\n    -webkit-rtl-ordering: logical;\n    -webkit-user-select: text;\n    flex-direction: column;\n    resize: auto;\n    cursor: auto;\n    padding: 2px;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n}\n\n::-webkit-input-placeholder {\n    -webkit-text-security: none;\n    color: darkGray;\n    display: block !important;\n    pointer-events: none !important;\n}\n\ninput::-webkit-input-placeholder {\n    white-space: pre;\n    word-wrap: normal;\n    overflow: hidden;\n    -webkit-user-modify: read-only !important;\n}\n\ninput[type=\"password\" i] {\n    -webkit-text-security: disc !important;\n}\n\ninput[type=\"hidden\" i], input[type=\"image\" i], input[type=\"file\" i] {\n    -webkit-appearance: initial;\n    padding: initial;\n    background-color: initial;\n    border: initial;\n}\n\ninput[type=\"file\" i] {\n    align-items: baseline;\n    color: inherit;\n    text-align: start !important;\n}\n\ninput:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {\n    background-color: #FAFFBD !important;\n    background-image:none !important;\n    color: #000000 !important;\n}\n\ninput[type=\"radio\" i], input[type=\"checkbox\" i] {\n    margin: 3px 0.5ex;\n    padding: initial;\n    background-color: initial;\n    border: initial;\n}\n\ninput[type=\"button\" i], input[type=\"submit\" i], input[type=\"reset\" i] {\n    -webkit-appearance: push-button;\n    -webkit-user-select: none;\n    white-space: pre\n}\n\ninput[type=\"file\" i]::-webkit-file-upload-button {\n    -webkit-appearance: push-button;\n    -webkit-user-modify: read-only !important;\n    white-space: nowrap;\n    margin: 0;\n    font-size: inherit;\n}\n\ninput[type=\"button\" i], input[type=\"submit\" i], input[type=\"reset\" i], input[type=\"file\" i]::-webkit-file-upload-button, button {\n    align-items: flex-start;\n    text-align: center;\n    cursor: default;\n    color: ButtonText;\n    padding: 2px 6px 3px 6px;\n    border: 2px outset ButtonFace;\n    background-color: ButtonFace;\n    box-sizing: border-box\n}\n\ninput[type=\"range\" i] {\n    -webkit-appearance: slider-horizontal;\n    padding: initial;\n    border: initial;\n    margin: 2px;\n    color: #909090;\n}\n\ninput[type=\"range\" i]::-webkit-slider-container, input[type=\"range\" i]::-webkit-media-slider-container {\n    flex: 1;\n    min-width: 0;\n    box-sizing: border-box;\n    -webkit-user-modify: read-only !important;\n    display: flex;\n}\n\ninput[type=\"range\" i]::-webkit-slider-runnable-track {\n    flex: 1;\n    min-width: 0;\n    -webkit-align-self: center;\n\n    box-sizing: border-box;\n    -webkit-user-modify: read-only !important;\n    display: block;\n}\n\ninput[type=\"range\" i]::-webkit-slider-thumb, input[type=\"range\" i]::-webkit-media-slider-thumb {\n    -webkit-appearance: sliderthumb-horizontal;\n    box-sizing: border-box;\n    -webkit-user-modify: read-only !important;\n    display: block;\n}\n\ninput[type=\"button\" i]:disabled, input[type=\"submit\" i]:disabled, input[type=\"reset\" i]:disabled,\ninput[type=\"file\" i]:disabled::-webkit-file-upload-button, button:disabled,\nselect:disabled, keygen:disabled, optgroup:disabled, option:disabled,\nselect[disabled]>option {\n    color: GrayText\n}\n\ninput[type=\"button\" i]:active, input[type=\"submit\" i]:active, input[type=\"reset\" i]:active, input[type=\"file\" i]:active::-webkit-file-upload-button, button:active {\n    border-style: inset\n}\n\ninput[type=\"button\" i]:active:disabled, input[type=\"submit\" i]:active:disabled, input[type=\"reset\" i]:active:disabled, input[type=\"file\" i]:active:disabled::-webkit-file-upload-button, button:active:disabled {\n    border-style: outset\n}\n\noption:-internal-spatial-navigation-focus {\n    outline: black dashed 1px;\n    outline-offset: -1px;\n}\n\ndatalist {\n    display: none\n}\n\narea {\n    display: inline;\n    cursor: pointer;\n}\n\nparam {\n    display: none\n}\n\ninput[type=\"checkbox\" i] {\n    -webkit-appearance: checkbox;\n    box-sizing: border-box;\n}\n\ninput[type=\"radio\" i] {\n    -webkit-appearance: radio;\n    box-sizing: border-box;\n}\n\ninput[type=\"color\" i] {\n    -webkit-appearance: square-button;\n    width: 44px;\n    height: 23px;\n    background-color: ButtonFace;\n    /* Same as native_theme_base. */\n    border: 1px #a9a9a9 solid;\n    padding: 1px 2px;\n}\n\ninput[type=\"color\" i]::-webkit-color-swatch-wrapper {\n    display:flex;\n    padding: 4px 2px;\n    box-sizing: border-box;\n    -webkit-user-modify: read-only !important;\n    width: 100%;\n    height: 100%\n}\n\ninput[type=\"color\" i]::-webkit-color-swatch {\n    background-color: #000000;\n    border: 1px solid #777777;\n    flex: 1;\n    min-width: 0;\n    -webkit-user-modify: read-only !important;\n}\n\ninput[type=\"color\" i][list] {\n    -webkit-appearance: menulist;\n    width: 88px;\n    height: 23px\n}\n\ninput[type=\"color\" i][list]::-webkit-color-swatch-wrapper {\n    padding-left: 8px;\n    padding-right: 24px;\n}\n\ninput[type=\"color\" i][list]::-webkit-color-swatch {\n    border-color: #000000;\n}\n\ninput::-webkit-calendar-picker-indicator {\n    display: inline-block;\n    width: 0.66em;\n    height: 0.66em;\n    padding: 0.17em 0.34em;\n    -webkit-user-modify: read-only !important;\n    opacity: 0;\n    pointer-events: none;\n}\n\ninput::-webkit-calendar-picker-indicator:hover {\n    background-color: #eee;\n}\n\ninput:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-calendar-picker-indicator,\ninput::-webkit-calendar-picker-indicator:focus {\n    opacity: 1;\n    pointer-events: auto;\n}\n\ninput[type=\"date\" i]:disabled::-webkit-clear-button,\ninput[type=\"date\" i]:disabled::-webkit-inner-spin-button,\ninput[type=\"datetime-local\" i]:disabled::-webkit-clear-button,\ninput[type=\"datetime-local\" i]:disabled::-webkit-inner-spin-button,\ninput[type=\"month\" i]:disabled::-webkit-clear-button,\ninput[type=\"month\" i]:disabled::-webkit-inner-spin-button,\ninput[type=\"week\" i]:disabled::-webkit-clear-button,\ninput[type=\"week\" i]:disabled::-webkit-inner-spin-button,\ninput:disabled::-webkit-calendar-picker-indicator,\ninput[type=\"date\" i][readonly]::-webkit-clear-button,\ninput[type=\"date\" i][readonly]::-webkit-inner-spin-button,\ninput[type=\"datetime-local\" i][readonly]::-webkit-clear-button,\ninput[type=\"datetime-local\" i][readonly]::-webkit-inner-spin-button,\ninput[type=\"month\" i][readonly]::-webkit-clear-button,\ninput[type=\"month\" i][readonly]::-webkit-inner-spin-button,\ninput[type=\"week\" i][readonly]::-webkit-clear-button,\ninput[type=\"week\" i][readonly]::-webkit-inner-spin-button,\ninput[readonly]::-webkit-calendar-picker-indicator {\n    visibility: hidden;\n}\n\nselect {\n    -webkit-appearance: menulist;\n    box-sizing: border-box;\n    align-items: center;\n    border: 1px solid;\n    white-space: pre;\n    -webkit-rtl-ordering: logical;\n    color: black;\n    background-color: white;\n    cursor: default;\n}\n\nselect:not(:-internal-list-box) {\n    overflow: visible !important;\n}\n\nselect:-internal-list-box {\n    -webkit-appearance: listbox;\n    align-items: flex-start;\n    border: 1px inset gray;\n    border-radius: initial;\n    overflow-x: hidden;\n    overflow-y: scroll;\n    vertical-align: text-bottom;\n    -webkit-user-select: none;\n    white-space: nowrap;\n}\n\noptgroup {\n    font-weight: bolder;\n    display: block;\n}\n\noption {\n    font-weight: normal;\n    display: block;\n    padding: 0 2px 1px 2px;\n    white-space: pre;\n    min-height: 1.2em;\n}\n\nselect:-internal-list-box option,\nselect:-internal-list-box optgroup {\n    line-height: initial !important;\n}\n\nselect:-internal-list-box:focus option:checked {\n    background-color: -internal-active-list-box-selection !important;\n    color: -internal-active-list-box-selection-text !important;\n}\n\nselect:-internal-list-box option:checked {\n    background-color: -internal-inactive-list-box-selection !important;\n    color: -internal-inactive-list-box-selection-text !important;\n}\n\nselect:-internal-list-box:disabled option:checked,\nselect:-internal-list-box option:checked:disabled {\n    color: gray !important;\n}\n\nselect:-internal-list-box hr {\n    border-style: none;\n}\n\noutput {\n    display: inline;\n}\n\n/* meter */\n\nmeter {\n    -webkit-appearance: meter;\n    box-sizing: border-box;\n    display: inline-block;\n    height: 1em;\n    width: 5em;\n    vertical-align: -0.2em;\n}\n\nmeter::-webkit-meter-inner-element {\n    -webkit-appearance: inherit;\n    box-sizing: inherit;\n    -webkit-user-modify: read-only !important;\n    height: 100%;\n    width: 100%;\n}\n\nmeter::-webkit-meter-bar {\n    background: linear-gradient(to bottom, #ddd, #eee 20%, #ccc 45%, #ccc 55%, #ddd);\n    height: 100%;\n    width: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\nmeter::-webkit-meter-optimum-value {\n    background: linear-gradient(to bottom, #ad7, #cea 20%, #7a3 45%, #7a3 55%, #ad7);\n    height: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\nmeter::-webkit-meter-suboptimum-value {\n    background: linear-gradient(to bottom, #fe7, #ffc 20%, #db3 45%, #db3 55%, #fe7);\n    height: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\nmeter::-webkit-meter-even-less-good-value {\n    background: linear-gradient(to bottom, #f77, #fcc 20%, #d44 45%, #d44 55%, #f77);\n    height: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\n/* progress */\n\nprogress {\n    -webkit-appearance: progress-bar;\n    box-sizing: border-box;\n    display: inline-block;\n    height: 1em;\n    width: 10em;\n    vertical-align: -0.2em;\n}\n\nprogress::-webkit-progress-inner-element {\n    -webkit-appearance: inherit;\n    box-sizing: inherit;\n    -webkit-user-modify: read-only;\n    height: 100%;\n    width: 100%;\n}\n\nprogress::-webkit-progress-bar {\n    background-color: gray;\n    height: 100%;\n    width: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\nprogress::-webkit-progress-value {\n    background-color: green;\n    height: 100%;\n    width: 50%; /* should be removed later */\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\n/* inline elements */\n\nu, ins {\n    text-decoration: underline\n}\n\nstrong, b {\n    font-weight: bold\n}\n\ni, cite, em, var, address, dfn {\n    font-style: italic\n}\n\ntt, code, kbd, samp {\n    font-family: monospace\n}\n\npre, xmp, plaintext, listing {\n    display: block;\n    font-family: monospace;\n    white-space: pre;\n    margin: 1__qem 0\n}\n\nmark {\n    background-color: yellow;\n    color: black\n}\n\nbig {\n    font-size: larger\n}\n\nsmall {\n    font-size: smaller\n}\n\ns, strike, del {\n    text-decoration: line-through\n}\n\nsub {\n    vertical-align: sub;\n    font-size: smaller\n}\n\nsup {\n    vertical-align: super;\n    font-size: smaller\n}\n\nnobr {\n    white-space: nowrap\n}\n\n/* states */\n\n:focus {\n    outline: auto 5px -webkit-focus-ring-color\n}\n\n/* Read-only text fields do not show a focus ring but do still receive focus */\nhtml:focus, body:focus, input[readonly]:focus {\n    outline: none\n}\n\napplet:focus, embed:focus, iframe:focus, object:focus {\n    outline: none\n}\n\ninput:focus, textarea:focus, keygen:focus, select:focus {\n    outline-offset: -2px\n}\n\ninput[type=\"button\" i]:focus,\ninput[type=\"checkbox\" i]:focus,\ninput[type=\"file\" i]:focus,\ninput[type=\"hidden\" i]:focus,\ninput[type=\"image\" i]:focus,\ninput[type=\"radio\" i]:focus,\ninput[type=\"reset\" i]:focus,\ninput[type=\"search\" i]:focus,\ninput[type=\"submit\" i]:focus,\ninput[type=\"file\" i]:focus::-webkit-file-upload-button {\n    outline-offset: 0\n}\n\na:-webkit-any-link {\n    color: -webkit-link;\n    text-decoration: underline;\n    cursor: auto;\n}\n\na:-webkit-any-link:active {\n    color: -webkit-activelink\n}\n\n/* HTML5 ruby elements */\n\nruby, rt {\n    text-indent: 0; /* blocks used for ruby rendering should not trigger this */\n}\n\nrt {\n    line-height: normal;\n    -webkit-text-emphasis: none;\n}\n\nruby > rt {\n    display: block;\n    font-size: 50%;\n    text-align: start;\n}\n\nruby > rp {\n    display: none;\n}\n\n/* other elements */\n\nnoframes {\n    display: none\n}\n\nframeset, frame {\n    display: block\n}\n\nframeset {\n    border-color: inherit\n}\n\niframe {\n    border: 2px inset\n}\n\ndetails {\n    display: block\n}\n\nsummary {\n    display: block\n}\n\nsummary::-webkit-details-marker {\n    display: inline-block;\n    width: 0.66em;\n    height: 0.66em;\n    -webkit-margin-end: 0.4em;\n}\n\ntemplate {\n    display: none\n}\n\nbdi, output {\n    unicode-bidi: -webkit-isolate;\n}\n\nbdo {\n    unicode-bidi: bidi-override;\n}\n\ntextarea[dir=auto i] {\n    unicode-bidi: -webkit-plaintext;\n}\n\ndialog:not([open]) {\n    display: none\n}\n\ndialog {\n    position: absolute;\n    left: 0;\n    right: 0;\n    width: -webkit-fit-content;\n    height: -webkit-fit-content;\n    margin: auto;\n    border: solid;\n    padding: 1em;\n    background: white;\n    color: black\n}\n\ndialog::backdrop {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background: rgba(0,0,0,0.1)\n}\n\n/* page */\n\n@page {\n    /* FIXME: Define the right default values for page properties. */\n    size: auto;\n    margin: auto;\n    padding: 0px;\n    border-width: 0px;\n}\n\n/* noscript is handled internally, as it depends on settings. */\n\n`;\n"}