{"/home/travis/build/npmtest/node-npmtest-jsdom/test.js":"/* istanbul instrument in package npmtest_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdom/lib.npmtest_jsdom.js":"/* istanbul instrument in package npmtest_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jsdom = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jsdom = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdom/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jsdom && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jsdom\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jsdom.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jsdom.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jsdom.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jsdom.__dirname + '/lib.npmtest_jsdom.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/api.js":"\"use strict\";\nconst path = require(\"path\");\nconst fs = require(\"pn/fs\");\nconst vm = require(\"vm\");\nconst toughCookie = require(\"tough-cookie\");\nconst request = require(\"request-promise-native\");\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\nconst whatwgURL = require(\"whatwg-url\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst { URL } = require(\"whatwg-url\");\nconst parseContentType = require(\"content-type-parser\");\nconst idlUtils = require(\"./jsdom/living/generated/utils.js\");\nconst VirtualConsole = require(\"./jsdom/virtual-console.js\");\nconst Window = require(\"./jsdom/browser/Window.js\");\nconst { locationInfo } = require(\"./jsdom/living/helpers/internal-constants.js\");\nconst { domToHtml } = require(\"./jsdom/browser/domtohtml.js\");\nconst { applyDocumentFeatures } = require(\"./jsdom/browser/documentfeatures.js\");\nconst { wrapCookieJarForRequest } = require(\"./jsdom/browser/resource-loader.js\");\nconst { version: packageVersion } = require(\"../package.json\");\n\nconst DEFAULT_USER_AGENT = `Mozilla/5.0 (${process.platform}) AppleWebKit/537.36 (KHTML, like Gecko) ` +\n                           `jsdom/${packageVersion}`;\n\n// This symbol allows us to smuggle a non-public option through to the JSDOM constructor, for use by JSDOM.fromURL.\nconst transportLayerEncodingLabelHiddenOption = Symbol(\"transportLayerEncodingLabel\");\n\nclass CookieJar extends toughCookie.CookieJar {\n  constructor(store, options) {\n    // jsdom cookie jars must be loose by default\n    super(store, Object.assign({ looseMode: true }, options));\n  }\n}\n\nconst window = Symbol(\"window\");\nlet sharedFragmentDocument = null;\n\nclass JSDOM {\n  constructor(input, options = {}) {\n    const { html, encoding } = normalizeHTML(input, options[transportLayerEncodingLabelHiddenOption]);\n    options = transformOptions(options, encoding);\n\n    this[window] = new Window(options.windowOptions);\n\n    // TODO NEWAPI: the whole \"features\" infrastructure is horrible and should be re-built. When we switch to newapi\n    // wholesale, or perhaps before, we should re-do it. For now, just adapt the new, nice, public API into the old,\n    // ugly, internal API.\n    const features = {\n      FetchExternalResources: [],\n      ProcessExternalResources: false,\n      SkipExternalResources: false\n    };\n    if (options.runScripts === \"dangerously\") {\n      features.ProcessExternalResources = [\"script\"];\n    }\n\n    if (options.resources === \"usable\") {\n      features.FetchExternalResources = [\"link\", \"img\", \"frame\", \"iframe\"];\n      if (options.runScripts === \"dangerously\") {\n        features.FetchExternalResources.push(\"script\");\n      }\n\n      // Note that \"img\" will be ignored by the code in HTMLImageElement-impl.js if canvas is not installed.\n      // TODO NEWAPI: clean that up and centralize the logic here.\n    }\n\n    const documentImpl = idlUtils.implForWrapper(this[window]._document);\n    applyDocumentFeatures(documentImpl, features);\n\n    if (options.runScripts === \"outside-only\") {\n      vm.createContext(this[window]);\n      this[window]._document._defaultView = this[window]._globalProxy = vm.runInContext(\"this\", this[window]);\n    }\n\n    options.beforeParse(this[window]._globalProxy);\n\n    // TODO NEWAPI: this is still pretty hacky. It's also different than jsdom.jsdom. Does it work? Can it be better?\n    documentImpl._htmlToDom.appendHtmlToDocument(html, documentImpl);\n    documentImpl.close();\n  }\n\n  get window() {\n    // It's important to grab the global proxy, instead of just the result of `new Window(...)`, since otherwise things\n    // like `window.eval` don't exist.\n    return this[window]._globalProxy;\n  }\n\n  get virtualConsole() {\n    return this[window]._virtualConsole;\n  }\n\n  get cookieJar() {\n    // TODO NEWAPI move _cookieJar to window probably\n    return idlUtils.implForWrapper(this[window]._document)._cookieJar;\n  }\n\n  serialize() {\n    return domToHtml([this[window]._document]);\n  }\n\n  nodeLocation(node) {\n    if (!idlUtils.implForWrapper(this[window]._document)._parseOptions.locationInfo) {\n      throw new Error(\"Location information was not saved for this jsdom. Use includeNodeLocations during creation.\");\n    }\n\n    return idlUtils.implForWrapper(node)[locationInfo];\n  }\n\n  runVMScript(script) {\n    if (!vm.isContext(this[window])) {\n      throw new TypeError(\"This jsdom was not configured to allow script running. \" +\n        \"Use the runScripts option during creation.\");\n    }\n\n    return script.runInContext(this[window]);\n  }\n\n  reconfigure(settings) {\n    if (\"windowTop\" in settings) {\n      this[window]._top = settings.windowTop;\n    }\n\n    if (\"url\" in settings) {\n      const document = idlUtils.implForWrapper(this[window]._document);\n\n      const url = whatwgURL.parseURL(settings.url);\n      if (url === \"failure\") {\n        throw new TypeError(`Could not parse \"${settings.url}\" as a URL`);\n      }\n\n      document._URL = url;\n      document._origin = whatwgURL.serializeURLToUnicodeOrigin(document._URL);\n    }\n  }\n\n  static fragment(string) {\n    if (!sharedFragmentDocument) {\n      sharedFragmentDocument = (new JSDOM()).window.document;\n    }\n\n    const template = sharedFragmentDocument.createElement(\"template\");\n    template.innerHTML = string;\n    return template.content;\n  }\n\n  static fromURL(url, options = {}) {\n    return Promise.resolve().then(() => {\n      const parsedURL = new URL(url);\n      url = parsedURL.href;\n      options = normalizeFromURLOptions(options);\n\n      const requestOptions = {\n        resolveWithFullResponse: true,\n        encoding: null, // i.e., give me the raw Buffer\n        gzip: true,\n        headers: {\n          \"User-Agent\": options.userAgent,\n          Referer: options.referrer,\n          Accept: \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n          \"Accept-Language\": \"en\"\n        },\n        jar: wrapCookieJarForRequest(options.cookieJar)\n      };\n\n      return request(url, requestOptions).then(res => {\n        const parsedContentType = parseContentType(res.headers[\"content-type\"]);\n        const transportLayerEncodingLabel = parsedContentType && parsedContentType.get(\"charset\");\n\n        options = Object.assign(options, {\n          url: res.request.href + parsedURL.hash,\n          contentType: res.headers[\"content-type\"],\n          referrer: res.request.getHeader(\"referer\"),\n          [transportLayerEncodingLabelHiddenOption]: transportLayerEncodingLabel\n        });\n\n        return new JSDOM(res.body, options);\n      });\n    });\n  }\n\n  static fromFile(filename, options = {}) {\n    return Promise.resolve().then(() => {\n      options = normalizeFromFileOptions(filename, options);\n\n      return fs.readFile(filename).then(buffer => {\n        return new JSDOM(buffer, options);\n      });\n    });\n  }\n}\n\nfunction normalizeFromURLOptions(options) {\n  // Checks on options that are invalid for `fromURL`\n  if (options.url !== undefined) {\n    throw new TypeError(\"Cannot supply a url option when using fromURL\");\n  }\n  if (options.contentType !== undefined) {\n    throw new TypeError(\"Cannot supply a contentType option when using fromURL\");\n  }\n\n  // Normalization of options which must be done before the rest of the fromURL code can use them, because they are\n  // given to request()\n  const normalized = Object.assign({}, options);\n  if (options.userAgent === undefined) {\n    normalized.userAgent = DEFAULT_USER_AGENT;\n  }\n\n  if (options.referrer !== undefined) {\n    normalized.referrer = (new URL(options.referrer)).href;\n  }\n\n  if (options.cookieJar === undefined) {\n    normalized.cookieJar = new CookieJar();\n  }\n\n  return normalized;\n\n  // All other options don't need to be processed yet, and can be taken care of in the normal course of things when\n  // `fromURL` calls `new JSDOM(html, options)`.\n}\n\nfunction normalizeFromFileOptions(filename, options) {\n  const normalized = Object.assign({}, options);\n\n  if (normalized.contentType === undefined) {\n    const extname = path.extname(filename);\n    if (extname === \".xhtml\" || extname === \".xml\") {\n      normalized.contentType = \"application/xhtml+xml\";\n    }\n  }\n\n  if (normalized.url === undefined) {\n    normalized.url = new URL(\"file:\" + path.resolve(filename));\n  }\n\n  return normalized;\n}\n\nfunction transformOptions(options, encoding) {\n  const transformed = {\n    windowOptions: {\n      // Defaults\n      url: \"about:blank\",\n      referrer: \"\",\n      contentType: \"text/html\",\n      parsingMode: \"html\",\n      userAgent: DEFAULT_USER_AGENT,\n      parseOptions: { locationInfo: false },\n      encoding,\n\n      // Defaults filled in later\n      virtualConsole: undefined,\n      cookieJar: undefined\n    },\n\n    // Defaults\n    resources: undefined,\n    runScripts: undefined,\n    beforeParse() { }\n  };\n\n  if (options.contentType !== undefined) {\n    const contentTypeParsed = parseContentType(options.contentType);\n    if (contentTypeParsed === null) {\n      throw new TypeError(`Could not parse the given content type of \"${options.contentType}\"`);\n    }\n\n    if (!contentTypeParsed.isHTML() && !contentTypeParsed.isXML()) {\n      throw new RangeError(`The given content type of \"${options.contentType}\" was not a HTML or XML content type`);\n    }\n\n    transformed.windowOptions.contentType = contentTypeParsed.type + \"/\" + contentTypeParsed.subtype;\n    transformed.windowOptions.parsingMode = contentTypeParsed.isHTML() ? \"html\" : \"xml\";\n  }\n\n  if (options.url !== undefined) {\n    transformed.windowOptions.url = (new URL(options.url)).href;\n  }\n\n  if (options.referrer !== undefined) {\n    transformed.windowOptions.referrer = (new URL(options.referrer)).href;\n  }\n\n  if (options.userAgent !== undefined) {\n    transformed.windowOptions.userAgent = String(options.userAgent);\n  }\n\n  if (options.includeNodeLocations) {\n    if (transformed.windowOptions.parsingMode === \"xml\") {\n      throw new TypeError(\"Cannot set includeNodeLocations to true with an XML content type\");\n    }\n\n    transformed.windowOptions.parseOptions = { locationInfo: true };\n  }\n\n  transformed.windowOptions.cookieJar = options.cookieJar === undefined ?\n                                       new CookieJar() :\n                                       options.cookieJar;\n\n  transformed.windowOptions.virtualConsole = options.virtualConsole === undefined ?\n                                            (new VirtualConsole()).sendTo(console) :\n                                            options.virtualConsole;\n\n  if (options.resources !== undefined) {\n    transformed.resources = String(options.resources);\n    if (transformed.resources !== \"usable\") {\n      throw new RangeError(`resources must be undefined or \"usable\"`);\n    }\n  }\n\n  if (options.runScripts !== undefined) {\n    transformed.runScripts = String(options.runScripts);\n    if (transformed.runScripts !== \"dangerously\" && transformed.runScripts !== \"outside-only\") {\n      throw new RangeError(`runScripts must be undefined, \"dangerously\", or \"outside-only\"`);\n    }\n  }\n\n  if (options.beforeParse !== undefined) {\n    transformed.beforeParse = options.beforeParse;\n  }\n\n  // concurrentNodeIterators??\n\n  return transformed;\n}\n\nfunction normalizeHTML(html = \"\", transportLayerEncodingLabel) {\n  let encoding = \"UTF-8\";\n\n  if (ArrayBuffer.isView(html)) {\n    html = Buffer.from(html.buffer, html.byteOffset, html.byteLength);\n  } else if (html instanceof ArrayBuffer) {\n    html = Buffer.from(html);\n  }\n\n  if (Buffer.isBuffer(html)) {\n    encoding = sniffHTMLEncoding(html, { defaultEncoding: \"windows-1252\", transportLayerEncodingLabel });\n    html = whatwgEncoding.decode(html, encoding);\n  } else {\n    html = String(html);\n  }\n\n  return { html, encoding };\n}\n\nexports.JSDOM = JSDOM;\n\nexports.VirtualConsole = VirtualConsole;\nexports.CookieJar = CookieJar;\n\nexports.toughCookie = toughCookie;\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/old-api.js":"\"use strict\";\n/* eslint-disable no-unused-expressions */\n() => `jsdom 7.x onward only works on Node.js 4 or newer: https://github.com/tmpvar/jsdom#install`;\n/* eslint-enable no-unused-expressions */\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst CookieJar = require(\"tough-cookie\").CookieJar;\nconst parseContentType = require(\"content-type-parser\");\n\nconst toFileUrl = require(\"./jsdom/utils\").toFileUrl;\nconst documentFeatures = require(\"./jsdom/browser/documentfeatures\");\nconst domToHtml = require(\"./jsdom/browser/domtohtml\").domToHtml;\nconst Window = require(\"./jsdom/browser/Window\");\nconst resourceLoader = require(\"./jsdom/browser/resource-loader\");\nconst VirtualConsole = require(\"./jsdom/virtual-console\");\nconst locationInfo = require(\"./jsdom/living/helpers/internal-constants\").locationInfo;\nconst idlUtils = require(\"./jsdom/living/generated/utils\");\nconst Blob = require(\"./jsdom/living/generated/Blob\");\n\nconst whatwgURL = require(\"whatwg-url\");\n\nrequire(\"./jsdom/living\"); // Enable living standard features\n\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\nconst URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\nconst canReadFilesFromFS = Boolean(fs.readFile); // in a browserify environment, this isn't present\n\nexports.createVirtualConsole = function (options) {\n  return new VirtualConsole(options);\n};\n\nexports.getVirtualConsole = function (window) {\n  return window._virtualConsole;\n};\n\nexports.createCookieJar = function () {\n  return new CookieJar(null, { looseMode: true });\n};\n\nexports.nodeLocation = function (node) {\n  return idlUtils.implForWrapper(node)[locationInfo];\n};\n\nexports.reconfigureWindow = function (window, newProps) {\n  if (\"top\" in newProps) {\n    window._top = newProps.top;\n  }\n};\n\nexports.changeURL = function (window, urlString) {\n  const doc = idlUtils.implForWrapper(window._document);\n\n  const url = whatwgURL.parseURL(urlString);\n\n  if (url === \"failure\") {\n    throw new TypeError(`Could not parse \"${urlString}\" as a URL`);\n  }\n\n  doc._URL = url;\n  doc._origin = whatwgURL.serializeURLToUnicodeOrigin(doc._URL);\n};\n\n// Proxy to features module\nObject.defineProperty(exports, \"defaultDocumentFeatures\", {\n  enumerable: true,\n  configurable: true,\n  get() {\n    return documentFeatures.defaultDocumentFeatures;\n  },\n  set(v) {\n    documentFeatures.defaultDocumentFeatures = v;\n  }\n});\n\nexports.jsdom = function (html, options) {\n  if (options === undefined) {\n    options = {};\n  }\n  if (options.parsingMode === undefined || options.parsingMode === \"auto\") {\n    options.parsingMode = \"html\";\n  }\n\n  if (options.parsingMode !== \"html\" && options.parsingMode !== \"xml\") {\n    throw new RangeError(`Invalid parsingMode option ${JSON.stringify(options.parsingMode)}; must be either \"html\", ` +\n      `\"xml\", \"auto\", or undefined`);\n  }\n\n  options.encoding = options.encoding || \"UTF-8\";\n\n  setGlobalDefaultConfig(options);\n\n  // Back-compat hack: we have previously suggested nesting these under document, for jsdom.env at least.\n  // So we need to support that.\n  if (options.document) {\n    if (options.document.cookie !== undefined) {\n      options.cookie = options.document.cookie;\n    }\n    if (options.document.referrer !== undefined) {\n      options.referrer = options.document.referrer;\n    }\n  }\n\n  // List options explicitly to be clear which are passed through\n  const window = new Window({\n    parsingMode: options.parsingMode,\n    parseOptions: options.parseOptions,\n    contentType: options.contentType,\n    encoding: options.encoding,\n    parser: options.parser,\n    url: options.url,\n    lastModified: options.lastModified,\n    referrer: options.referrer,\n    cookieJar: options.cookieJar,\n    cookie: options.cookie,\n    resourceLoader: options.resourceLoader,\n    deferClose: options.deferClose,\n    concurrentNodeIterators: options.concurrentNodeIterators,\n    virtualConsole: options.virtualConsole,\n    pool: options.pool,\n    agent: options.agent,\n    agentClass: options.agentClass,\n    agentOptions: options.agentOptions,\n    strictSSL: options.strictSSL,\n    proxy: options.proxy,\n    userAgent: options.userAgent\n  });\n\n  const documentImpl = idlUtils.implForWrapper(window.document);\n  documentFeatures.applyDocumentFeatures(documentImpl, options.features);\n\n  if (options.created) {\n    options.created(null, window.document.defaultView);\n  }\n\n  if (options.parsingMode === \"html\") {\n    if (html === undefined || html === \"\") {\n      html = \"<html><head></head><body></body></html>\";\n    }\n\n    window.document.write(html);\n  } else if (options.parsingMode === \"xml\") {\n    if (html !== undefined) {\n      documentImpl._htmlToDom.appendHtmlToDocument(html, documentImpl);\n    }\n  }\n\n  if (window.document.close && !options.deferClose) {\n    window.document.close();\n  }\n\n  return window.document;\n};\n\nexports.jQueryify = exports.jsdom.jQueryify = function (window, jqueryUrl, callback) {\n  if (!window || !window.document) {\n    return;\n  }\n\n  const implImpl = idlUtils.implForWrapper(window.document.implementation);\n  const features = implImpl._features;\n  implImpl._addFeature(\"FetchExternalResources\", [\"script\"]);\n  implImpl._addFeature(\"ProcessExternalResources\", [\"script\"]);\n\n  const scriptEl = window.document.createElement(\"script\");\n  scriptEl.className = \"jsdom\";\n  scriptEl.src = jqueryUrl;\n  scriptEl.onload = scriptEl.onerror = () => {\n    implImpl._features = features;\n\n    if (callback) {\n      callback(window, window.jQuery);\n    }\n  };\n\n  window.document.body.appendChild(scriptEl);\n};\n\nexports.env = exports.jsdom.env = function () {\n  const config = getConfigFromArguments(arguments);\n  let req = null;\n\n  if (config.file && canReadFilesFromFS) {\n    req = resourceLoader.readFile(config.file,\n    { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },\n    (err, text, res) => {\n      if (err) {\n        reportInitError(err, config);\n        return;\n      }\n\n      const contentType = parseContentType(res.headers[\"content-type\"]);\n      config.encoding = contentType.get(\"charset\");\n      setParsingModeFromExtension(config, config.file);\n\n      config.html = text;\n      processHTML(config);\n    });\n  } else if (config.html !== undefined) {\n    processHTML(config);\n  } else if (config.url) {\n    req = handleUrl(config);\n  } else if (config.somethingToAutodetect !== undefined) {\n    const url = URL.parse(config.somethingToAutodetect);\n    if (url.protocol && url.hostname) {\n      config.url = config.somethingToAutodetect;\n      req = handleUrl(config.somethingToAutodetect);\n    } else if (canReadFilesFromFS) {\n      req = resourceLoader.readFile(config.somethingToAutodetect,\n      { defaultEncoding: config.defaultEncoding, detectMetaCharset: true },\n      (err, text, res) => {\n        if (err) {\n          if (err.code === \"ENOENT\" || err.code === \"ENAMETOOLONG\") {\n            config.html = config.somethingToAutodetect;\n            processHTML(config);\n          } else {\n            reportInitError(err, config);\n          }\n        } else {\n          const contentType = parseContentType(res.headers[\"content-type\"]);\n          config.encoding = contentType.get(\"charset\");\n          setParsingModeFromExtension(config, config.somethingToAutodetect);\n\n          config.html = text;\n          config.url = toFileUrl(config.somethingToAutodetect);\n          processHTML(config);\n        }\n      });\n    } else {\n      config.html = config.somethingToAutodetect;\n      processHTML(config);\n    }\n  }\n\n  function handleUrl() {\n    config.cookieJar = config.cookieJar || exports.createCookieJar();\n\n    const options = {\n      defaultEncoding: config.defaultEncoding,\n      detectMetaCharset: true,\n      headers: config.headers,\n      pool: config.pool,\n      strictSSL: config.strictSSL,\n      proxy: config.proxy,\n      cookieJar: config.cookieJar,\n      userAgent: config.userAgent,\n      agent: config.agent,\n      agentClass: config.agentClass,\n      agentOptions: config.agentOptions\n    };\n\n    const fragment = whatwgURL.parseURL(config.url).fragment;\n\n    return resourceLoader.download(config.url, options, (err, responseText, res) => {\n      if (err) {\n        reportInitError(err, config);\n        return;\n      }\n\n      // The use of `res.request.uri.href` ensures that `window.location.href`\n      // is updated when `request` follows redirects.\n      config.html = responseText;\n      config.url = res.request.uri.href;\n      if (fragment) {\n        config.url += `#${fragment}`;\n      }\n\n      if (res.headers[\"last-modified\"]) {\n        config.lastModified = new Date(res.headers[\"last-modified\"]);\n      }\n\n      const contentType = parseContentType(res.headers[\"content-type\"]);\n      if (config.parsingMode === \"auto\") {\n        if (contentType.isXML()) {\n          config.parsingMode = \"xml\";\n        }\n      }\n      config.encoding = contentType.get(\"charset\");\n\n      processHTML(config);\n    });\n  }\n  return req;\n};\n\nexports.serializeDocument = function (doc) {\n  return domToHtml([doc]);\n};\n\nexports.blobToBuffer = function (blob) {\n  return Blob.is(blob) && idlUtils.implForWrapper(blob)._buffer || undefined;\n};\n\nexports.evalVMScript = (window, script) => {\n  return script.runInContext(idlUtils.implForWrapper(window._document)._global);\n};\n\nfunction processHTML(config) {\n  const window = exports.jsdom(config.html, config).defaultView;\n  const implImpl = idlUtils.implForWrapper(window.document.implementation);\n  const features = JSON.parse(JSON.stringify(implImpl._features));\n\n  let docsLoaded = 0;\n  const totalDocs = config.scripts.length + config.src.length;\n\n  if (!window || !window.document) {\n    reportInitError(new Error(\"JSDOM: a window object could not be created.\"), config);\n    return;\n  }\n\n  function scriptComplete() {\n    docsLoaded++;\n\n    if (docsLoaded >= totalDocs) {\n      implImpl._features = features;\n\n      process.nextTick(() => {\n        if (config.onload) {\n          config.onload(window);\n        }\n        if (config.done) {\n          config.done(null, window);\n        }\n      });\n    }\n  }\n\n  function handleScriptError() {\n    // nextTick so that an exception within scriptComplete won't cause\n    // another script onerror (which would be an infinite loop)\n    process.nextTick(scriptComplete);\n  }\n\n  if (config.scripts.length > 0 || config.src.length > 0) {\n    implImpl._addFeature(\"FetchExternalResources\", [\"script\"]);\n    implImpl._addFeature(\"ProcessExternalResources\", [\"script\"]);\n\n    for (const scriptSrc of config.scripts) {\n      const script = window.document.createElement(\"script\");\n      script.className = \"jsdom\";\n      script.onload = scriptComplete;\n      script.onerror = handleScriptError;\n      script.src = scriptSrc;\n\n      window.document.body.appendChild(script);\n    }\n\n    for (const scriptText of config.src) {\n      const script = window.document.createElement(\"script\");\n      script.onload = scriptComplete;\n      script.onerror = handleScriptError;\n      script.text = scriptText;\n\n      window.document.documentElement.appendChild(script);\n      window.document.documentElement.removeChild(script);\n    }\n  } else if (window.document.readyState === \"complete\") {\n    scriptComplete();\n  } else {\n    window.addEventListener(\"load\", scriptComplete);\n  }\n}\n\nfunction setGlobalDefaultConfig(config) {\n  config.parseOptions = { locationInfo: true };\n\n  config.pool = config.pool !== undefined ? config.pool : {\n    maxSockets: 6\n  };\n\n  config.agentOptions = config.agentOptions !== undefined ? config.agentOptions : {\n    keepAlive: true,\n    keepAliveMsecs: 115 * 1000\n  };\n\n  config.strictSSL = config.strictSSL !== undefined ? config.strictSSL : true;\n\n  config.userAgent = config.userAgent ||\n    `Node.js (${process.platform}; U; rv:${process.version}) AppleWebKit/537.36 (KHTML, like Gecko)`;\n}\n\nfunction getConfigFromArguments(args) {\n  const config = {};\n  if (typeof args[0] === \"object\") {\n    Object.assign(config, args[0]);\n  } else {\n    for (const arg of args) {\n      switch (typeof arg) {\n        case \"string\":\n          config.somethingToAutodetect = arg;\n          break;\n        case \"function\":\n          config.done = arg;\n          break;\n        case \"object\":\n          if (Array.isArray(arg)) {\n            config.scripts = arg;\n          } else {\n            Object.assign(config, arg);\n          }\n          break;\n      }\n    }\n  }\n\n  if (!config.done && !config.created && !config.onload) {\n    throw new Error(\"Must pass a \\\"created\\\", \\\"onload\\\", or \\\"done\\\" option, or a callback, to jsdom.env\");\n  }\n\n  if (config.somethingToAutodetect === undefined &&\n      config.html === undefined && !config.file && !config.url) {\n    throw new Error(\"Must pass a \\\"html\\\", \\\"file\\\", or \\\"url\\\" option, or a string, to jsdom.env\");\n  }\n\n  config.scripts = ensureArray(config.scripts);\n  config.src = ensureArray(config.src);\n  config.parsingMode = config.parsingMode || \"auto\";\n\n  config.features = config.features || {\n    FetchExternalResources: false,\n    ProcessExternalResources: false,\n    SkipExternalResources: false\n  };\n\n  if (!config.url && config.file) {\n    config.url = toFileUrl(config.file);\n  }\n\n  config.defaultEncoding = config.defaultEncoding || \"windows-1252\";\n\n  setGlobalDefaultConfig(config);\n\n  return config;\n}\n\nfunction reportInitError(err, config) {\n  if (config.created) {\n    config.created(err);\n  }\n  if (config.done) {\n    config.done(err);\n  }\n}\n\nfunction ensureArray(value) {\n  let array = value || [];\n  if (typeof array === \"string\") {\n    array = [array];\n  }\n  return array;\n}\n\nfunction setParsingModeFromExtension(config, filename) {\n  if (config.parsingMode === \"auto\") {\n    const ext = path.extname(filename);\n    if (ext === \".xhtml\" || ext === \".xml\") {\n      config.parsingMode = \"xml\";\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/utils.js":"\"use strict\";\nconst path = require(\"path\");\nconst whatwgURL = require(\"whatwg-url\");\nconst querystring = require(\"querystring\");\nconst domSymbolTree = require(\"./living/helpers/internal-constants\").domSymbolTree;\nconst SYMBOL_TREE_POSITION = require(\"symbol-tree\").TreePosition;\nconst parseURLToResultingURLRecord = require(\"./living/helpers/document-base-url\").parseURLToResultingURLRecord;\n\nexports.toFileUrl = function (fileName) {\n  // Beyond just the `path.resolve`, this is mostly for the benefit of Windows,\n  // where we need to convert \"\\\" to \"/\" and add an extra \"/\" prefix before the\n  // drive letter.\n  let pathname = path.resolve(process.cwd(), fileName).replace(/\\\\/g, \"/\");\n  if (pathname[0] !== \"/\") {\n    pathname = \"/\" + pathname;\n  }\n\n  // path might contain spaces, so convert those to %20\n  return \"file://\" + encodeURI(pathname);\n};\n\n/**\n * Define a getter on an object\n *\n * This method replaces any existing getter but leaves setters in place.\n *\n * - `object` {Object} the object to define the getter on\n * - `property` {String} the name of the getter\n * - `getterFn` {Function} the getter\n */\nexports.defineGetter = function defineGetter(object, property, getterFn) {\n  const descriptor = Object.getOwnPropertyDescriptor(object, property) || {\n    configurable: true,\n    enumerable: true\n  };\n\n  descriptor.get = getterFn;\n\n  Object.defineProperty(object, property, descriptor);\n};\n\n/**\n * Define a set of properties on an object, by copying the property descriptors\n * from the original object.\n *\n * - `object` {Object} the target object\n * - `properties` {Object} the source from which to copy property descriptors\n */\nexports.define = function define(object, properties) {\n  for (const name of Object.getOwnPropertyNames(properties)) {\n    const propDesc = Object.getOwnPropertyDescriptor(properties, name);\n    Object.defineProperty(object, name, propDesc);\n  }\n};\n\n/**\n * Define a list of constants on a constructor and its .prototype\n *\n * - `Constructor` {Function} the constructor to define the constants on\n * - `propertyMap` {Object}  key/value map of properties to define\n */\nexports.addConstants = function addConstants(Constructor, propertyMap) {\n  for (const property in propertyMap) {\n    const value = propertyMap[property];\n    addConstant(Constructor, property, value);\n    addConstant(Constructor.prototype, property, value);\n  }\n};\n\nfunction addConstant(object, property, value) {\n  Object.defineProperty(object, property, {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value\n  });\n}\n\nlet memoizeQueryTypeCounter = 0;\n\n/**\n * Returns a version of a method that memoizes specific types of calls on the object\n *\n * - `fn` {Function} the method to be memozied\n */\nexports.memoizeQuery = function memoizeQuery(fn) {\n  // Only memoize query functions with arity <= 2\n  if (fn.length > 2) {\n    return fn;\n  }\n\n  const type = memoizeQueryTypeCounter++;\n\n  return function () {\n    if (!this._memoizedQueries) {\n      return fn.apply(this, arguments);\n    }\n\n    if (!this._memoizedQueries[type]) {\n      this._memoizedQueries[type] = Object.create(null);\n    }\n\n    let key;\n    if (arguments.length === 1 && typeof arguments[0] === \"string\") {\n      key = arguments[0];\n    } else if (arguments.length === 2 && typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n      key = arguments[0] + \"::\" + arguments[1];\n    } else {\n      return fn.apply(this, arguments);\n    }\n\n    if (!(key in this._memoizedQueries[type])) {\n      this._memoizedQueries[type][key] = fn.apply(this, arguments);\n    }\n    return this._memoizedQueries[type][key];\n  };\n};\n\nexports.reflectURLAttribute = (elementImpl, contentAttributeName) => {\n  const attributeValue = elementImpl.getAttribute(contentAttributeName);\n  if (attributeValue === null || attributeValue === \"\") {\n    return \"\";\n  }\n\n  const urlRecord = parseURLToResultingURLRecord(attributeValue, elementImpl._ownerDocument);\n  if (urlRecord === \"failure\") {\n    return attributeValue;\n  }\n  return whatwgURL.serializeURL(urlRecord);\n};\n\nfunction isValidAbsoluteURL(str) {\n  return whatwgURL.parseURL(str) !== \"failure\";\n}\n\nexports.isValidTargetOrigin = function (str) {\n  return str === \"*\" || str === \"/\" || isValidAbsoluteURL(str);\n};\n\nexports.simultaneousIterators = function* (first, second) {\n  for (;;) {\n    const firstResult = first.next();\n    const secondResult = second.next();\n\n    if (firstResult.done && secondResult.done) {\n      return;\n    }\n\n    yield [\n      firstResult.done ? null : firstResult.value,\n      secondResult.done ? null : secondResult.value\n    ];\n  }\n};\n\nexports.treeOrderSorter = function (a, b) {\n  const compare = domSymbolTree.compareTreePosition(a, b);\n\n  if (compare & SYMBOL_TREE_POSITION.PRECEDING) { // b is preceding a\n    return 1;\n  }\n\n  if (compare & SYMBOL_TREE_POSITION.FOLLOWING) {\n    return -1;\n  }\n\n  // disconnected or equal:\n  return 0;\n};\n\nexports.lengthFromProperties = function (arrayLike) {\n  let max = -1;\n  const keys = Object.keys(arrayLike);\n  const highestKeyIndex = keys.length - 1;\n\n  // Abuses a v8 implementation detail for a very fast case\n  // (if this implementation detail changes, this method will still\n  //  return correct results)\n  /* eslint-disable eqeqeq */\n  if (highestKeyIndex == keys[highestKeyIndex]) { // not ===\n    /* eslint-enable eqeqeq */\n    return keys.length;\n  }\n\n  for (let i = highestKeyIndex; i >= 0; --i) {\n    const asNumber = Number(keys[i]);\n\n    if (!Number.isNaN(asNumber) && asNumber > max) {\n      max = asNumber;\n    }\n  }\n  return max + 1;\n};\n\nconst base64Regexp = /^(?:[A-Z0-9+/]{4})*(?:[A-Z0-9+/]{2}==|[A-Z0-9+/]{3}=|[A-Z0-9+/]{4})$/i;\n\nexports.parseDataUrl = function parseDataUrl(url) {\n  const urlParts = url.match(/^data:(.+?)(?:;(base64))?,(.*)$/);\n  let buffer;\n  if (urlParts[2] === \"base64\") {\n    if (urlParts[3] && !base64Regexp.test(urlParts[3])) {\n      throw new Error(\"Not a base64 string\");\n    }\n    buffer = new Buffer(urlParts[3], \"base64\");\n  } else {\n    buffer = new Buffer(querystring.unescape(urlParts[3]));\n  }\n  return { buffer, type: urlParts[1] };\n};\n\n/* eslint-disable global-require */\n\nexports.Canvas = null;\n[\"canvas\", \"canvas-prebuilt\"].some(moduleName => {\n  try {\n    exports.Canvas = require(moduleName);\n    if (typeof exports.Canvas !== \"function\") {\n      // In browserify, the require will succeed but return an empty object\n      exports.Canvas = null;\n    }\n  } catch (e) {\n    exports.Canvas = null;\n  }\n  return exports.Canvas !== null;\n});\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/helpers/internal-constants.js":"\"use strict\";\nconst SymbolTree = require(\"symbol-tree\");\n\nexports.cloningSteps = Symbol(\"cloning steps\");\nexports.locationInfo = Symbol(\"location info\");\n\n// TODO: the many underscore-prefixed hooks should move here\n// E.g. _attrModified (which maybe should be split into its per-spec variants)\n\n/**\n * This SymbolTree is used to build the tree for all Node in a document\n */\nexports.domSymbolTree = new SymbolTree(\"DOM SymbolTree\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/helpers/document-base-url.js":"\"use strict\";\nconst internalQuerySelector = require(\"./selectors\").querySelector;\nconst whatwgURL = require(\"whatwg-url\");\n\nexports.documentBaseURL = document => {\n  // https://html.spec.whatwg.org/multipage/infrastructure.html#document-base-url\n\n  const firstBase = internalQuerySelector(document, \"base[href]\");\n  const fallbackBaseURL = exports.fallbackBaseURL(document);\n\n  if (firstBase === null) {\n    return fallbackBaseURL;\n  }\n\n  return frozenBaseURL(firstBase, fallbackBaseURL);\n};\n\nexports.documentBaseURLSerialized = document => {\n  return whatwgURL.serializeURL(exports.documentBaseURL(document));\n};\n\nexports.fallbackBaseURL = document => {\n  // https://html.spec.whatwg.org/multipage/infrastructure.html#fallback-base-url\n\n  // Unimplemented: <iframe srcdoc>\n\n  if (document.URL === \"about:blank\" && document._defaultView &&\n      document._defaultView._parent !== document._defaultView) {\n    return exports.documentBaseURL(document._defaultView._parent._document);\n  }\n\n  return document._URL;\n};\n\nexports.parseURLToResultingURLRecord = (url, document) => {\n  // https://html.spec.whatwg.org/#resolve-a-url\n\n  // Encoding stuff ignored; always UTF-8 for us, for now.\n\n  const baseURL = exports.documentBaseURL(document);\n\n  return whatwgURL.parseURL(url, { baseURL });\n  // This returns the resulting URL record; to get the resulting URL string, just serialize it.\n};\n\nfunction frozenBaseURL(baseElement, fallbackBaseURL) {\n  // https://html.spec.whatwg.org/multipage/semantics.html#frozen-base-url\n  // The spec is eager (setting the frozen base URL when things change); we are lazy (getting it when we need to)\n\n  const baseHrefAttribute = baseElement.getAttribute(\"href\");\n  const result = whatwgURL.parseURL(baseHrefAttribute, { baseURL: fallbackBaseURL });\n  return result === \"failure\" ? fallbackBaseURL : result;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/helpers/selectors.js":"\"use strict\";\n\nconst idlUtils = require(\"../generated/utils\");\nconst nwmatcher = require(\"nwmatcher/src/nwmatcher-noqsa\");\nconst domSymbolTree = require(\"./internal-constants\").domSymbolTree;\n\n// Internal method so you don't have to go through the public API\nexports.querySelector = function (parentNode, selectors) {\n  if (!domSymbolTree.hasChildren(parentNode) ||\n      (parentNode === parentNode._ownerDocument && !parentNode.documentElement)) {\n    // This allows us to avoid the explosion that occurs if you try to add nwmatcher to a document that is not yet\n    // initialized.\n    return null;\n  }\n\n  return addNwmatcher(parentNode).first(selectors, idlUtils.wrapperForImpl(parentNode));\n};\n\n// nwmatcher gets `document.documentElement` at creation-time, so we have to initialize lazily, since in the initial\n// stages of Document initialization, there is no documentElement present yet.\nfunction addNwmatcher(parentNode) {\n  const document = parentNode._ownerDocument;\n\n  if (!document._nwmatcher) {\n    document._nwmatcher = nwmatcher({ document });\n    document._nwmatcher.configure({ UNIQUE_ID: false });\n  }\n\n  return document._nwmatcher;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/generated/utils.js":"\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nconst wrapperSymbol = Symbol(\"wrapper\");\nconst implSymbol = Symbol(\"impl\");\n\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n};\n\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n};\n\nfunction tryWrapperForImpl(impl) {\n  const wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n};\n\nfunction tryImplForWrapper(wrapper) {\n  const impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n};\n\nconst iterInternalSymbol = Symbol(\"internal\");\nconst IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\nmodule.exports.wrapperSymbol = wrapperSymbol;\nmodule.exports.implSymbol = implSymbol;\nmodule.exports.wrapperForImpl = wrapperForImpl;\nmodule.exports.implForWrapper = implForWrapper;\nmodule.exports.tryWrapperForImpl = tryWrapperForImpl;\nmodule.exports.tryImplForWrapper = tryImplForWrapper;\nmodule.exports.iterInternalSymbol = iterInternalSymbol;\nmodule.exports.IteratorPrototype = IteratorPrototype;\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/browser/documentfeatures.js":"\"use strict\";\n\nexports.availableDocumentFeatures = [\n  \"FetchExternalResources\",\n  \"ProcessExternalResources\",\n  \"SkipExternalResources\"\n];\n\nexports.defaultDocumentFeatures = {\n  FetchExternalResources: [\"script\", \"link\"], // omitted by default: \"frame\"\n  ProcessExternalResources: [\"script\"],\n  SkipExternalResources: false\n};\n\nexports.applyDocumentFeatures = (documentImpl, features) => {\n  features = features || {};\n\n  for (let i = 0; i < exports.availableDocumentFeatures.length; ++i) {\n    const featureName = exports.availableDocumentFeatures[i];\n    let featureSource;\n\n    if (features[featureName] !== undefined) {\n      featureSource = features[featureName];\n      // We have to check the lowercase version also because the Document feature\n      // methods convert everything to lowercase.\n    } else if (typeof features[featureName.toLowerCase()] !== \"undefined\") {\n      featureSource = features[featureName.toLowerCase()];\n    } else if (exports.defaultDocumentFeatures[featureName]) {\n      featureSource = exports.defaultDocumentFeatures[featureName];\n    } else {\n      continue;\n    }\n\n    const implImpl = documentImpl._implementation;\n    implImpl._removeFeature(featureName);\n\n    if (featureSource !== undefined) {\n      if (Array.isArray(featureSource)) {\n        for (let j = 0; j < featureSource.length; ++j) {\n          implImpl._addFeature(featureName, featureSource[j]);\n        }\n      } else {\n        implImpl._addFeature(featureName, featureSource);\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/browser/domtohtml.js":"\"use strict\";\nconst parse5 = require(\"parse5\");\nconst documentAdapter = require(\"./documentAdapter\");\nconst NODE_TYPE = require(\"../living/node-type\");\nconst idlUtils = require(\"../living/generated/utils\");\n\nconst serializer = new parse5.TreeSerializer(documentAdapter);\n\nexports.domToHtml = function (iterable) {\n  let ret = \"\";\n  for (const node of iterable) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      ret += serializer.serialize(node);\n    } else {\n      ret += serializer.serialize({ childNodes: [idlUtils.wrapperForImpl(node)] });\n    }\n  }\n  return ret;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/browser/documentAdapter.js":"\"use strict\";\n\nconst idlUtils = require(\"../living/generated/utils\");\n\n// Tree traversing\nexports.getFirstChild = function (node) {\n  return node.childNodes[0];\n};\n\nexports.getChildNodes = function (node) {\n  // parse5 treats template elements specially, assuming you return an array whose single item is the document fragment\n  const children = node._templateContents ? [node._templateContents] : [];\n  if (children.length === 0) {\n    for (let i = 0; i < node.childNodes.length; ++i) {\n      children.push(idlUtils.implForWrapper(node.childNodes[i]));\n    }\n  }\n  return children;\n};\n\nexports.getParentNode = function (node) {\n  return node.parentNode;\n};\n\nexports.getAttrList = function (node) {\n  return node.attributes;\n};\n\n// Node data\nexports.getTagName = function (element) {\n  return element.tagName.toLowerCase();\n};\n\nexports.getNamespaceURI = function (element) {\n  return element.namespaceURI || \"http://www.w3.org/1999/xhtml\";\n};\n\nexports.getTextNodeContent = function (textNode) {\n  return textNode.nodeValue;\n};\n\nexports.getCommentNodeContent = function (commentNode) {\n  return commentNode.nodeValue;\n};\n\nexports.getDocumentTypeNodeName = function (doctypeNode) {\n  return doctypeNode.name;\n};\n\nexports.getDocumentTypeNodePublicId = function (doctypeNode) {\n  return doctypeNode.publicId || null;\n};\n\nexports.getDocumentTypeNodeSystemId = function (doctypeNode) {\n  return doctypeNode.systemId || null;\n};\n\n// Node types\nexports.isTextNode = function (node) {\n  return node.nodeName === \"#text\";\n};\n\nexports.isCommentNode = function (node) {\n  return node.nodeName === \"#comment\";\n};\n\nexports.isDocumentTypeNode = function (node) {\n  return node.nodeType === 10;\n};\n\nexports.isElementNode = function (node) {\n  return Boolean(node.tagName);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/node-type.js":"\"use strict\";\n\nmodule.exports = Object.freeze({\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2, // historical\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4, // historical\n  ENTITY_REFERENCE_NODE: 5, // historical\n  ENTITY_NODE: 6, // historical\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n  NOTATION_NODE: 12 // historical\n});\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/browser/Window.js":"\"use strict\";\n\nconst webIDLConversions = require(\"webidl-conversions\");\nconst CSSStyleDeclaration = require(\"cssstyle\").CSSStyleDeclaration;\nconst notImplemented = require(\"./not-implemented\");\nconst VirtualConsole = require(\"../virtual-console\");\nconst define = require(\"../utils\").define;\nconst EventTarget = require(\"../living/generated/EventTarget\");\nconst namedPropertiesWindow = require(\"../living/named-properties-window\");\nconst cssom = require(\"cssom\");\nconst postMessage = require(\"../living/post-message\");\nconst DOMException = require(\"../web-idl/DOMException\");\nconst btoa = require(\"abab\").btoa;\nconst atob = require(\"abab\").atob;\nconst idlUtils = require(\"../living/generated/utils\");\nconst createXMLHttpRequest = require(\"../living/xmlhttprequest\");\nconst createFileReader = require(\"../living/generated/FileReader\").createInterface;\nconst Document = require(\"../living/generated/Document\");\nconst Navigator = require(\"../living/generated/Navigator\");\nconst reportException = require(\"../living/helpers/runtime-script-errors\");\n\n// NB: the require() must be after assigning `module.exports` because this require() is circular\n// TODO: this above note might not even be true anymore... figure out the cycle and document it, or clean up.\nmodule.exports = Window;\nconst dom = require(\"../living\");\n\nconst cssSelectorSplitRE = /((?:[^,\"']|\"[^\"]*\"|'[^']*')+)/;\n\nconst defaultStyleSheet = cssom.parse(require(\"./default-stylesheet\"));\n\ndom.Window = Window;\n\n// NOTE: per https://heycam.github.io/webidl/#Global, all properties on the Window object must be own-properties.\n// That is why we assign everything inside of the constructor, instead of using a shared prototype.\n// You can verify this in e.g. Firefox or Internet Explorer, which do a good job with Web IDL compliance.\n\nfunction Window(options) {\n  EventTarget.setup(this);\n\n  const window = this;\n\n  ///// INTERFACES FROM THE DOM\n  // TODO: consider a mode of some sort where these are not shared between all DOM instances\n  // It'd be very memory-expensive in most cases, though.\n  for (const name in dom) {\n    Object.defineProperty(window, name, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: dom[name]\n    });\n  }\n  this._core = dom;\n\n  ///// PRIVATE DATA PROPERTIES\n\n  // vm initialization is defered until script processing is activated (in level1/core)\n  this._globalProxy = this;\n\n  this.__timers = Object.create(null);\n\n  // Set up the window as if it's a top level window.\n  // If it's not, then references will be corrected by frame/iframe code.\n  this._parent = this._top = this._globalProxy;\n  this._frameElement = null;\n\n  // List options explicitly to be clear which are passed through\n  this._document = Document.create([], {\n    core: dom,\n    options: {\n      parsingMode: options.parsingMode,\n      contentType: options.contentType,\n      encoding: options.encoding,\n      cookieJar: options.cookieJar,\n      parser: options.parser,\n      url: options.url,\n      lastModified: options.lastModified,\n      referrer: options.referrer,\n      cookie: options.cookie,\n      deferClose: options.deferClose,\n      resourceLoader: options.resourceLoader,\n      concurrentNodeIterators: options.concurrentNodeIterators,\n      pool: options.pool,\n      agent: options.agent,\n      agentClass: options.agentClass,\n      agentOptions: options.agentOptions,\n      strictSSL: options.strictSSL,\n      proxy: options.proxy,\n      parseOptions: options.parseOptions,\n      defaultView: this._globalProxy,\n      global: this\n    }\n  });\n  // https://html.spec.whatwg.org/#session-history\n  this._sessionHistory = [{\n    document: idlUtils.implForWrapper(this._document),\n    url: idlUtils.implForWrapper(this._document)._URL,\n    stateObject: null\n  }];\n  this._currentSessionHistoryEntryIndex = 0;\n\n\n  // This implements window.frames.length, since window.frames returns a\n  // self reference to the window object.  This value is incremented in the\n  // HTMLFrameElement init function (see: level2/html.js).\n  this._length = 0;\n\n  // TODO NEWAPI can remove this\n  if (options.virtualConsole) {\n    if (options.virtualConsole instanceof VirtualConsole) {\n      this._virtualConsole = options.virtualConsole;\n    } else {\n      throw new TypeError(\n        \"options.virtualConsole must be a VirtualConsole (from createVirtualConsole)\");\n    }\n  } else {\n    this._virtualConsole = new VirtualConsole();\n  }\n\n  ///// GETTERS\n\n  const navigator = Navigator.create([], { userAgent: options.userAgent });\n\n  define(this, {\n    get length() {\n      return window._length;\n    },\n    get window() {\n      return window._globalProxy;\n    },\n    get frameElement() {\n      return window._frameElement;\n    },\n    get frames() {\n      return window._globalProxy;\n    },\n    get self() {\n      return window._globalProxy;\n    },\n    get parent() {\n      return window._parent;\n    },\n    get top() {\n      return window._top;\n    },\n    get document() {\n      return window._document;\n    },\n    get location() {\n      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._location);\n    },\n    get history() {\n      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._history);\n    },\n    get navigator() {\n      return navigator;\n    }\n  });\n\n  namedPropertiesWindow.initializeWindow(this, dom.HTMLCollection);\n\n  ///// METHODS for [ImplicitThis] hack\n  // See https://lists.w3.org/Archives/Public/public-script-coord/2015JanMar/0109.html\n  this.addEventListener = this.addEventListener.bind(this);\n  this.removeEventListener = this.removeEventListener.bind(this);\n  this.dispatchEvent = this.dispatchEvent.bind(this);\n\n  ///// METHODS\n\n  let latestTimerId = 0;\n\n  this.setTimeout = function (fn, ms) {\n    const args = [];\n    for (let i = 2; i < arguments.length; ++i) {\n      args[i - 2] = arguments[i];\n    }\n    return startTimer(window, setTimeout, clearTimeout, ++latestTimerId, fn, ms, args);\n  };\n  this.setInterval = function (fn, ms) {\n    const args = [];\n    for (let i = 2; i < arguments.length; ++i) {\n      args[i - 2] = arguments[i];\n    }\n    return startTimer(window, setInterval, clearInterval, ++latestTimerId, fn, ms, args);\n  };\n  this.clearInterval = stopTimer.bind(this, window);\n  this.clearTimeout = stopTimer.bind(this, window);\n  this.__stopAllTimers = stopAllTimers.bind(this, window);\n\n  function Option(text, value, defaultSelected, selected) {\n    if (text === undefined) {\n      text = \"\";\n    }\n    text = webIDLConversions.DOMString(text);\n\n    if (value !== undefined) {\n      value = webIDLConversions.DOMString(value);\n    }\n\n    defaultSelected = webIDLConversions.boolean(defaultSelected);\n    selected = webIDLConversions.boolean(selected);\n\n    const option = window._document.createElement(\"option\");\n    const impl = idlUtils.implForWrapper(option);\n\n    if (text !== \"\") {\n      impl.text = text;\n    }\n    if (value !== undefined) {\n      impl.setAttribute(\"value\", value);\n    }\n    if (defaultSelected) {\n      impl.setAttribute(\"selected\", \"\");\n    }\n    impl._selectedness = selected;\n\n    return option;\n  }\n  Object.defineProperty(Option, \"prototype\", {\n    value: this.HTMLOptionElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Option\", {\n    value: Option,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function Image() {\n    const img = window._document.createElement(\"img\");\n    const impl = idlUtils.implForWrapper(img);\n\n    if (arguments.length > 0) {\n      impl.setAttribute(\"width\", String(arguments[0]));\n    }\n    if (arguments.length > 1) {\n      impl.setAttribute(\"height\", String(arguments[1]));\n    }\n\n    return img;\n  }\n  Object.defineProperty(Image, \"prototype\", {\n    value: this.HTMLImageElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Image\", {\n    value: Image,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function Audio(src) {\n    const audio = window._document.createElement(\"audio\");\n    const impl = idlUtils.implForWrapper(audio);\n    impl.setAttribute(\"preload\", \"auto\");\n\n    if (src !== undefined) {\n      impl.setAttribute(\"src\", String(src));\n    }\n\n    return audio;\n  }\n  Object.defineProperty(Audio, \"prototype\", {\n    value: this.HTMLAudioElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Audio\", {\n    value: Audio,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function wrapConsoleMethod(method) {\n    return (...args) => {\n      window._virtualConsole.emit(method, ...args);\n    };\n  }\n\n  this.postMessage = postMessage;\n\n  this.atob = function (str) {\n    const result = atob(str);\n    if (result === null) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n        \"The string to be decoded contains invalid characters.\");\n    }\n    return result;\n  };\n\n  this.btoa = function (str) {\n    const result = btoa(str);\n    if (result === null) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n        \"The string to be encoded contains invalid characters.\");\n    }\n    return result;\n  };\n\n  this.FileReader = createFileReader({\n    window: this\n  }).interface;\n\n  this.XMLHttpRequest = createXMLHttpRequest(this);\n\n  // TODO: necessary for Blob and FileReader due to different-globals weirdness; investigate how to avoid this.\n  this.ArrayBuffer = ArrayBuffer;\n  this.Int8Array = Int8Array;\n  this.Uint8Array = Uint8Array;\n  this.Uint8ClampedArray = Uint8ClampedArray;\n  this.Int16Array = Int16Array;\n  this.Uint16Array = Uint16Array;\n  this.Int32Array = Int32Array;\n  this.Uint32Array = Uint32Array;\n  this.Float32Array = Float32Array;\n  this.Float64Array = Float64Array;\n\n  this.stop = function () {\n    const manager = idlUtils.implForWrapper(this._document)._requestManager;\n    if (manager) {\n      manager.close();\n    }\n  };\n\n  this.close = function () {\n    // Recursively close child frame windows, then ourselves.\n    const currentWindow = this;\n    (function windowCleaner(windowToClean) {\n      for (let i = 0; i < windowToClean.length; i++) {\n        windowCleaner(windowToClean[i]);\n      }\n\n      // We\"re already in our own window.close().\n      if (windowToClean !== currentWindow) {\n        windowToClean.close();\n      }\n    }(this));\n\n    // Clear out all listeners. Any in-flight or upcoming events should not get delivered.\n    idlUtils.implForWrapper(this)._eventListeners = Object.create(null);\n\n    if (this._document) {\n      if (this._document.body) {\n        this._document.body.innerHTML = \"\";\n      }\n\n      if (this._document.close) {\n        // It's especially important to clear out the listeners here because document.close() causes a \"load\" event to\n        // fire.\n        idlUtils.implForWrapper(this._document)._eventListeners = Object.create(null);\n        this._document.close();\n      }\n      const doc = idlUtils.implForWrapper(this._document);\n      if (doc._requestManager) {\n        doc._requestManager.close();\n      }\n      delete this._document;\n    }\n\n    stopAllTimers(currentWindow);\n  };\n\n  this.getComputedStyle = function (node) {\n    const s = node.style;\n    const cs = new CSSStyleDeclaration();\n    const forEach = Array.prototype.forEach;\n\n    function setPropertiesFromRule(rule) {\n      if (!rule.selectorText) {\n        return;\n      }\n\n      const selectors = rule.selectorText.split(cssSelectorSplitRE);\n      let matched = false;\n      for (const selectorText of selectors) {\n        if (selectorText !== \"\" && selectorText !== \",\" && !matched && matchesDontThrow(node, selectorText)) {\n          matched = true;\n          forEach.call(rule.style, property => {\n            cs.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));\n          });\n        }\n      }\n    }\n\n    function readStylesFromStyleSheet(sheet) {\n      forEach.call(sheet.cssRules, rule => {\n        if (rule.media) {\n          if (Array.prototype.indexOf.call(rule.media, \"screen\") !== -1) {\n            forEach.call(rule.cssRules, setPropertiesFromRule);\n          }\n        } else {\n          setPropertiesFromRule(rule);\n        }\n      });\n    }\n\n    readStylesFromStyleSheet(defaultStyleSheet);\n    forEach.call(node.ownerDocument.styleSheets, readStylesFromStyleSheet);\n\n    forEach.call(s, property => {\n      cs.setProperty(property, s.getPropertyValue(property), s.getPropertyPriority(property));\n    });\n\n    return cs;\n  };\n\n  ///// PUBLIC DATA PROPERTIES (TODO: should be getters)\n\n  this.console = {\n    assert: wrapConsoleMethod(\"assert\"),\n    clear: wrapConsoleMethod(\"clear\"),\n    count: wrapConsoleMethod(\"count\"),\n    debug: wrapConsoleMethod(\"debug\"),\n    error: wrapConsoleMethod(\"error\"),\n    group: wrapConsoleMethod(\"group\"),\n    groupCollapsed: wrapConsoleMethod(\"groupCollapsed\"),\n    groupEnd: wrapConsoleMethod(\"groupEnd\"),\n    info: wrapConsoleMethod(\"info\"),\n    log: wrapConsoleMethod(\"log\"),\n    table: wrapConsoleMethod(\"table\"),\n    time: wrapConsoleMethod(\"time\"),\n    timeEnd: wrapConsoleMethod(\"timeEnd\"),\n    trace: wrapConsoleMethod(\"trace\"),\n    warn: wrapConsoleMethod(\"warn\")\n  };\n\n  function notImplementedMethod(name) {\n    return function () {\n      notImplemented(name, window);\n    };\n  }\n\n  define(this, {\n    name: \"nodejs\",\n    innerWidth: 1024,\n    innerHeight: 768,\n    outerWidth: 1024,\n    outerHeight: 768,\n    pageXOffset: 0,\n    pageYOffset: 0,\n    screenX: 0,\n    screenY: 0,\n    screenLeft: 0,\n    screenTop: 0,\n    scrollX: 0,\n    scrollY: 0,\n    scrollTop: 0,\n    scrollLeft: 0,\n    screen: {\n      width: 0,\n      height: 0\n    },\n\n    alert: notImplementedMethod(\"window.alert\"),\n    blur: notImplementedMethod(\"window.blur\"),\n    confirm: notImplementedMethod(\"window.confirm\"),\n    createPopup: notImplementedMethod(\"window.createPopup\"),\n    focus: notImplementedMethod(\"window.focus\"),\n    moveBy: notImplementedMethod(\"window.moveBy\"),\n    moveTo: notImplementedMethod(\"window.moveTo\"),\n    open: notImplementedMethod(\"window.open\"),\n    print: notImplementedMethod(\"window.print\"),\n    prompt: notImplementedMethod(\"window.prompt\"),\n    resizeBy: notImplementedMethod(\"window.resizeBy\"),\n    resizeTo: notImplementedMethod(\"window.resizeTo\"),\n    scroll: notImplementedMethod(\"window.scroll\"),\n    scrollBy: notImplementedMethod(\"window.scrollBy\"),\n    scrollTo: notImplementedMethod(\"window.scrollTo\"),\n\n    toString: () => {\n      return \"[object Window]\";\n    }\n  });\n\n  ///// INITIALIZATION\n\n  process.nextTick(() => {\n    if (!window.document) {\n      return; // window might've been closed already\n    }\n\n    if (window.document.readyState === \"complete\") {\n      const ev = window.document.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"load\", false, false);\n      window.dispatchEvent(ev);\n    } else {\n      window.document.addEventListener(\"load\", () => {\n        const ev = window.document.createEvent(\"HTMLEvents\");\n        ev.initEvent(\"load\", false, false);\n        window.dispatchEvent(ev);\n      });\n    }\n  });\n}\n\nObject.setPrototypeOf(Window, EventTarget.interface);\nObject.setPrototypeOf(Window.prototype, EventTarget.interface.prototype);\n\nfunction matchesDontThrow(el, selector) {\n  try {\n    return el.matches(selector);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction startTimer(window, startFn, stopFn, timerId, callback, ms, args) {\n  if (typeof callback !== \"function\") {\n    const code = String(callback);\n    callback = window._globalProxy.eval.bind(window, code + `\\n//# sourceURL=${window.location.href}`);\n  }\n\n  const oldCallback = callback;\n  callback = () => {\n    try {\n      oldCallback.apply(window._globalProxy, args);\n    } catch (e) {\n      reportException(window, e, window.location.href);\n    }\n  };\n\n  const res = startFn(callback, ms);\n  window.__timers[timerId] = [res, stopFn];\n  return timerId;\n}\n\nfunction stopTimer(window, id) {\n  const timer = window.__timers[id];\n  if (timer) {\n    // Need to .call() with undefined to ensure the thisArg is not timer itself\n    timer[1].call(undefined, timer[0]);\n    delete window.__timers[id];\n  }\n}\n\nfunction stopAllTimers(window) {\n  Object.keys(window.__timers).forEach(key => {\n    const timer = window.__timers[key];\n    // Need to .call() with undefined to ensure the thisArg is not timer itself\n    timer[1].call(undefined, timer[0]);\n  });\n  window.__timers = Object.create(null);\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/browser/not-implemented.js":"\"use strict\";\n\nmodule.exports = function (nameForErrorMessage, window) {\n  if (!window) {\n    // Do nothing for window-less documents.\n    return;\n  }\n\n  const error = new Error(`Not implemented: ${nameForErrorMessage}`);\n  error.type = \"not implemented\";\n\n  window._virtualConsole.emit(\"jsdomError\", error);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/virtual-console.js":"\"use strict\";\nconst EventEmitter = require(\"events\").EventEmitter;\n\nmodule.exports = class VirtualConsole extends EventEmitter {\n  constructor() {\n    super();\n\n    this.on(\"error\", () => {\n      // If \"error\" event has no listeners,\n      // EventEmitter throws an exception\n    });\n  }\n\n  sendTo(anyConsole, options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    for (const method of Object.keys(anyConsole)) {\n      if (typeof anyConsole[method] === \"function\") {\n        function onMethodCall() {\n          anyConsole[method](...arguments);\n        }\n        this.on(method, onMethodCall);\n      }\n    }\n\n    if (!options.omitJSDOMErrors) {\n      this.on(\"jsdomError\", e => anyConsole.error(e.stack, e.detail));\n    }\n\n    return this;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction EventTarget() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nEventTarget.prototype.addEventListener = function addEventListener(type, callback) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  if (args[1] === null || args[1] === undefined) {\n    args[1] = null;\n  } else {\n  }\n  return this[impl].addEventListener.apply(this[impl], args);\n};\n\nEventTarget.prototype.removeEventListener = function removeEventListener(type, callback) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'removeEventListener' on 'EventTarget': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  if (args[1] === null || args[1] === undefined) {\n    args[1] = null;\n  } else {\n  }\n  return this[impl].removeEventListener.apply(this[impl], args);\n};\n\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'dispatchEvent' on 'EventTarget': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].dispatchEvent.apply(this[impl], args);\n};\n\nEventTarget.prototype.toString = function () {\n  if (this === EventTarget.prototype) {\n    return \"[object EventTargetPrototype]\";\n  }\n  return this[impl].toString();\n};\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(EventTarget.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(EventTarget.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: EventTarget,\n  expose: {\n    Window: { EventTarget: EventTarget },\n    Worker: { EventTarget: EventTarget }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/EventTarget-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js":"\"use strict\";\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst idlUtils = require(\"../generated/utils\");\n\nconst EventImpl = require(\"./Event-impl\").implementation;\nconst Event = require(\"../generated/Event\").interface;\n\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (!(eventImpl instanceof EventImpl)) {\n      throw new TypeError(\"Argument to dispatchEvent must be an Event\");\n    }\n\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR, \"Tried to dispatch an uninitialized event\");\n    }\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(DOMException.INVALID_STATE_ERR, \"Tried to dispatch a dispatching event\");\n    }\n\n    eventImpl.isTrusted = false;\n\n    return this._dispatch(eventImpl);\n  }\n\n  _dispatch(eventImpl, targetOverride) {\n    eventImpl._dispatchFlag = true;\n    eventImpl.target = targetOverride || this;\n\n    const eventPath = [];\n    let targetParent = domSymbolTree.parent(eventImpl.target);\n    let target = eventImpl.target;\n    while (targetParent) {\n      eventPath.push(targetParent);\n      target = targetParent;\n      targetParent = domSymbolTree.parent(targetParent);\n    }\n    if (eventImpl.type !== \"load\" && target._defaultView) {\n      // https://html.spec.whatwg.org/#events-and-the-window-object\n      eventPath.push(idlUtils.implForWrapper(target._defaultView));\n    }\n\n    eventImpl.eventPhase = Event.CAPTURING_PHASE;\n    for (let i = eventPath.length - 1; i >= 0; --i) {\n      if (eventImpl._stopPropagationFlag) {\n        break;\n      }\n\n      const object = eventPath[i];\n      const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n      const eventListeners = objectImpl._eventListeners[eventImpl.type];\n      invokeEventListeners(eventListeners, object, eventImpl);\n    }\n\n    eventImpl.eventPhase = Event.AT_TARGET;\n\n    if (!eventImpl._stopPropagationFlag) {\n      invokeInlineListeners(eventImpl.target, eventImpl);\n\n      if (this._eventListeners[eventImpl.type]) {\n        const eventListeners = this._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, eventImpl.target, eventImpl);\n      }\n    }\n\n    if (eventImpl.bubbles) {\n      eventImpl.eventPhase = Event.BUBBLING_PHASE;\n      for (let i = 0; i < eventPath.length; ++i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n\n        const object = eventPath[i];\n        const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n        const eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeInlineListeners(object, eventImpl);\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n    }\n\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n    eventImpl.eventPhase = Event.NONE;\n    eventImpl.currentTarget = null;\n    return !eventImpl._canceledFlag;\n  }\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\nfunction invokeInlineListeners(object, event) {\n  const wrapper = idlUtils.wrapperForImpl(object);\n  const inlineListener = getListenerForInlineEventHandler(wrapper, event.type);\n  if (inlineListener) {\n    const document = object._ownerDocument || (wrapper && (wrapper._document || wrapper._ownerDocument));\n\n    // Will be falsy for windows that have closed\n    if (document && (!object.nodeName || document.implementation._hasFeature(\"ProcessExternalResources\", \"script\"))) {\n      invokeEventListeners([{\n        callback: inlineListener,\n        options: normalizeEventHandlerOptions(false, [\"capture\", \"once\"])\n      }], object, event);\n    }\n  }\n}\n\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  const wrapper = idlUtils.wrapperForImpl(target);\n  const document = target._ownerDocument || (wrapper && (wrapper._document || wrapper._ownerDocument));\n  // Will be falsy for windows that have closed\n  if (!document) {\n    return;\n  }\n\n  // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n  if (wrapper._document) {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n  eventImpl.currentTarget = target;\n  if (!listeners) {\n    return;\n  }\n\n  const handlers = listeners.slice();\n  for (let i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n\n    const listener = handlers[i];\n    const capture = listener.options.capture;\n    const once = listener.options.once;\n    // const passive = listener.options.passive;\n\n    if (listeners.indexOf(listener) === -1 ||\n        (eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture) ||\n        (eventImpl.eventPhase === Event.BUBBLING_PHASE && capture)) {\n      continue;\n    }\n\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n  }\n}\n\nconst wrappedListener = Symbol(\"inline event listener wrapper\");\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}\n\nfunction getListenerForInlineEventHandler(target, type) {\n  const callback = target[\"on\" + type];\n\n  if (!callback) { // TODO event handlers: only check null\n    return null;\n  }\n\n  if (!callback[wrappedListener]) {\n    // https://html.spec.whatwg.org/multipage/webappapis.html#the-event-handler-processing-algorithm\n    callback[wrappedListener] = function (E) {\n      const isWindowError = E.constructor.name === \"ErrorEvent\" && type === \"error\"; // TODO branding\n\n      let returnValue;\n      if (isWindowError) {\n        returnValue = callback.call(E.currentTarget, E.message, E.filename, E.lineno, E.colno, E.error);\n      } else {\n        returnValue = callback.call(E.currentTarget, E);\n      }\n\n      if (type === \"mouseover\" || isWindowError) {\n        if (returnValue === true) {\n          E.preventDefault();\n        }\n      } else if (returnValue === false) {\n        E.preventDefault();\n      }\n    };\n  }\n\n  return callback[wrappedListener];\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/web-idl/DOMException.js":"\"use strict\";\nconst addConstants = require(\"../utils\").addConstants;\nconst table = require(\"./dom-exception-table.json\"); // https://heycam.github.io/webidl/#idl-DOMException-error-names\n\n// Precompute some stuff. Mostly unnecessary once we take care of the TODO below.\nconst namesWithCodes = Object.keys(table).filter(name => \"legacyCodeValue\" in table[name]);\n\nconst codesToNames = Object.create(null);\nfor (const name of namesWithCodes) {\n  codesToNames[table[name].legacyCodeValue] = name;\n}\n\nmodule.exports = DOMException;\n\n// TODO: update constructor signature to match WebIDL spec\n// See also https://github.com/heycam/webidl/pull/22 which isn't merged as of yet\nfunction DOMException(code, message) {\n  const name = codesToNames[code];\n\n  if (message === undefined) {\n    message = table[name].description;\n  }\n  Error.call(this, message);\n\n  Object.defineProperty(this, \"name\", { value: name, writable: true, configurable: true, enumerable: false });\n  Object.defineProperty(this, \"code\", { value: code, writable: true, configurable: true, enumerable: false });\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, DOMException);\n  }\n}\n\nObject.setPrototypeOf(DOMException, Error);\nObject.setPrototypeOf(DOMException.prototype, Error.prototype);\n\nconst constants = Object.create(null);\nfor (const name of namesWithCodes) {\n  constants[table[name].legacyCodeName] = table[name].legacyCodeValue;\n}\n\naddConstants(DOMException, constants);\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/helpers/runtime-script-errors.js":"\"use strict\";\nconst util = require(\"util\");\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\n\nconst errorReportingMode = Symbol(\"error reporting mode\");\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#report-the-error\n// Omits script parameter and any check for muted errors; takes error object, message, and location as params, unlike\n// the spec. Returns whether the event was handled or not.\nfunction reportAnError(line, col, target, errorObject, message, location) {\n  if (target[errorReportingMode]) {\n    return false;\n  }\n\n  target[errorReportingMode] = true;\n\n  // TODO Events: use constructor directly, once they are no longer tied to a window.\n  const event = ErrorEvent.createImpl([\"error\", {\n    bubbles: false,\n    cancelable: true,\n    message,\n    filename: location,\n    lineno: line,\n    colno: col,\n    error: errorObject\n  }]);\n\n  try {\n    target.dispatchEvent(event);\n  } finally {\n    target[errorReportingMode] = false;\n    return event.defaultPrevented;\n  }\n}\n\nmodule.exports = function reportException(window, error, filenameHint) {\n  // This function will give good results on real Error objects with stacks; poor ones otherwise\n\n  const stack = error && error.stack;\n  const lines = stack && stack.split(\"\\n\");\n\n  // Find the first line that matches; important for multi-line messages\n  let pieces;\n  if (lines) {\n    for (let i = 1; i < lines.length && !pieces; ++i) {\n      pieces = lines[i].match(/at (?:(.+)\\s+)?\\(?(?:(.+?):(\\d+):(\\d+)|([^)]+))\\)?/);\n    }\n  }\n\n  const fileName = pieces && pieces[2] || filenameHint || window._document.URL;\n  const lineNumber = pieces && parseInt(pieces[3]) || 0;\n  const columnNumber = pieces && parseInt(pieces[4]) || 0;\n\n  const handled = reportAnError(lineNumber, columnNumber, window, error, error.message, fileName);\n\n  if (!handled) {\n    const errorString = shouldBeDisplayedAsError(error) ? `[${error.name}: ${error.message}]` : util.inspect(error);\n    const jsdomError = new Error(`Uncaught ${errorString}`);\n    jsdomError.detail = error;\n    jsdomError.type = \"unhandled exception\";\n\n    window._virtualConsole.emit(\"jsdomError\", jsdomError);\n  }\n};\n\nfunction shouldBeDisplayedAsError(x) {\n  return x.name && x.message !== undefined && x.stack;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/generated/ErrorEvent.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Event = require(\"./Event.js\");\nconst impl = utils.implSymbol;\nconst convertErrorEventInit = require(\"./ErrorEventInit\").convert;\n\nfunction ErrorEvent(type) {\n  if (!this || this[impl] || !(this instanceof ErrorEvent)) {\n    throw new TypeError(\"Failed to construct 'ErrorEvent': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'ErrorEvent': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertErrorEventInit(args[1]);\n\n  iface.setup(this, args);\n}\nErrorEvent.prototype = Object.create(Event.interface.prototype);\nErrorEvent.prototype.constructor = ErrorEvent;\n\n\nErrorEvent.prototype.toString = function () {\n  if (this === ErrorEvent.prototype) {\n    return \"[object ErrorEventPrototype]\";\n  }\n  return Event.interface.prototype.toString.call(this);\n};\nObject.defineProperty(ErrorEvent.prototype, \"message\", {\n  get() {\n    return this[impl].message;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ErrorEvent.prototype, \"filename\", {\n  get() {\n    return this[impl].filename;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ErrorEvent.prototype, \"lineno\", {\n  get() {\n    return this[impl].lineno;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ErrorEvent.prototype, \"colno\", {\n  get() {\n    return this[impl].colno;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(ErrorEvent.prototype, \"error\", {\n  get() {\n    return this[impl].error;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(ErrorEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(ErrorEvent.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Event._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: ErrorEvent,\n  expose: {\n    Window: { ErrorEvent: ErrorEvent },\n    Worker: { ErrorEvent: ErrorEvent }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/ErrorEvent-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/generated/Event.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\nconst convertEventInit = require(\"./EventInit\").convert;\n\nfunction Event(type) {\n  if (!this || this[impl] || !(this instanceof Event)) {\n    throw new TypeError(\"Failed to construct 'Event': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'Event': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = convertEventInit(args[1]);\n\n  iface.setup(this, args);\n}\n\n\nEvent.prototype.stopPropagation = function stopPropagation() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].stopPropagation.apply(this[impl], args);\n};\n\nEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].stopImmediatePropagation.apply(this[impl], args);\n};\n\nEvent.prototype.preventDefault = function preventDefault() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].preventDefault.apply(this[impl], args);\n};\n\nEvent.prototype.initEvent = function initEvent(type, bubbles, cancelable) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 3) {\n    throw new TypeError(\"Failed to execute 'initEvent' on 'Event': 3 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 3; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  args[0] = conversions[\"DOMString\"](args[0]);\n  args[1] = conversions[\"boolean\"](args[1]);\n  args[2] = conversions[\"boolean\"](args[2]);\n  return this[impl].initEvent.apply(this[impl], args);\n};\n\nEvent.prototype.toString = function () {\n  if (this === Event.prototype) {\n    return \"[object EventPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(Event.prototype, \"type\", {\n  get() {\n    return this[impl].type;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"target\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].target);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"currentTarget\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].currentTarget);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event, \"NONE\", {\n  value: 0,\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"NONE\", {\n  value: 0,\n  enumerable: true\n});\n\nObject.defineProperty(Event, \"CAPTURING_PHASE\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"CAPTURING_PHASE\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(Event, \"AT_TARGET\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"AT_TARGET\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(Event, \"BUBBLING_PHASE\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"BUBBLING_PHASE\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(Event.prototype, \"eventPhase\", {\n  get() {\n    return this[impl].eventPhase;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"cancelBubble\", {\n  get() {\n    return this[impl].cancelBubble;\n  },\n  set(V) {\n    V = conversions[\"boolean\"](V);\n    this[impl].cancelBubble = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"bubbles\", {\n  get() {\n    return this[impl].bubbles;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"cancelable\", {\n  get() {\n    return this[impl].cancelable;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"defaultPrevented\", {\n  get() {\n    return this[impl].defaultPrevented;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Event.prototype, \"timeStamp\", {\n  get() {\n    return this[impl].timeStamp;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Event.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Event.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Object.defineProperty(obj, \"isTrusted\", {\n      get() {\n        return obj[impl].isTrusted;\n      },\n      enumerable: true,\n      configurable: false\n    });\n    \n    \n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Event,\n  expose: {\n    Window: { Event: Event },\n    Worker: { Event: Event }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../events/Event-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/generated/EventInit.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\n\nmodule.exports = {\n  convertInherit(obj, ret) {\n    let key, value;\n\n    key = \"bubbles\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n\n    key = \"cancelable\";\n    value = obj === undefined || obj === null ? undefined : obj[key];\n    if (value !== undefined) {\n      ret[key] = conversions[\"boolean\"](value);\n    } else {\n      ret[key] = false;\n    }\n  },\n\n  convert(obj) {\n    if (obj !== undefined && typeof obj !== \"object\") {\n      throw new TypeError(\"Dictionary has to be an object\");\n    }\n    if (obj instanceof Date || obj instanceof RegExp) {\n      throw new TypeError(\"Dictionary may not be a Date or RegExp object\");\n    }\n\n    const ret = Object.create(null);\n    module.exports.convertInherit(obj, ret);\n    return ret;\n  }\n};","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/events/Event-impl.js":"\"use strict\";\n\nconst EventInit = require(\"../generated/EventInit\");\n\nclass EventImpl {\n  constructor(args, privateData) {\n    const [type, eventInitDict = EventInit.convert(undefined)] = args;\n\n    this.type = type;\n\n    const wrapper = privateData.wrapper;\n    for (const key in eventInitDict) {\n      if (key in wrapper) {\n        this[key] = eventInitDict[key];\n      }\n    }\n\n    this.target = null;\n    this.currentTarget = null;\n    this.eventPhase = 0;\n\n    this._initializedFlag = true;\n    this._stopPropagationFlag = false;\n    this._stopImmediatePropagationFlag = false;\n    this._canceledFlag = false;\n    this._dispatchFlag = false;\n\n    this.isTrusted = privateData.isTrusted || false;\n    this.timeStamp = Date.now();\n  }\n\n  get defaultPrevented() {\n    return this._canceledFlag;\n  }\n\n  stopPropagation() {\n    this._stopPropagationFlag = true;\n  }\n\n  get cancelBubble() {\n    return this._stopPropagationFlag;\n  }\n\n  set cancelBubble(v) {\n    if (v) {\n      this._stopPropagationFlag = true;\n    }\n  }\n\n  stopImmediatePropagation() {\n    this._stopPropagationFlag = true;\n    this._stopImmediatePropagationFlag = true;\n  }\n\n  preventDefault() {\n    if (this.cancelable) {\n      this._canceledFlag = true;\n    }\n  }\n\n  _initialize(type, bubbles, cancelable) {\n    this.type = type;\n    this._initializedFlag = true;\n\n    this._stopPropagationFlag = false;\n    this._stopImmediatePropagationFlag = false;\n    this._canceledFlag = false;\n\n    this.isTrusted = false;\n    this.target = null;\n    this.bubbles = bubbles;\n    this.cancelable = cancelable;\n  }\n\n  initEvent(type, bubbles, cancelable) {\n    if (this._dispatchFlag) {\n      return;\n    }\n\n    this._initialize(type, bubbles, cancelable);\n  }\n}\n\nmodule.exports = {\n  implementation: EventImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/named-properties-tracker.js":"\"use strict\";\n// https://heycam.github.io/webidl/#idl-named-properties\n\nconst IS_NAMED_PROPERTY = Symbol();\nconst TRACKER = Symbol();\n\n/**\n * Create a new NamedPropertiesTracker for the given `object`.\n *\n * Named properties are used in DOM to let you lookup (for example) a Node by accessing a property on another object.\n * For example `window.foo` might resolve to an image element with id \"foo\".\n *\n * This tracker is a workaround because the ES6 Proxy feature is not yet available.\n *\n * @param {Object} object\n * @param {Function} resolverFunc Each time a property is accessed, this function is called to determine the value of\n *        the property. The function is passed 3 arguments: (object, name, values).\n *        `object` is identical to the `object` parameter of this `create` function.\n *        `name` is the name of the property.\n *        `values` is a function that returns a Set with all the tracked values for this name. The order of these\n *        values is undefined.\n *\n * @returns {NamedPropertiesTracker}\n */\nexports.create = function (object, resolverFunc) {\n  if (object[TRACKER]) {\n    throw Error(\"A NamedPropertiesTracker has already been created for this object\");\n  }\n\n  const tracker = new NamedPropertiesTracker(object, resolverFunc);\n  object[TRACKER] = tracker;\n  return tracker;\n};\n\nexports.get = function (object) {\n  if (!object) {\n    return null;\n  }\n\n  return object[TRACKER] || null;\n};\n\nfunction NamedPropertiesTracker(object, resolverFunc) {\n  this.object = object;\n  this.resolverFunc = resolverFunc;\n  this.trackedValues = new Map(); // Map<Set<value>>\n}\n\nfunction newPropertyDescriptor(tracker, name) {\n  const emptySet = new Set();\n\n  function getValues() {\n    return tracker.trackedValues.get(name) || emptySet;\n  }\n\n  const descriptor = {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return tracker.resolverFunc(tracker.object, name, getValues);\n    },\n    set(value) {\n      Object.defineProperty(tracker.object, name, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n      });\n    }\n  };\n\n  descriptor.get[IS_NAMED_PROPERTY] = true;\n  descriptor.set[IS_NAMED_PROPERTY] = true;\n  return descriptor;\n}\n\n/**\n * Track a value (e.g. a Node) for a specified name.\n *\n * Values can be tracked eagerly, which means that not all tracked values *have* to appear in the output. The resolver\n * function that was passed to the output may filter the value.\n *\n * Tracking the same `name` and `value` pair multiple times has no effect\n *\n * @param {String} name\n * @param {*} value\n */\nNamedPropertiesTracker.prototype.track = function (name, value) {\n  if (name === undefined || name === null || name === \"\") {\n    return;\n  }\n\n  let valueSet = this.trackedValues.get(name);\n  if (!valueSet) {\n    valueSet = new Set();\n    this.trackedValues.set(name, valueSet);\n  }\n\n  valueSet.add(value);\n\n  if (name in this.object) {\n    // already added our getter or it is not a named property (e.g. \"addEventListener\")\n    return;\n  }\n\n  const descriptor = newPropertyDescriptor(this, name);\n  Object.defineProperty(this.object, name, descriptor);\n};\n\n/**\n * Stop tracking a previously tracked `name` & `value` pair, see track().\n *\n * Untracking the same `name` and `value` pair multiple times has no effect\n *\n * @param {String} name\n * @param {*} value\n */\nNamedPropertiesTracker.prototype.untrack = function (name, value) {\n  if (name === undefined || name === null || name === \"\") {\n    return;\n  }\n\n  const valueSet = this.trackedValues.get(name);\n  if (!valueSet) {\n    // the value is not present\n    return;\n  }\n\n  if (!valueSet.delete(value)) {\n    // the value was not present\n    return;\n  }\n\n  if (valueSet.size === 0) {\n    this.trackedValues.delete(name);\n  }\n\n  if (valueSet.size > 0) {\n    // other values for this name are still present\n    return;\n  }\n\n  // at this point there are no more values, delete the property\n\n  const descriptor = Object.getOwnPropertyDescriptor(this.object, name);\n\n  if (!descriptor || !descriptor.get || descriptor.get[IS_NAMED_PROPERTY] !== true) {\n    // Not defined by NamedPropertyTracker\n    return;\n  }\n\n  // note: delete puts the object in dictionary mode.\n  // if this turns out to be a performance issue, maybe add:\n  // https://github.com/petkaantonov/bluebird/blob/3e36fc861ac5795193ba37935333eb6ef3716390/src/util.js#L177\n  delete this.object[name];\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/vm-shim.js":"\"use strict\";\n/* eslint-disable no-new-func */\nconst acorn = require(\"acorn\");\nconst findGlobals = require(\"acorn-globals\");\nconst escodegen = require(\"escodegen\");\n\n// We can't use the default browserify vm shim because it doesn't work in a web worker.\n\n// From ES spec table of contents. Also, don't forget the Annex B additions.\n// If someone feels ambitious maybe make this into an npm package.\nconst builtInConsts = [\"Infinity\", \"NaN\", \"undefined\"];\nconst otherBuiltIns = [\"isFinite\", \"isNaN\", \"parseFloat\", \"parseInt\", \"decodeURI\", \"decodeURIComponent\",\n  \"encodeURI\", \"encodeURIComponent\", \"Array\", \"ArrayBuffer\", \"Boolean\", \"DataView\", \"Date\", \"Error\", \"EvalError\",\n  \"Float32Array\", \"Float64Array\", \"Function\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Map\", \"Number\", \"Object\",\n  \"Proxy\", \"Promise\", \"RangeError\", \"ReferenceError\", \"RegExp\", \"Set\", \"String\", \"Symbol\", \"SyntaxError\", \"TypeError\",\n  \"Uint8Array\", \"Uint8ClampedArray\", \"Uint16Array\", \"Uint32Array\", \"URIError\", \"WeakMap\", \"WeakSet\", \"JSON\", \"Math\",\n  \"Reflect\", \"escape\", \"unescape\"];\n\nexports.createContext = function (sandbox) {\n  Object.defineProperty(sandbox, \"__isVMShimContext\", {\n    value: true,\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n\n  for (const builtIn of builtInConsts) {\n    Object.defineProperty(sandbox, builtIn, {\n      value: global[builtIn],\n      writable: false,\n      configurable: false,\n      enumerable: false\n    });\n  }\n\n  for (const builtIn of otherBuiltIns) {\n    Object.defineProperty(sandbox, builtIn, {\n      value: global[builtIn],\n      writable: true,\n      configurable: true,\n      enumerable: false\n    });\n  }\n\n  Object.defineProperty(sandbox, \"eval\", {\n    value(code) {\n      return exports.runInContext(code, sandbox);\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n};\n\nexports.isContext = function (sandbox) {\n  return sandbox.__isVMShimContext;\n};\n\nexports.runInContext = function (code, contextifiedSandbox, options) {\n  if (code === \"this\") {\n    // Special case for during window creation.\n    return contextifiedSandbox;\n  }\n\n  if (options === undefined) {\n    options = {};\n  }\n\n  const comments = [];\n  const tokens = [];\n  const ast = acorn.parse(code, {\n    allowReturnOutsideFunction: true,\n    ranges: true,\n    // collect comments in Esprima's format\n    onComment: comments,\n    // collect token ranges\n    onToken: tokens\n  });\n\n  // make sure we keep comments\n  escodegen.attachComments(ast, comments, tokens);\n\n  const globals = findGlobals(ast);\n  for (let i = 0; i < globals.length; ++i) {\n    if (globals[i].name === \"window\" || globals[i].name === \"this\") {\n      continue;\n    }\n\n    const nodes = globals[i].nodes;\n    for (let j = 0; j < nodes.length; ++j) {\n      const type = nodes[j].type;\n      const name = nodes[j].name;\n      nodes[j].type = \"MemberExpression\";\n      nodes[j].property = { name, type };\n      nodes[j].computed = false;\n      nodes[j].object = {\n        name: \"window\",\n        type: \"Identifier\"\n      };\n    }\n  }\n\n  const lastNode = ast.body[ast.body.length - 1];\n  if (lastNode.type === \"ExpressionStatement\") {\n    lastNode.type = \"ReturnStatement\";\n    lastNode.argument = lastNode.expression;\n    delete lastNode.expression;\n  }\n\n  const rewrittenCode = escodegen.generate(ast, { comment: true });\n  const suffix = options.filename !== undefined ? \"\\n//# sourceURL=\" + options.filename : \"\";\n\n  return Function(\"window\", rewrittenCode + suffix).bind(contextifiedSandbox)(contextifiedSandbox);\n};\n\nexports.Script = class VMShimScript {\n  constructor(code, options) {\n    this._code = code;\n    this._options = options;\n  }\n\n  runInContext(sandbox, options) {\n    return exports.runInContext(this._code, sandbox, Object.assign({}, this._options, options));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/browser/default-stylesheet.js":"// Ideally, we would use\n// https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints\n// but for now, just use the version from blink. This file is copied from\n// https://chromium.googlesource.com/chromium/blink/+/96aa3a280ab7d67178c8f122a04949ce5f8579e0/Source/core/css/html.css\n// (removed a line which had octal literals inside since octal literals are not allowed in template strings)\n\n// We use a .js file because otherwise we can't browserify this. (brfs is unusable due to lack of ES2015 support)\n\nmodule.exports = `\n/*\n * The default style sheet used to render HTML.\n *\n * Copyright (C) 2000 Lars Knoll (knoll@kde.org)\n * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public License\n * along with this library; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA.\n *\n */\n\n@namespace \"http://www.w3.org/1999/xhtml\";\n\nhtml {\n    display: block\n}\n\n:root {\n    scroll-blocks-on: start-touch wheel-event\n}\n\n/* children of the <head> element all have display:none */\nhead {\n    display: none\n}\n\nmeta {\n    display: none\n}\n\ntitle {\n    display: none\n}\n\nlink {\n    display: none\n}\n\nstyle {\n    display: none\n}\n\nscript {\n    display: none\n}\n\n/* generic block-level elements */\n\nbody {\n    display: block;\n    margin: 8px\n}\n\nbody:-webkit-full-page-media {\n    background-color: rgb(0, 0, 0)\n}\n\np {\n    display: block;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1__qem;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n}\n\ndiv {\n    display: block\n}\n\nlayer {\n    display: block\n}\n\narticle, aside, footer, header, hgroup, main, nav, section {\n    display: block\n}\n\nmarquee {\n    display: inline-block;\n}\n\naddress {\n    display: block\n}\n\nblockquote {\n    display: block;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 40px;\n    -webkit-margin-end: 40px;\n}\n\nfigcaption {\n    display: block\n}\n\nfigure {\n    display: block;\n    -webkit-margin-before: 1em;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 40px;\n    -webkit-margin-end: 40px;\n}\n\nq {\n    display: inline\n}\n\nq:before {\n    content: open-quote;\n}\n\nq:after {\n    content: close-quote;\n}\n\ncenter {\n    display: block;\n    /* special centering to be able to emulate the html4/netscape behaviour */\n    text-align: -webkit-center\n}\n\nhr {\n    display: block;\n    -webkit-margin-before: 0.5em;\n    -webkit-margin-after: 0.5em;\n    -webkit-margin-start: auto;\n    -webkit-margin-end: auto;\n    border-style: inset;\n    border-width: 1px;\n    box-sizing: border-box\n}\n\nmap {\n    display: inline\n}\n\nvideo {\n    object-fit: contain;\n}\n\n/* heading elements */\n\nh1 {\n    display: block;\n    font-size: 2em;\n    -webkit-margin-before: 0.67__qem;\n    -webkit-margin-after: 0.67em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\n:-webkit-any(article,aside,nav,section) h1 {\n    font-size: 1.5em;\n    -webkit-margin-before: 0.83__qem;\n    -webkit-margin-after: 0.83em;\n}\n\n:-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) h1 {\n    font-size: 1.17em;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n}\n\n:-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) h1 {\n    font-size: 1.00em;\n    -webkit-margin-before: 1.33__qem;\n    -webkit-margin-after: 1.33em;\n}\n\n:-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) h1 {\n    font-size: .83em;\n    -webkit-margin-before: 1.67__qem;\n    -webkit-margin-after: 1.67em;\n}\n\n:-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) :-webkit-any(article,aside,nav,section) h1 {\n    font-size: .67em;\n    -webkit-margin-before: 2.33__qem;\n    -webkit-margin-after: 2.33em;\n}\n\nh2 {\n    display: block;\n    font-size: 1.5em;\n    -webkit-margin-before: 0.83__qem;\n    -webkit-margin-after: 0.83em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\nh3 {\n    display: block;\n    font-size: 1.17em;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\nh4 {\n    display: block;\n    -webkit-margin-before: 1.33__qem;\n    -webkit-margin-after: 1.33em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\nh5 {\n    display: block;\n    font-size: .83em;\n    -webkit-margin-before: 1.67__qem;\n    -webkit-margin-after: 1.67em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\nh6 {\n    display: block;\n    font-size: .67em;\n    -webkit-margin-before: 2.33__qem;\n    -webkit-margin-after: 2.33em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    font-weight: bold\n}\n\n/* tables */\n\ntable {\n    display: table;\n    border-collapse: separate;\n    border-spacing: 2px;\n    border-color: gray\n}\n\nthead {\n    display: table-header-group;\n    vertical-align: middle;\n    border-color: inherit\n}\n\ntbody {\n    display: table-row-group;\n    vertical-align: middle;\n    border-color: inherit\n}\n\ntfoot {\n    display: table-footer-group;\n    vertical-align: middle;\n    border-color: inherit\n}\n\n/* for tables without table section elements (can happen with XHTML or dynamically created tables) */\ntable > tr {\n    vertical-align: middle;\n}\n\ncol {\n    display: table-column\n}\n\ncolgroup {\n    display: table-column-group\n}\n\ntr {\n    display: table-row;\n    vertical-align: inherit;\n    border-color: inherit\n}\n\ntd, th {\n    display: table-cell;\n    vertical-align: inherit\n}\n\nth {\n    font-weight: bold\n}\n\ncaption {\n    display: table-caption;\n    text-align: -webkit-center\n}\n\n/* lists */\n\nul, menu, dir {\n    display: block;\n    list-style-type: disc;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    -webkit-padding-start: 40px\n}\n\nol {\n    display: block;\n    list-style-type: decimal;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n    -webkit-padding-start: 40px\n}\n\nli {\n    display: list-item;\n    text-align: -webkit-match-parent;\n}\n\nul ul, ol ul {\n    list-style-type: circle\n}\n\nol ol ul, ol ul ul, ul ol ul, ul ul ul {\n    list-style-type: square\n}\n\ndd {\n    display: block;\n    -webkit-margin-start: 40px\n}\n\ndl {\n    display: block;\n    -webkit-margin-before: 1__qem;\n    -webkit-margin-after: 1em;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0;\n}\n\ndt {\n    display: block\n}\n\nol ul, ul ol, ul ul, ol ol {\n    -webkit-margin-before: 0;\n    -webkit-margin-after: 0\n}\n\n/* form elements */\n\nform {\n    display: block;\n    margin-top: 0__qem;\n}\n\nlabel {\n    cursor: default;\n}\n\nlegend {\n    display: block;\n    -webkit-padding-start: 2px;\n    -webkit-padding-end: 2px;\n    border: none\n}\n\nfieldset {\n    display: block;\n    -webkit-margin-start: 2px;\n    -webkit-margin-end: 2px;\n    -webkit-padding-before: 0.35em;\n    -webkit-padding-start: 0.75em;\n    -webkit-padding-end: 0.75em;\n    -webkit-padding-after: 0.625em;\n    border: 2px groove ThreeDFace;\n    min-width: -webkit-min-content;\n}\n\nbutton {\n    -webkit-appearance: button;\n}\n\n/* Form controls don't go vertical. */\ninput, textarea, keygen, select, button, meter, progress {\n    -webkit-writing-mode: horizontal-tb !important;\n}\n\ninput, textarea, keygen, select, button {\n    margin: 0__qem;\n    font: -webkit-small-control;\n    text-rendering: auto; /* FIXME: Remove when tabs work with optimizeLegibility. */\n    color: initial;\n    letter-spacing: normal;\n    word-spacing: normal;\n    line-height: normal;\n    text-transform: none;\n    text-indent: 0;\n    text-shadow: none;\n    display: inline-block;\n    text-align: start;\n}\n\ninput[type=\"hidden\" i] {\n    display: none\n}\n\ninput {\n    -webkit-appearance: textfield;\n    padding: 1px;\n    background-color: white;\n    border: 2px inset;\n    -webkit-rtl-ordering: logical;\n    -webkit-user-select: text;\n    cursor: auto;\n}\n\ninput[type=\"search\" i] {\n    -webkit-appearance: searchfield;\n    box-sizing: border-box;\n}\n\ninput::-webkit-textfield-decoration-container {\n    display: flex;\n    align-items: center;\n    -webkit-user-modify: read-only !important;\n    content: none !important;\n}\n\ninput[type=\"search\" i]::-webkit-textfield-decoration-container {\n    direction: ltr;\n}\n\ninput::-webkit-clear-button {\n    -webkit-appearance: searchfield-cancel-button;\n    display: inline-block;\n    flex: none;\n    -webkit-user-modify: read-only !important;\n    -webkit-margin-start: 2px;\n    opacity: 0;\n    pointer-events: none;\n}\n\ninput:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-clear-button {\n    opacity: 1;\n    pointer-events: auto;\n}\n\ninput[type=\"search\" i]::-webkit-search-cancel-button {\n    -webkit-appearance: searchfield-cancel-button;\n    display: block;\n    flex: none;\n    -webkit-user-modify: read-only !important;\n    -webkit-margin-start: 1px;\n    opacity: 0;\n    pointer-events: none;\n}\n\ninput[type=\"search\" i]:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-search-cancel-button {\n    opacity: 1;\n    pointer-events: auto;\n}\n\ninput[type=\"search\" i]::-webkit-search-decoration {\n    -webkit-appearance: searchfield-decoration;\n    display: block;\n    flex: none;\n    -webkit-user-modify: read-only !important;\n    -webkit-align-self: flex-start;\n    margin: auto 0;\n}\n\ninput[type=\"search\" i]::-webkit-search-results-decoration {\n    -webkit-appearance: searchfield-results-decoration;\n    display: block;\n    flex: none;\n    -webkit-user-modify: read-only !important;\n    -webkit-align-self: flex-start;\n    margin: auto 0;\n}\n\ninput::-webkit-inner-spin-button {\n    -webkit-appearance: inner-spin-button;\n    display: inline-block;\n    cursor: default;\n    flex: none;\n    align-self: stretch;\n    -webkit-user-select: none;\n    -webkit-user-modify: read-only !important;\n    opacity: 0;\n    pointer-events: none;\n}\n\ninput:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-inner-spin-button {\n    opacity: 1;\n    pointer-events: auto;\n}\n\nkeygen, select {\n    border-radius: 5px;\n}\n\nkeygen::-webkit-keygen-select {\n    margin: 0px;\n}\n\ntextarea {\n    -webkit-appearance: textarea;\n    background-color: white;\n    border: 1px solid;\n    -webkit-rtl-ordering: logical;\n    -webkit-user-select: text;\n    flex-direction: column;\n    resize: auto;\n    cursor: auto;\n    padding: 2px;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n}\n\n::-webkit-input-placeholder {\n    -webkit-text-security: none;\n    color: darkGray;\n    display: block !important;\n    pointer-events: none !important;\n}\n\ninput::-webkit-input-placeholder {\n    white-space: pre;\n    word-wrap: normal;\n    overflow: hidden;\n    -webkit-user-modify: read-only !important;\n}\n\ninput[type=\"password\" i] {\n    -webkit-text-security: disc !important;\n}\n\ninput[type=\"hidden\" i], input[type=\"image\" i], input[type=\"file\" i] {\n    -webkit-appearance: initial;\n    padding: initial;\n    background-color: initial;\n    border: initial;\n}\n\ninput[type=\"file\" i] {\n    align-items: baseline;\n    color: inherit;\n    text-align: start !important;\n}\n\ninput:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {\n    background-color: #FAFFBD !important;\n    background-image:none !important;\n    color: #000000 !important;\n}\n\ninput[type=\"radio\" i], input[type=\"checkbox\" i] {\n    margin: 3px 0.5ex;\n    padding: initial;\n    background-color: initial;\n    border: initial;\n}\n\ninput[type=\"button\" i], input[type=\"submit\" i], input[type=\"reset\" i] {\n    -webkit-appearance: push-button;\n    -webkit-user-select: none;\n    white-space: pre\n}\n\ninput[type=\"file\" i]::-webkit-file-upload-button {\n    -webkit-appearance: push-button;\n    -webkit-user-modify: read-only !important;\n    white-space: nowrap;\n    margin: 0;\n    font-size: inherit;\n}\n\ninput[type=\"button\" i], input[type=\"submit\" i], input[type=\"reset\" i], input[type=\"file\" i]::-webkit-file-upload-button, button {\n    align-items: flex-start;\n    text-align: center;\n    cursor: default;\n    color: ButtonText;\n    padding: 2px 6px 3px 6px;\n    border: 2px outset ButtonFace;\n    background-color: ButtonFace;\n    box-sizing: border-box\n}\n\ninput[type=\"range\" i] {\n    -webkit-appearance: slider-horizontal;\n    padding: initial;\n    border: initial;\n    margin: 2px;\n    color: #909090;\n}\n\ninput[type=\"range\" i]::-webkit-slider-container, input[type=\"range\" i]::-webkit-media-slider-container {\n    flex: 1;\n    min-width: 0;\n    box-sizing: border-box;\n    -webkit-user-modify: read-only !important;\n    display: flex;\n}\n\ninput[type=\"range\" i]::-webkit-slider-runnable-track {\n    flex: 1;\n    min-width: 0;\n    -webkit-align-self: center;\n\n    box-sizing: border-box;\n    -webkit-user-modify: read-only !important;\n    display: block;\n}\n\ninput[type=\"range\" i]::-webkit-slider-thumb, input[type=\"range\" i]::-webkit-media-slider-thumb {\n    -webkit-appearance: sliderthumb-horizontal;\n    box-sizing: border-box;\n    -webkit-user-modify: read-only !important;\n    display: block;\n}\n\ninput[type=\"button\" i]:disabled, input[type=\"submit\" i]:disabled, input[type=\"reset\" i]:disabled,\ninput[type=\"file\" i]:disabled::-webkit-file-upload-button, button:disabled,\nselect:disabled, keygen:disabled, optgroup:disabled, option:disabled,\nselect[disabled]>option {\n    color: GrayText\n}\n\ninput[type=\"button\" i]:active, input[type=\"submit\" i]:active, input[type=\"reset\" i]:active, input[type=\"file\" i]:active::-webkit-file-upload-button, button:active {\n    border-style: inset\n}\n\ninput[type=\"button\" i]:active:disabled, input[type=\"submit\" i]:active:disabled, input[type=\"reset\" i]:active:disabled, input[type=\"file\" i]:active:disabled::-webkit-file-upload-button, button:active:disabled {\n    border-style: outset\n}\n\noption:-internal-spatial-navigation-focus {\n    outline: black dashed 1px;\n    outline-offset: -1px;\n}\n\ndatalist {\n    display: none\n}\n\narea {\n    display: inline;\n    cursor: pointer;\n}\n\nparam {\n    display: none\n}\n\ninput[type=\"checkbox\" i] {\n    -webkit-appearance: checkbox;\n    box-sizing: border-box;\n}\n\ninput[type=\"radio\" i] {\n    -webkit-appearance: radio;\n    box-sizing: border-box;\n}\n\ninput[type=\"color\" i] {\n    -webkit-appearance: square-button;\n    width: 44px;\n    height: 23px;\n    background-color: ButtonFace;\n    /* Same as native_theme_base. */\n    border: 1px #a9a9a9 solid;\n    padding: 1px 2px;\n}\n\ninput[type=\"color\" i]::-webkit-color-swatch-wrapper {\n    display:flex;\n    padding: 4px 2px;\n    box-sizing: border-box;\n    -webkit-user-modify: read-only !important;\n    width: 100%;\n    height: 100%\n}\n\ninput[type=\"color\" i]::-webkit-color-swatch {\n    background-color: #000000;\n    border: 1px solid #777777;\n    flex: 1;\n    min-width: 0;\n    -webkit-user-modify: read-only !important;\n}\n\ninput[type=\"color\" i][list] {\n    -webkit-appearance: menulist;\n    width: 88px;\n    height: 23px\n}\n\ninput[type=\"color\" i][list]::-webkit-color-swatch-wrapper {\n    padding-left: 8px;\n    padding-right: 24px;\n}\n\ninput[type=\"color\" i][list]::-webkit-color-swatch {\n    border-color: #000000;\n}\n\ninput::-webkit-calendar-picker-indicator {\n    display: inline-block;\n    width: 0.66em;\n    height: 0.66em;\n    padding: 0.17em 0.34em;\n    -webkit-user-modify: read-only !important;\n    opacity: 0;\n    pointer-events: none;\n}\n\ninput::-webkit-calendar-picker-indicator:hover {\n    background-color: #eee;\n}\n\ninput:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-calendar-picker-indicator,\ninput::-webkit-calendar-picker-indicator:focus {\n    opacity: 1;\n    pointer-events: auto;\n}\n\ninput[type=\"date\" i]:disabled::-webkit-clear-button,\ninput[type=\"date\" i]:disabled::-webkit-inner-spin-button,\ninput[type=\"datetime-local\" i]:disabled::-webkit-clear-button,\ninput[type=\"datetime-local\" i]:disabled::-webkit-inner-spin-button,\ninput[type=\"month\" i]:disabled::-webkit-clear-button,\ninput[type=\"month\" i]:disabled::-webkit-inner-spin-button,\ninput[type=\"week\" i]:disabled::-webkit-clear-button,\ninput[type=\"week\" i]:disabled::-webkit-inner-spin-button,\ninput:disabled::-webkit-calendar-picker-indicator,\ninput[type=\"date\" i][readonly]::-webkit-clear-button,\ninput[type=\"date\" i][readonly]::-webkit-inner-spin-button,\ninput[type=\"datetime-local\" i][readonly]::-webkit-clear-button,\ninput[type=\"datetime-local\" i][readonly]::-webkit-inner-spin-button,\ninput[type=\"month\" i][readonly]::-webkit-clear-button,\ninput[type=\"month\" i][readonly]::-webkit-inner-spin-button,\ninput[type=\"week\" i][readonly]::-webkit-clear-button,\ninput[type=\"week\" i][readonly]::-webkit-inner-spin-button,\ninput[readonly]::-webkit-calendar-picker-indicator {\n    visibility: hidden;\n}\n\nselect {\n    -webkit-appearance: menulist;\n    box-sizing: border-box;\n    align-items: center;\n    border: 1px solid;\n    white-space: pre;\n    -webkit-rtl-ordering: logical;\n    color: black;\n    background-color: white;\n    cursor: default;\n}\n\nselect:not(:-internal-list-box) {\n    overflow: visible !important;\n}\n\nselect:-internal-list-box {\n    -webkit-appearance: listbox;\n    align-items: flex-start;\n    border: 1px inset gray;\n    border-radius: initial;\n    overflow-x: hidden;\n    overflow-y: scroll;\n    vertical-align: text-bottom;\n    -webkit-user-select: none;\n    white-space: nowrap;\n}\n\noptgroup {\n    font-weight: bolder;\n    display: block;\n}\n\noption {\n    font-weight: normal;\n    display: block;\n    padding: 0 2px 1px 2px;\n    white-space: pre;\n    min-height: 1.2em;\n}\n\nselect:-internal-list-box option,\nselect:-internal-list-box optgroup {\n    line-height: initial !important;\n}\n\nselect:-internal-list-box:focus option:checked {\n    background-color: -internal-active-list-box-selection !important;\n    color: -internal-active-list-box-selection-text !important;\n}\n\nselect:-internal-list-box option:checked {\n    background-color: -internal-inactive-list-box-selection !important;\n    color: -internal-inactive-list-box-selection-text !important;\n}\n\nselect:-internal-list-box:disabled option:checked,\nselect:-internal-list-box option:checked:disabled {\n    color: gray !important;\n}\n\nselect:-internal-list-box hr {\n    border-style: none;\n}\n\noutput {\n    display: inline;\n}\n\n/* meter */\n\nmeter {\n    -webkit-appearance: meter;\n    box-sizing: border-box;\n    display: inline-block;\n    height: 1em;\n    width: 5em;\n    vertical-align: -0.2em;\n}\n\nmeter::-webkit-meter-inner-element {\n    -webkit-appearance: inherit;\n    box-sizing: inherit;\n    -webkit-user-modify: read-only !important;\n    height: 100%;\n    width: 100%;\n}\n\nmeter::-webkit-meter-bar {\n    background: linear-gradient(to bottom, #ddd, #eee 20%, #ccc 45%, #ccc 55%, #ddd);\n    height: 100%;\n    width: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\nmeter::-webkit-meter-optimum-value {\n    background: linear-gradient(to bottom, #ad7, #cea 20%, #7a3 45%, #7a3 55%, #ad7);\n    height: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\nmeter::-webkit-meter-suboptimum-value {\n    background: linear-gradient(to bottom, #fe7, #ffc 20%, #db3 45%, #db3 55%, #fe7);\n    height: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\nmeter::-webkit-meter-even-less-good-value {\n    background: linear-gradient(to bottom, #f77, #fcc 20%, #d44 45%, #d44 55%, #f77);\n    height: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\n/* progress */\n\nprogress {\n    -webkit-appearance: progress-bar;\n    box-sizing: border-box;\n    display: inline-block;\n    height: 1em;\n    width: 10em;\n    vertical-align: -0.2em;\n}\n\nprogress::-webkit-progress-inner-element {\n    -webkit-appearance: inherit;\n    box-sizing: inherit;\n    -webkit-user-modify: read-only;\n    height: 100%;\n    width: 100%;\n}\n\nprogress::-webkit-progress-bar {\n    background-color: gray;\n    height: 100%;\n    width: 100%;\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\nprogress::-webkit-progress-value {\n    background-color: green;\n    height: 100%;\n    width: 50%; /* should be removed later */\n    -webkit-user-modify: read-only !important;\n    box-sizing: border-box;\n}\n\n/* inline elements */\n\nu, ins {\n    text-decoration: underline\n}\n\nstrong, b {\n    font-weight: bold\n}\n\ni, cite, em, var, address, dfn {\n    font-style: italic\n}\n\ntt, code, kbd, samp {\n    font-family: monospace\n}\n\npre, xmp, plaintext, listing {\n    display: block;\n    font-family: monospace;\n    white-space: pre;\n    margin: 1__qem 0\n}\n\nmark {\n    background-color: yellow;\n    color: black\n}\n\nbig {\n    font-size: larger\n}\n\nsmall {\n    font-size: smaller\n}\n\ns, strike, del {\n    text-decoration: line-through\n}\n\nsub {\n    vertical-align: sub;\n    font-size: smaller\n}\n\nsup {\n    vertical-align: super;\n    font-size: smaller\n}\n\nnobr {\n    white-space: nowrap\n}\n\n/* states */\n\n:focus {\n    outline: auto 5px -webkit-focus-ring-color\n}\n\n/* Read-only text fields do not show a focus ring but do still receive focus */\nhtml:focus, body:focus, input[readonly]:focus {\n    outline: none\n}\n\napplet:focus, embed:focus, iframe:focus, object:focus {\n    outline: none\n}\n\ninput:focus, textarea:focus, keygen:focus, select:focus {\n    outline-offset: -2px\n}\n\ninput[type=\"button\" i]:focus,\ninput[type=\"checkbox\" i]:focus,\ninput[type=\"file\" i]:focus,\ninput[type=\"hidden\" i]:focus,\ninput[type=\"image\" i]:focus,\ninput[type=\"radio\" i]:focus,\ninput[type=\"reset\" i]:focus,\ninput[type=\"search\" i]:focus,\ninput[type=\"submit\" i]:focus,\ninput[type=\"file\" i]:focus::-webkit-file-upload-button {\n    outline-offset: 0\n}\n\na:-webkit-any-link {\n    color: -webkit-link;\n    text-decoration: underline;\n    cursor: auto;\n}\n\na:-webkit-any-link:active {\n    color: -webkit-activelink\n}\n\n/* HTML5 ruby elements */\n\nruby, rt {\n    text-indent: 0; /* blocks used for ruby rendering should not trigger this */\n}\n\nrt {\n    line-height: normal;\n    -webkit-text-emphasis: none;\n}\n\nruby > rt {\n    display: block;\n    font-size: 50%;\n    text-align: start;\n}\n\nruby > rp {\n    display: none;\n}\n\n/* other elements */\n\nnoframes {\n    display: none\n}\n\nframeset, frame {\n    display: block\n}\n\nframeset {\n    border-color: inherit\n}\n\niframe {\n    border: 2px inset\n}\n\ndetails {\n    display: block\n}\n\nsummary {\n    display: block\n}\n\nsummary::-webkit-details-marker {\n    display: inline-block;\n    width: 0.66em;\n    height: 0.66em;\n    -webkit-margin-end: 0.4em;\n}\n\ntemplate {\n    display: none\n}\n\nbdi, output {\n    unicode-bidi: -webkit-isolate;\n}\n\nbdo {\n    unicode-bidi: bidi-override;\n}\n\ntextarea[dir=auto i] {\n    unicode-bidi: -webkit-plaintext;\n}\n\ndialog:not([open]) {\n    display: none\n}\n\ndialog {\n    position: absolute;\n    left: 0;\n    right: 0;\n    width: -webkit-fit-content;\n    height: -webkit-fit-content;\n    margin: auto;\n    border: solid;\n    padding: 1em;\n    background: white;\n    color: black\n}\n\ndialog::backdrop {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background: rgba(0,0,0,0.1)\n}\n\n/* page */\n\n@page {\n    /* FIXME: Define the right default values for page properties. */\n    size: auto;\n    margin: auto;\n    padding: 0px;\n    border-width: 0px;\n}\n\n/* noscript is handled internally, as it depends on settings. */\n\n`;\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/browser/htmltodom.js":"\"use strict\";\n\nconst parse5 = require(\"parse5\");\nconst sax = require(\"sax\");\nconst attributes = require(\"../living/attributes\");\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst locationInfo = require(\"../living/helpers/internal-constants\").locationInfo;\n\nclass HtmlToDom {\n  constructor(core, parser, parsingMode) {\n    if (!parser) {\n      if (parsingMode === \"xml\") {\n        parser = sax;\n      } else {\n        parser = parse5;\n      }\n    }\n\n    this.core = core;\n    this.parser = parser;\n    this.parsingMode = parsingMode;\n\n    if (parser.DefaultHandler) {\n      this.parserType = \"htmlparser2\";\n    } else if (parser.Parser && parser.TreeAdapters) {\n      this.parserType = \"parse5v1\";\n    } else if (parser.moduleName === \"HTML5\") {\n      this.parserType = \"html5\";\n    } else if (parser.parser) {\n      this.parserType = \"sax\";\n    }\n  }\n\n  appendHtmlToElement(html, element) {\n    if (typeof html !== \"string\") {\n      html = String(html);\n    }\n\n    return this[\"_parseWith\" + this.parserType](html, true, element);\n  }\n\n  appendHtmlToDocument(html, documentImpl) {\n    if (typeof html !== \"string\") {\n      html = String(html);\n    }\n\n    const options = documentImpl._parseOptions;\n    return this[\"_parseWith\" + this.parserType](html, false, documentImpl, options);\n  }\n\n  _parseWithhtmlparser2(html, fragment, element) {\n    const handler = new this.parser.DefaultHandler();\n    // Check if document is XML\n    const isXML = this.parsingMode === \"xml\";\n    const parserInstance = new this.parser.Parser(handler, {\n      xmlMode: isXML,\n      lowerCaseTags: !isXML,\n      lowerCaseAttributeNames: !isXML,\n      decodeEntities: true\n    });\n\n    parserInstance.includeLocation = false;\n    parserInstance.parseComplete(html);\n\n    const parsed = handler.dom;\n    for (let i = 0; i < parsed.length; i++) {\n      setChild(this.core, element, parsed[i]);\n    }\n\n    return element;\n  }\n\n  _parseWithparse5v1(html, fragment, element, options) {\n    if (this.parsingMode === \"xml\") {\n      throw new Error(\"Can't parse XML with parse5, please use htmlparser2 instead.\");\n    }\n\n    const htmlparser2Adapter = this.parser.TreeAdapters.htmlparser2;\n    let dom;\n    if (fragment) {\n      const instance = new this.parser.Parser(htmlparser2Adapter);\n      const parentElement = htmlparser2Adapter.createElement(element.tagName.toLowerCase(), element.namespaceURI, []);\n      dom = instance.parseFragment(html, parentElement);\n    } else {\n      const instance = new this.parser.Parser(htmlparser2Adapter, options);\n      dom = instance.parse(html);\n    }\n\n    const parsed = dom.children;\n    for (let i = 0; i < parsed.length; i++) {\n      setChild(this.core, element, parsed[i]);\n    }\n\n    return element;\n  }\n\n  _parseWithhtml5(html, fragment, element) {\n    if (element.nodeType === 9) {\n      new this.parser.Parser({ document: element }).parse(html);\n    } else {\n      const p = new this.parser.Parser({ document: element.ownerDocument });\n      p.parse_fragment(html, element);\n    }\n  }\n\n  _parseWithsax(html, fragment, element) {\n    const SaxParser = this.parser.parser;\n    const parser = new SaxParser(/* strict = */true, { xmlns: true });\n    parser.noscript = false;\n    parser.looseCase = \"toString\";\n    const openStack = [element];\n    parser.ontext = text => {\n      setChild(this.core, openStack[openStack.length - 1], {\n        type: \"text\",\n        data: text\n      });\n    };\n    parser.onopentag = arg => {\n      const attrValues = {};\n      const attrPrefixes = {};\n      const attrNamespaces = {};\n      Object.keys(arg.attributes).forEach(key => {\n        const localName = arg.attributes[key].local;\n        attrValues[localName] = arg.attributes[key].value;\n        attrPrefixes[localName] = arg.attributes[key].prefix || null;\n        attrNamespaces[localName] = arg.attributes[key].uri || null;\n      });\n\n      if (arg.local === \"script\" && arg.uri === \"http://www.w3.org/1999/xhtml\") {\n        openStack.push({\n          type: \"tag\",\n          name: arg.local,\n          prefix: arg.prefix,\n          namespace: arg.uri,\n          attribs: attrValues,\n          \"x-attribsPrefix\": attrPrefixes,\n          \"x-attribsNamespace\": attrNamespaces\n        });\n      } else {\n        const elem = setChild(this.core, openStack[openStack.length - 1], {\n          type: \"tag\",\n          name: arg.local,\n          prefix: arg.prefix,\n          namespace: arg.uri,\n          attribs: attrValues,\n          \"x-attribsPrefix\": attrPrefixes,\n          \"x-attribsNamespace\": attrNamespaces\n        });\n        openStack.push(elem);\n      }\n    };\n    parser.onclosetag = () => {\n      const elem = openStack.pop();\n      if (elem.constructor.name === \"Object\") { // we have an empty script tag\n        setChild(this.core, openStack[openStack.length - 1], elem);\n      }\n    };\n    parser.onscript = scriptText => {\n      const tag = openStack.pop();\n      tag.children = [{ type: \"text\", data: scriptText }];\n      const elem = setChild(this.core, openStack[openStack.length - 1], tag);\n      openStack.push(elem);\n    };\n    parser.oncomment = comment => {\n      setChild(this.core, openStack[openStack.length - 1], {\n        type: \"comment\",\n        data: comment\n      });\n    };\n    parser.onprocessinginstruction = pi => {\n      setChild(this.core, openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"?\" + pi.name,\n        data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n      });\n    };\n    parser.ondoctype = dt => {\n      setChild(this.core, openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"!doctype\",\n        data: \"!doctype \" + dt\n      });\n\n      const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n      let result;\n      while ((result = entityMatcher.exec(dt))) {\n        const [, name, value] = result;\n        if (!(name in parser.ENTITIES)) {\n          parser.ENTITIES[name] = value;\n        }\n      }\n    };\n\n    parser.onerror = err => {\n      throw err;\n    };\n    parser.write(html).close();\n  }\n}\n\n// utility function for forgiving parser\nfunction setChild(core, parentImpl, node) {\n  const currentDocument = parentImpl && parentImpl._ownerDocument || parentImpl;\n\n  let newNode;\n  let isTemplateContents = false;\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n      break;\n\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        const data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        if (node[\"x-name\"] !== undefined) { // parse5 supports doctypes directly\n          newNode = createDocumentTypeInternal(core, currentDocument,\n            node[\"x-name\"] || \"\",\n            node[\"x-publicId\"] || \"\",\n            node[\"x-systemId\"] || \"\");\n        } else {\n          newNode = parseDocType(core, currentDocument, \"<\" + node.data + \">\");\n        }\n      }\n      break;\n  }\n\n  if (!newNode) {\n    return null;\n  }\n\n  newNode[locationInfo] = node.__location;\n\n  if (node.attribs) {\n    Object.keys(node.attribs).forEach(localName => {\n      const value = node.attribs[localName];\n      let prefix =\n        node[\"x-attribsPrefix\"] &&\n        Object.prototype.hasOwnProperty.call(node[\"x-attribsPrefix\"], localName) &&\n        node[\"x-attribsPrefix\"][localName] || null;\n      const namespace =\n        node[\"x-attribsNamespace\"] &&\n        Object.prototype.hasOwnProperty.call(node[\"x-attribsNamespace\"], localName) &&\n        node[\"x-attribsNamespace\"][localName] || null;\n      if (prefix === \"xmlns\" && localName === \"\") {\n         // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n        localName = prefix;\n        prefix = null;\n      }\n      attributes.setAttributeValue(newNode, localName, value, prefix, namespace);\n    });\n  }\n\n  if (node.children) {\n    for (let c = 0; c < node.children.length; c++) {\n      setChild(core, newNode, node.children[c]);\n    }\n  }\n\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n\n  return newNode;\n}\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(core, doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(core, doc, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentTypeInternal(core, doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentTypeInternal(core, doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n  return createDocumentTypeInternal(core, doc, \"html\", \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(core, ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], { core, ownerDocument, name, publicId, systemId });\n}\n\nexports.HtmlToDom = HtmlToDom;\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/attributes.js":"\"use strict\";\nconst DOMException = require(\"../web-idl/DOMException\");\nconst defineGetter = require(\"../utils\").defineGetter;\nconst idlUtils = require(\"./generated/utils\");\nconst attrGenerated = require(\"./generated/Attr\");\nconst changeAttributeImpl = require(\"./attributes/Attr-impl\").changeAttributeImpl;\nconst getAttrImplQualifiedName = require(\"./attributes/Attr-impl\").getAttrImplQualifiedName;\n\n// https://dom.spec.whatwg.org/#namednodemap\n\nconst INTERNAL = Symbol(\"NamedNodeMap internal\");\n\n// TODO: use NamedPropertyTracker when https://github.com/tmpvar/jsdom/pull/1116 lands?\n\n// Don't emulate named getters for these properties.\n// Compiled later after NamedNodeMap is all set up.\nconst reservedNames = new Set();\n\nfunction NamedNodeMap() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\ndefineGetter(NamedNodeMap.prototype, \"length\", function () {\n  return this[INTERNAL].attributeList.length;\n});\n\nNamedNodeMap.prototype.item = function (index) {\n  if (arguments.length < 1) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.item\");\n  }\n\n  // Don't bother with full unsigned long long conversion. When we have better WebIDL support generally, revisit.\n  index = Number(index);\n\n  return this[index] || null;\n};\n\nNamedNodeMap.prototype.getNamedItem = function (name) {\n  if (arguments.length < 1) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.getNamedItem\");\n  }\n  name = String(name);\n\n  return idlUtils.wrapperForImpl(exports.getAttributeByName(this[INTERNAL].element, name));\n};\n\nNamedNodeMap.prototype.getNamedItemNS = function (namespace, localName) {\n  if (arguments.length < 2) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.getNamedItemNS\");\n  }\n  if (namespace === undefined || namespace === null) {\n    namespace = null;\n  } else {\n    namespace = String(namespace);\n  }\n  localName = String(localName);\n\n  return idlUtils.wrapperForImpl(exports.getAttributeByNameNS(this[INTERNAL].element, namespace, localName));\n};\n\nNamedNodeMap.prototype.setNamedItem = function (attr) {\n  if (!attrGenerated.is(attr)) {\n    throw new TypeError(\"First argument to NamedNodeMap.prototype.setNamedItem must be an Attr\");\n  }\n\n  return idlUtils.wrapperForImpl(exports.setAttribute(this[INTERNAL].element, idlUtils.implForWrapper(attr)));\n};\n\nNamedNodeMap.prototype.setNamedItemNS = function (attr) {\n  if (!attrGenerated.is(attr)) {\n    throw new TypeError(\"First argument to NamedNodeMap.prototype.setNamedItemNS must be an Attr\");\n  }\n\n  return idlUtils.wrapperForImpl(exports.setAttribute(this[INTERNAL].element, idlUtils.implForWrapper(attr)));\n};\n\nNamedNodeMap.prototype.removeNamedItem = function (name) {\n  if (arguments.length < 1) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.getNamedItem\");\n  }\n  name = String(name);\n\n  const attr = exports.removeAttributeByName(this[INTERNAL].element, name);\n\n  if (attr === null) {\n    throw new DOMException(DOMException.NOT_FOUND_ERR, \"Tried to remove an attribute that was not present\");\n  }\n\n  return idlUtils.wrapperForImpl(attr);\n};\n\nNamedNodeMap.prototype.removeNamedItemNS = function (namespace, localName) {\n  if (arguments.length < 2) {\n    throw new TypeError(\"Not enough arguments to NamedNodeMap.prototype.removeNamedItemNS\");\n  }\n  if (namespace === undefined || namespace === null) {\n    namespace = null;\n  } else {\n    namespace = String(namespace);\n  }\n  localName = String(localName);\n\n  const attr = exports.removeAttributeByNameNS(this[INTERNAL].element, namespace, localName);\n\n  if (attr === null) {\n    throw new DOMException(DOMException.NOT_FOUND_ERR, \"Tried to remove an attribute that was not present\");\n  }\n\n  return idlUtils.wrapperForImpl(attr);\n};\n\nexports.NamedNodeMap = NamedNodeMap;\n\n{\n  let prototype = NamedNodeMap.prototype;\n  while (prototype) {\n    for (const name of Object.getOwnPropertyNames(prototype)) {\n      reservedNames.add(name);\n    }\n    prototype = Object.getPrototypeOf(prototype);\n  }\n}\n\nexports.createNamedNodeMap = function (element) {\n  const nnm = Object.create(NamedNodeMap.prototype);\n  nnm[INTERNAL] = {\n    element,\n    attributeList: [],\n    attributesByNameMap: new Map()\n  };\n  return nnm;\n};\n\n// The following three are for https://dom.spec.whatwg.org/#concept-element-attribute-has. We don't just have a\n// predicate tester since removing that kind of flexibility gives us the potential for better future optimizations.\n\nexports.hasAttribute = function (element, A) {\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  return attributeList.includes(A);\n};\n\nexports.hasAttributeByName = function (element, name) {\n  const attributesNNM = element._attributes;\n  const attributesByNameMap = attributesNNM[INTERNAL].attributesByNameMap;\n\n  return attributesByNameMap.has(name);\n};\n\nexports.hasAttributeByNameNS = function (element, namespace, localName) {\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  return attributeList.some(attribute => {\n    return attribute._localName === localName && attribute._namespace === namespace;\n  });\n};\n\nexports.changeAttribute = function (element, attribute, value) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-change\n\n  // The partitioning here works around a particularly bad circular require problem. See\n  // https://github.com/tmpvar/jsdom/pull/1247#issuecomment-149060470\n  changeAttributeImpl(element, attribute, value);\n};\n\nexports.appendAttribute = function (element, attribute) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-append\n\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  // TODO mutation observer stuff\n\n  attributeList.push(attribute);\n  attribute._element = element;\n\n  // Sync target indexed properties\n  attributesNNM[attributeList.length - 1] = idlUtils.wrapperForImpl(attribute);\n\n  const name = getAttrImplQualifiedName(attribute);\n\n  // Sync target named properties\n  if (!reservedNames.has(name) && shouldNameBeInNNMProps(element, name)) {\n    Object.defineProperty(attributesNNM, name, {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: idlUtils.wrapperForImpl(attribute)\n    });\n  }\n\n  // Sync name cache\n  const cache = attributesNNM[INTERNAL].attributesByNameMap;\n  let entry = cache.get(name);\n  if (!entry) {\n    entry = [];\n    cache.set(name, entry);\n  }\n  entry.push(attribute);\n\n  // Run jsdom hooks; roughly correspond to spec's \"An attribute is set and an attribute is added.\"\n  element._attrModified(name, attribute._value, null);\n};\n\nexports.removeAttribute = function (element, attribute) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-remove\n\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  // TODO mutation observer stuff\n\n  for (let i = 0; i < attributeList.length; ++i) {\n    if (attributeList[i] === attribute) {\n      attributeList.splice(i, 1);\n      attribute._element = null;\n\n      // Sync target indexed properties\n      for (let j = i; j < attributeList.length; ++j) {\n        attributesNNM[j] = idlUtils.wrapperForImpl(attributeList[j]);\n      }\n      delete attributesNNM[attributeList.length];\n\n      const name = getAttrImplQualifiedName(attribute);\n\n      // Sync target named properties\n      if (!reservedNames.has(name) && shouldNameBeInNNMProps(element, name)) {\n        delete attributesNNM[name];\n      }\n\n      // Sync name cache\n      const cache = attributesNNM[INTERNAL].attributesByNameMap;\n      const entry = cache.get(name);\n      entry.splice(entry.indexOf(attribute), 1);\n      if (entry.length === 0) {\n        cache.delete(name);\n      }\n\n      // Run jsdom hooks; roughly correspond to spec's \"An attribute is removed.\"\n      element._attrModified(name, null, attribute._value);\n\n      return;\n    }\n  }\n};\n\nexports.replaceAttribute = function (element, oldAttr, newAttr) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-replace\n\n  const attributesNNM = element._attributes;\n  const attributeList = attributesNNM[INTERNAL].attributeList;\n\n  // TODO mutation observer stuff\n\n  for (let i = 0; i < attributeList.length; ++i) {\n    if (attributeList[i] === oldAttr) {\n      attributeList.splice(i, 1, newAttr);\n      oldAttr._element = null;\n      newAttr._element = element;\n\n      // Sync target indexed properties\n      attributesNNM[i] = idlUtils.wrapperForImpl(newAttr);\n\n      const name = getAttrImplQualifiedName(newAttr);\n\n      // Sync target named properties\n      if (!reservedNames.has(name) && shouldNameBeInNNMProps(element, name)) {\n        attributesNNM[name] = newAttr;\n      }\n\n      // Sync name cache\n      const cache = attributesNNM[INTERNAL].attributesByNameMap;\n      let entry = cache.get(name);\n      if (!entry) {\n        entry = [];\n        cache.set(name, entry);\n      }\n      entry.splice(entry.indexOf(oldAttr), 1, newAttr);\n\n      // Run jsdom hooks; roughly correspond to spec's \"An attribute is set and an attribute is changed.\"\n      element._attrModified(name, newAttr._value, oldAttr._value);\n\n      return;\n    }\n  }\n};\n\nexports.getAttributeByName = function (element, name) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name\n\n  if (element._namespaceURI === \"http://www.w3.org/1999/xhtml\" &&\n      element._ownerDocument._parsingMode === \"html\") {\n    name = name.toLowerCase();\n  }\n\n  const cache = element._attributes[INTERNAL].attributesByNameMap;\n  const entry = cache.get(name);\n  if (!entry) {\n    return null;\n  }\n\n  return entry[0];\n};\n\nexports.getAttributeValue = function (element, name) {\n  const attr = exports.getAttributeByName(element, name);\n\n  if (!attr) {\n    return null;\n  }\n\n  return attr._value;\n};\n\nexports.getAttributeByNameNS = function (element, namespace, localName) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace\n\n  if (namespace === \"\") {\n    namespace = null;\n  }\n\n  const attributeList = element._attributes[INTERNAL].attributeList;\n  for (let i = 0; i < attributeList.length; ++i) {\n    const attr = attributeList[i];\n    if (attr._namespace === namespace && attr._localName === localName) {\n      return attr;\n    }\n  }\n\n  return null;\n};\n\nexports.getAttributeValueByNameNS = function (element, namespace, localName) {\n  const attr = exports.getAttributeByNameNS(element, namespace, localName);\n\n  if (!attr) {\n    return null;\n  }\n\n  return attr._value;\n};\n\nexports.setAttribute = function (element, attr) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-set\n\n  if (attr._element !== null && attr._element !== element) {\n    throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n  }\n\n  const oldAttr = exports.getAttributeByNameNS(element, attr._namespace, attr._localName);\n  if (oldAttr === attr) {\n    return attr;\n  }\n\n  if (oldAttr !== null) {\n    exports.replaceAttribute(element, oldAttr, attr);\n  } else {\n    exports.appendAttribute(element, attr);\n  }\n\n  return oldAttr;\n};\n\nexports.setAttributeValue = function (element, localName, value, prefix, namespace) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-set-value\n\n  if (prefix === undefined) {\n    prefix = null;\n  }\n  if (namespace === undefined) {\n    namespace = null;\n  }\n\n  const attribute = exports.getAttributeByNameNS(element, namespace, localName);\n  if (attribute === null) {\n    const newAttribute = attrGenerated.createImpl([], { namespace, namespacePrefix: prefix, localName, value });\n    exports.appendAttribute(element, newAttribute);\n    return;\n  }\n\n  exports.changeAttribute(element, attribute, value);\n};\n\nexports.removeAttributeByName = function (element, name) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name\n\n  const attr = exports.getAttributeByName(element, name);\n\n  if (attr !== null) {\n    exports.removeAttribute(element, attr);\n  }\n\n  return attr;\n};\n\nexports.removeAttributeByNameNS = function (element, namespace, localName) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace\n\n  const attr = exports.getAttributeByNameNS(element, namespace, localName);\n\n  if (attr !== null) {\n    exports.removeAttribute(element, attr);\n  }\n\n  return attr;\n};\n\nexports.copyAttributeList = function (sourceElement, destElement) {\n  // Needed by https://dom.spec.whatwg.org/#concept-node-clone\n\n  for (const sourceAttr of sourceElement._attributes[INTERNAL].attributeList) {\n    const destAttr = attrGenerated.createImpl([], {\n      namespace: sourceAttr._namespace,\n      namespacePrefix: sourceAttr._namespacePrefix,\n      localName: sourceAttr._localName,\n      value: sourceAttr._value\n    });\n\n    exports.appendAttribute(destElement, destAttr);\n  }\n};\n\nexports.attributeListsEqual = function (elementA, elementB) {\n  // Needed by https://dom.spec.whatwg.org/#concept-node-equals\n\n  const listA = elementA._attributes[INTERNAL].attributeList;\n  const listB = elementB._attributes[INTERNAL].attributeList;\n\n  if (listA.length !== listB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < listA.length; ++i) {\n    const attrA = listA[i];\n\n    if (!listB.some(attrB => equalsA(attrB))) {\n      return false;\n    }\n\n    function equalsA(attrB) {\n      return attrA._namespace === attrB._namespace && attrA._localName === attrB._localName &&\n             attrA._value === attrB._value;\n    }\n  }\n\n  return true;\n};\n\nexports.attributeNames = function (element) {\n  // Needed by https://dom.spec.whatwg.org/#dom-element-getattributenames\n\n  return element._attributes[INTERNAL].attributeList.map(getAttrImplQualifiedName);\n};\n\nexports.hasAttributes = function (element) {\n  // Needed by https://dom.spec.whatwg.org/#dom-element-hasattributes\n\n  return element._attributes[INTERNAL].attributeList.length > 0;\n};\n\nfunction shouldNameBeInNNMProps(element, name) {\n  if (element._ownerDocument._parsingMode === \"html\" && element._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n    return name.toLowerCase() === name;\n  }\n  return true;\n}\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/generated/Attr.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\n\nfunction Attr() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\n\nAttr.prototype.toString = function () {\n  if (this === Attr.prototype) {\n    return \"[object AttrPrototype]\";\n  }\n  return this[impl].toString();\n};\nObject.defineProperty(Attr.prototype, \"namespaceURI\", {\n  get() {\n    return this[impl].namespaceURI;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"prefix\", {\n  get() {\n    return this[impl].prefix;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"localName\", {\n  get() {\n    return this[impl].localName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"name\", {\n  get() {\n    return this[impl].name;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"nodeName\", {\n  get() {\n    return this[impl].nodeName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"value\", {\n  get() {\n    return this[impl].value;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V);\n    this[impl].value = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"nodeValue\", {\n  get() {\n    return this[impl].nodeValue;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].nodeValue = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"textContent\", {\n  get() {\n    return this[impl].textContent;\n  },\n  set(V) {\n    V = conversions[\"DOMString\"](V, { treatNullAsEmptyString: true });\n    this[impl].textContent = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"ownerElement\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ownerElement);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Attr.prototype, \"specified\", {\n  get() {\n    return this[impl].specified;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Attr.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Attr.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Attr,\n  expose: {\n    Window: { Attr: Attr }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../attributes/Attr-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/attributes/Attr-impl.js":"\"use strict\";\n\nexports.implementation = class AttrImpl {\n  constructor(_, privateData) {\n    this._namespace = privateData.namespace !== undefined ? privateData.namespace : null;\n    this._namespacePrefix = privateData.namespacePrefix !== undefined ? privateData.namespacePrefix : null;\n    this._localName = privateData.localName;\n    this._value = privateData.value !== undefined ? privateData.value : \"\";\n    this._element = privateData.element !== undefined ? privateData.element : null;\n\n    this.specified = true;\n  }\n\n  get namespaceURI() {\n    return this._namespace;\n  }\n\n  get prefix() {\n    return this._namespacePrefix;\n  }\n\n  get localName() {\n    return this._localName;\n  }\n\n  get name() {\n    return exports.getAttrImplQualifiedName(this);\n  }\n\n  // Delegate to name\n  get nodeName() {\n    return this.name;\n  }\n\n  get value() {\n    return this._value;\n  }\n  set value(v) {\n    if (this._element === null) {\n      this._value = v;\n    } else {\n      exports.changeAttributeImpl(this._element, this, v);\n    }\n  }\n\n  // Delegate to value\n  get nodeValue() {\n    return this.value;\n  }\n  set nodeValue(v) {\n    this.value = v;\n  }\n\n  // Delegate to value\n  get textContent() {\n    return this.value;\n  }\n  set textContent(v) {\n    this.value = v;\n  }\n\n  get ownerElement() {\n    return this._element;\n  }\n};\n\nexports.changeAttributeImpl = function (element, attributeImpl, value) {\n  // https://dom.spec.whatwg.org/#concept-element-attributes-change\n\n  // TODO mutation observer stuff\n\n  const oldValue = attributeImpl._value;\n  attributeImpl._value = value;\n\n  // Run jsdom hooks; roughly correspond to spec's \"An attribute is set and an attribute is changed.\"\n  element._attrModified(exports.getAttrImplQualifiedName(attributeImpl), value, oldValue);\n};\n\nexports.getAttrImplQualifiedName = function (attributeImpl) {\n  // https://dom.spec.whatwg.org/#concept-attribute-qualified-name\n\n  if (attributeImpl._namespacePrefix === null) {\n    return attributeImpl._localName;\n  }\n\n  return attributeImpl._namespacePrefix + \":\" + attributeImpl._localName;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/generated/DocumentType.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Node = require(\"./Node.js\");\nconst impl = utils.implSymbol;\nconst mixin = utils.mixin;\nconst ChildNode = require(\"./ChildNode.js\");\n\nfunction DocumentType() {\n  throw new TypeError(\"Illegal constructor\");\n}\nDocumentType.prototype = Object.create(Node.interface.prototype);\nDocumentType.prototype.constructor = DocumentType;\n\nmixin(DocumentType.prototype, ChildNode.interface.prototype);\nChildNode.mixedInto.push(DocumentType);\n\nDocumentType.prototype.toString = function () {\n  if (this === DocumentType.prototype) {\n    return \"[object DocumentTypePrototype]\";\n  }\n  return Node.interface.prototype.toString.call(this);\n};\nObject.defineProperty(DocumentType.prototype, \"name\", {\n  get() {\n    return this[impl].name;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(DocumentType.prototype, \"publicId\", {\n  get() {\n    return this[impl].publicId;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(DocumentType.prototype, \"systemId\", {\n  get() {\n    return this[impl].systemId;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(DocumentType.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(DocumentType.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    Node._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: DocumentType,\n  expose: {\n    Window: { DocumentType: DocumentType }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/DocumentType-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/generated/Node.js":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst EventTarget = require(\"./EventTarget.js\");\nconst impl = utils.implSymbol;\n\nfunction Node() {\n  throw new TypeError(\"Illegal constructor\");\n}\nNode.prototype = Object.create(EventTarget.interface.prototype);\nNode.prototype.constructor = Node;\n\n\nNode.prototype.hasChildNodes = function hasChildNodes() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].hasChildNodes.apply(this[impl], args);\n};\n\nNode.prototype.normalize = function normalize() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].normalize.apply(this[impl], args);\n};\n\nNode.prototype.cloneNode = function cloneNode() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] !== undefined) {\n  args[0] = conversions[\"boolean\"](args[0]);\n  } else {\n    args[0] = false;\n  }\n  return utils.tryWrapperForImpl(this[impl].cloneNode.apply(this[impl], args));\n};\n\nNode.prototype.isEqualNode = function isEqualNode(otherNode) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'isEqualNode' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  }\n  return this[impl].isEqualNode.apply(this[impl], args);\n};\n\nNode.prototype.compareDocumentPosition = function compareDocumentPosition(other) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'compareDocumentPosition' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return this[impl].compareDocumentPosition.apply(this[impl], args);\n};\n\nNode.prototype.contains = function contains(other) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'contains' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[0] === null || args[0] === undefined) {\n    args[0] = null;\n  } else {\n  }\n  return this[impl].contains.apply(this[impl], args);\n};\n\nNode.prototype.insertBefore = function insertBefore(node, child) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'insertBefore' on 'Node': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  if (args[1] === null || args[1] === undefined) {\n    args[1] = null;\n  } else {\n  }\n  return utils.tryWrapperForImpl(this[impl].insertBefore.apply(this[impl], args));\n};\n\nNode.prototype.appendChild = function appendChild(node) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'appendChild' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].appendChild.apply(this[impl], args));\n};\n\nNode.prototype.replaceChild = function replaceChild(node, child) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'replaceChild' on 'Node': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].replaceChild.apply(this[impl], args));\n};\n\nNode.prototype.removeChild = function removeChild(child) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'removeChild' on 'Node': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = utils.tryImplForWrapper(arguments[i]);\n  }\n  return utils.tryWrapperForImpl(this[impl].removeChild.apply(this[impl], args));\n};\n\nNode.prototype.toString = function () {\n  if (this === Node.prototype) {\n    return \"[object NodePrototype]\";\n  }\n  return EventTarget.interface.prototype.toString.call(this);\n};\nObject.defineProperty(Node, \"ELEMENT_NODE\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"ELEMENT_NODE\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"ATTRIBUTE_NODE\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"ATTRIBUTE_NODE\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"TEXT_NODE\", {\n  value: 3,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"TEXT_NODE\", {\n  value: 3,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"CDATA_SECTION_NODE\", {\n  value: 4,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"CDATA_SECTION_NODE\", {\n  value: 4,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"ENTITY_REFERENCE_NODE\", {\n  value: 5,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"ENTITY_REFERENCE_NODE\", {\n  value: 5,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"ENTITY_NODE\", {\n  value: 6,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"ENTITY_NODE\", {\n  value: 6,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"PROCESSING_INSTRUCTION_NODE\", {\n  value: 7,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"PROCESSING_INSTRUCTION_NODE\", {\n  value: 7,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"COMMENT_NODE\", {\n  value: 8,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"COMMENT_NODE\", {\n  value: 8,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_NODE\", {\n  value: 9,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_NODE\", {\n  value: 9,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_TYPE_NODE\", {\n  value: 10,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_TYPE_NODE\", {\n  value: 10,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_FRAGMENT_NODE\", {\n  value: 11,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_FRAGMENT_NODE\", {\n  value: 11,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"NOTATION_NODE\", {\n  value: 12,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"NOTATION_NODE\", {\n  value: 12,\n  enumerable: true\n});\n\nObject.defineProperty(Node.prototype, \"nodeType\", {\n  get() {\n    return this[impl].nodeType;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"nodeName\", {\n  get() {\n    return this[impl].nodeName;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"baseURI\", {\n  get() {\n    return this[impl].baseURI;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"ownerDocument\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].ownerDocument);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"parentNode\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].parentNode);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"parentElement\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].parentElement);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"childNodes\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].childNodes);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"firstChild\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].firstChild);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"lastChild\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].lastChild);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"previousSibling\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].previousSibling);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"nextSibling\", {\n  get() {\n    return utils.tryWrapperForImpl(this[impl].nextSibling);\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"nodeValue\", {\n  get() {\n    return this[impl].nodeValue;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this[impl].nodeValue = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node.prototype, \"textContent\", {\n  get() {\n    return this[impl].textContent;\n  },\n  set(V) {\n    if (V === null || V === undefined) {\n      V = null;\n    } else {\n    V = conversions[\"DOMString\"](V);\n    }\n    this[impl].textContent = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_DISCONNECTED\", {\n  value: 1,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_DISCONNECTED\", {\n  value: 1,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_PRECEDING\", {\n  value: 2,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_PRECEDING\", {\n  value: 2,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_FOLLOWING\", {\n  value: 4,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_FOLLOWING\", {\n  value: 4,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_CONTAINS\", {\n  value: 8,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_CONTAINS\", {\n  value: 8,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_CONTAINED_BY\", {\n  value: 16,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_CONTAINED_BY\", {\n  value: 16,\n  enumerable: true\n});\n\nObject.defineProperty(Node, \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\", {\n  value: 32,\n  enumerable: true\n});\nObject.defineProperty(Node.prototype, \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\", {\n  value: 32,\n  enumerable: true\n});\n\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(Node.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(Node.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    EventTarget._internalSetup(obj);\n\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: Node,\n  expose: {\n    Window: { Node: Node }\n  }\n};\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/Node-impl.js\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/browser/resource-loader.js":"\"use strict\";\n\nconst parseContentType = require(\"content-type-parser\");\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst parseDataUrl = require(\"../utils\").parseDataUrl;\nconst fs = require(\"fs\");\nconst request = require(\"request\");\nconst documentBaseURLSerialized = require(\"../living/helpers/document-base-url\").documentBaseURLSerialized;\nconst NODE_TYPE = require(\"../living/node-type\");\n\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\nconst URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nfunction createResourceLoadHandler(element, resourceUrl, document, loadCallback) {\n  if (loadCallback === undefined) {\n    loadCallback = () => {\n      // do nothing\n    };\n  }\n  return (err, data, response) => {\n    const ev = document.createEvent(\"HTMLEvents\");\n\n    if (!err) {\n      try {\n        loadCallback.call(element, data, resourceUrl, response);\n        ev.initEvent(\"load\", false, false);\n      } catch (e) {\n        err = e;\n      }\n    }\n\n    if (err) {\n      if (!err.isAbortError) {\n        ev.initEvent(\"error\", false, false);\n        ev.error = err;\n        element.dispatchEvent(ev);\n\n        const error = new Error(`Could not load ${element.localName}: \"${resourceUrl}\"`);\n        error.detail = err;\n        error.type = \"resource loading\";\n\n        document._defaultView._virtualConsole.emit(\"jsdomError\", error);\n      }\n    } else {\n      element.dispatchEvent(ev);\n    }\n  };\n}\n\nexports.readFile = function (filePath, options, callback) {\n  const readableStream = fs.createReadStream(filePath);\n\n  let data = new Buffer(0);\n\n  readableStream.on(\"error\", callback);\n\n  readableStream.on(\"data\", chunk => {\n    data = Buffer.concat([data, chunk]);\n  });\n\n  const defaultEncoding = options.defaultEncoding;\n  const detectMetaCharset = options.detectMetaCharset;\n\n  readableStream.on(\"end\", () => {\n    // Not passing default encoding means binary\n    if (defaultEncoding) {\n      const encoding = detectMetaCharset ? sniffHTMLEncoding(data, { defaultEncoding }) :\n                       whatwgEncoding.getBOMEncoding(data) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(data, encoding);\n      callback(null, decoded, { headers: { \"content-type\": \"text/plain;charset=\" + encoding } });\n    } else {\n      callback(null, data);\n    }\n  });\n\n  return {\n    abort() {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nfunction readDataUrl(dataUrl, options, callback) {\n  const defaultEncoding = options.defaultEncoding;\n  try {\n    const data = parseDataUrl(dataUrl);\n    // If default encoding does not exist, pass on binary data.\n    if (defaultEncoding) {\n      const contentType = parseContentType(data.type) || parseContentType(\"text/plain\");\n      const sniffOptions = {\n        transportLayerEncodingLabel: contentType.get(\"charset\"),\n        defaultEncoding\n      };\n\n      const encoding = options.detectMetaCharset ? sniffHTMLEncoding(data.buffer, sniffOptions) :\n                       whatwgEncoding.getBOMEncoding(data.buffer) ||\n                       whatwgEncoding.labelToName(contentType.get(\"charset\")) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(data.buffer, encoding);\n\n      contentType.set(\"charset\", encoding);\n      data.type = contentType.toString();\n\n      callback(null, decoded, { headers: { \"content-type\": data.type } });\n    } else {\n      callback(null, data.buffer, { headers: { \"content-type\": data.type } });\n    }\n  } catch (err) {\n    callback(err, null);\n  }\n  return null;\n}\n\n// NOTE: request wraps tough-cookie cookie jar\n// (see: https://github.com/request/request/blob/master/lib/cookies.js).\n// Therefore, to pass our cookie jar to the request, we need to create\n// request's wrapper and monkey patch it with our jar.\nexports.wrapCookieJarForRequest = cookieJar => {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n};\n\nfunction fetch(urlObj, options, callback) {\n  if (urlObj.protocol === \"data:\") {\n    return readDataUrl(urlObj.href, options, callback);\n  } else if (urlObj.hostname) {\n    return exports.download(urlObj, options, callback);\n  }\n  const filePath = urlObj.pathname\n    .replace(/^file:\\/\\//, \"\")\n    .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n    .replace(/%20/g, \" \");\n  return exports.readFile(filePath, options, callback);\n}\n\nexports.enqueue = function (element, resourceUrl, callback) {\n  const document = element.nodeType === NODE_TYPE.DOCUMENT_NODE ? element : element._ownerDocument;\n\n  if (document._queue) {\n    const loadHandler = createResourceLoadHandler(element, resourceUrl || document.URL, document, callback);\n    return document._queue.push(loadHandler);\n  }\n\n  return () => {\n    // do nothing in queue-less documents\n  };\n};\n\nexports.download = function (url, options, callback) {\n  const requestOptions = {\n    pool: options.pool,\n    agent: options.agent,\n    agentOptions: options.agentOptions,\n    agentClass: options.agentClass,\n    strictSSL: options.strictSSL,\n    gzip: true,\n    jar: exports.wrapCookieJarForRequest(options.cookieJar),\n    encoding: null,\n    headers: {\n      \"User-Agent\": options.userAgent,\n      \"Accept-Language\": \"en\",\n      Accept: options.accept || \"*/*\"\n    }\n  };\n  if (options.referrer && !IS_BROWSER) {\n    requestOptions.headers.referer = options.referrer;\n  }\n  if (options.proxy) {\n    requestOptions.proxy = options.proxy;\n  }\n  Object.assign(requestOptions.headers, options.headers);\n\n  const defaultEncoding = options.defaultEncoding;\n  const detectMetaCharset = options.detectMetaCharset;\n\n  const req = request(url, requestOptions, (error, response, bufferData) => {\n    if (!error) {\n      // If default encoding does not exist, pass on binary data.\n      if (defaultEncoding) {\n        const contentType = parseContentType(response.headers[\"content-type\"]) || parseContentType(\"text/plain\");\n        const sniffOptions = {\n          transportLayerEncodingLabel: contentType.get(\"charset\"),\n          defaultEncoding\n        };\n\n        const encoding = detectMetaCharset ? sniffHTMLEncoding(bufferData, sniffOptions) :\n                        whatwgEncoding.getBOMEncoding(bufferData) ||\n                        whatwgEncoding.labelToName(contentType.get(\"charset\")) || defaultEncoding;\n        const decoded = whatwgEncoding.decode(bufferData, encoding);\n\n        contentType.set(\"charset\", encoding);\n        response.headers[\"content-type\"] = contentType.toString();\n\n        callback(null, decoded, response);\n      } else {\n        callback(null, bufferData, response);\n      }\n    } else {\n      callback(error, null, response);\n    }\n  });\n  return {\n    abort() {\n      req.abort();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nexports.load = function (element, urlString, options, callback) {\n  const document = element._ownerDocument;\n  const documentImpl = document.implementation;\n\n  if (!documentImpl._hasFeature(\"FetchExternalResources\", element.tagName.toLowerCase())) {\n    return;\n  }\n\n  if (documentImpl._hasFeature(\"SkipExternalResources\", urlString)) {\n    return;\n  }\n\n  const urlObj = URL.parse(urlString);\n  const enqueued = exports.enqueue(element, urlString, callback);\n  const customLoader = document._customResourceLoader;\n  const requestManager = document._requestManager;\n  const cookieJar = document._cookieJar;\n\n  options.accept = element._accept;\n  options.cookieJar = cookieJar;\n  options.referrer = document.URL;\n  options.pool = document._pool;\n  options.agentOptions = document._agentOptions;\n  options.strictSSL = document._strictSSL;\n  options.proxy = document._proxy;\n  options.userAgent = document._defaultView.navigator.userAgent;\n\n  let req = null;\n  function wrappedEnqueued() {\n    if (req && requestManager) {\n      requestManager.remove(req);\n    }\n    // do not trigger if the window is closed\n    if (element._ownerDocument && element._ownerDocument.defaultView.document) {\n      enqueued.apply(this, arguments);\n    }\n  }\n  if (typeof customLoader === \"function\") {\n    req = customLoader({\n      element,\n      url: urlObj,\n      cookie: cookieJar.getCookieStringSync(urlObj, { http: true }),\n      baseUrl: documentBaseURLSerialized(document),\n      defaultFetch(fetchCallback) {\n        return fetch(urlObj, options, fetchCallback);\n      }\n    },\n    wrappedEnqueued);\n  } else {\n    req = fetch(urlObj, options, wrappedEnqueued);\n  }\n  if (req && requestManager) {\n    requestManager.add(req);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/level2/style.js":"\"use strict\";\nconst cssom = require(\"cssom\");\nconst cssstyle = require(\"cssstyle\");\n\nmodule.exports = core => {\n\n  // What works now:\n  // - Accessing the rules defined in individual stylesheets\n  // - Modifications to style content attribute are reflected in style property\n  // - Modifications to style property are reflected in style content attribute\n  // TODO\n  // - Modifications to style element's textContent are reflected in sheet property.\n  // - Modifications to style element's sheet property are reflected in textContent.\n  // - Modifications to link.href property are reflected in sheet property.\n  // - Less-used features of link: disabled\n  // - Less-used features of style: disabled, scoped, title\n  // - CSSOM-View\n  //   - getComputedStyle(): requires default stylesheet, cascading, inheritance,\n  //     filtering by @media (screen? print?), layout for widths/heights\n  // - Load events are not in the specs, but apparently some browsers\n  //   implement something. Should onload only fire after all @imports have been\n  //   loaded, or only the primary sheet?\n\n  core.StyleSheet = cssom.StyleSheet;\n  core.MediaList = cssom.MediaList;\n  core.CSSStyleSheet = cssom.CSSStyleSheet;\n  core.CSSRule = cssom.CSSRule;\n  core.CSSStyleRule = cssom.CSSStyleRule;\n  core.CSSMediaRule = cssom.CSSMediaRule;\n  core.CSSImportRule = cssom.CSSImportRule;\n  core.CSSStyleDeclaration = cssstyle.CSSStyleDeclaration;\n\n  // Relavant specs\n  // http://www.w3.org/TR/DOM-Level-2-Style (2000)\n  // http://www.w3.org/TR/cssom-view/ (2008)\n  // http://dev.w3.org/csswg/cssom/ (2010) Meant to replace DOM Level 2 Style\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/ HTML5, of course\n  // http://dev.w3.org/csswg/css-style-attr/  not sure what's new here\n\n  // Objects that aren't in cssom library but should be:\n  //   CSSRuleList  (cssom just uses array)\n  //   CSSFontFaceRule\n  //   CSSPageRule\n\n  // These rules don't really make sense to implement, so CSSOM draft makes them\n  // obsolete.\n  //   CSSCharsetRule\n  //   CSSUnknownRule\n\n  // These objects are considered obsolete by CSSOM draft, although modern\n  // browsers implement them.\n  //   CSSValue\n  //   CSSPrimitiveValue\n  //   CSSValueList\n  //   RGBColor\n  //   Rect\n  //   Counter\n\n  // http://dev.w3.org/csswg/cssom/#stylesheetlist\n  function StyleSheetList() {}\n\n  StyleSheetList.prototype.__proto__ = Array.prototype;\n\n  StyleSheetList.prototype.item = function item(i) {\n    return Object.prototype.hasOwnProperty.call(this, i) ? this[i] : null;\n  };\n\n  core.StyleSheetList = StyleSheetList;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/level3/xpath.js":"/** Here is yet another implementation of XPath 1.0 in Javascript.\n *\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\n * the axes became more and more complicated. :-(.\n *\n * I have not implemented namespaces or case-sensitive axes for XML yet.\n *\n * How to test it in Chrome: You can make a Chrome extension that replaces\n * the WebKit XPath parser with this one. But it takes a bit of effort to\n * get around isolated world and same-origin restrictions:\n * manifest.json:\n    {\n      \"name\": \"XPathTest\",\n      \"version\": \"0.1\",\n      \"content_scripts\": [{\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\n        \"js\": [\"xpath.js\", \"injection.js\"],\n        \"all_frames\": true, \"run_at\": \"document_start\"\n      }]\n    }\n * injection.js:\n    // goal: give my xpath object to the website's JS context.\n    var script = document.createElement('script');\n    script.textContent =\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\n        \"  console.log('extending document with xpath...');\\n\" +\n        \"  e.detail(window);\" +\n        \"});\";\n    document.documentElement.appendChild(script);\n    document.documentElement.removeChild(script);\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\n    document.dispatchEvent(evt);\n */\nmodule.exports = core => {\n  var xpath = {};\n\n  // Helper function to deal with the migration of Attr to no longer have a nodeName property despite this codebase\n  // assuming it does.\n  function getNodeName(nodeOrAttr) {\n    return nodeOrAttr.constructor.name === 'Attr' ? nodeOrAttr.name : nodeOrAttr.nodeName;\n  }\n\n  /***************************************************************************\n   *                            Tokenization                                 *\n   ***************************************************************************/\n  /**\n   * The XPath lexer is basically a single regular expression, along with\n   * some helper functions to pop different types.\n   */\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null;\n    // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n    this.prev = null;  // for debugging\n    this.prevprev = null;\n  }\n  Stream.prototype = {\n    peek: function() {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n    /** Peek 2 tokens ahead. */\n    peek2: function() {\n      this.peek();  // make sure this.peeked is set\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function() {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function(tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();;\n        }\n      }\n    },\n    trypopfuncname: function() {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok))\n        return null;\n      switch (tok) {\n        case 'comment': case 'text': case 'processing-instruction': case 'node':\n          return null;\n      }\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function() {\n      var tok = this.peek();\n      switch (tok) {\n        case 'ancestor': case 'ancestor-or-self': case 'attribute':\n        case 'child': case 'descendant': case 'descendant-or-self':\n        case 'following': case 'following-sibling': case 'namespace':\n        case 'parent': case 'preceding': case 'preceding-sibling': case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n      return null;\n    },\n    trypopnametest: function() {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n      if ('\"' === first && '\"' === last ||\n          \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function() {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());\n      else return null;\n    },\n    trypopvarref: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);\n      else return null;\n    },\n    position: function() {\n      return this.original.length - this.str.length;\n    }\n  };\n  (function() {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon =\n        'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' +\n        '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' +\n        '\\uFDF0-\\uFFFD';  // JS doesn't support [#x10000-#xEFFFF]\n    var nameCharExceptColon = nameStartCharsExceptColon +\n        '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon +\n        '][' + nameCharExceptColon + ']*'\n    // http://www.w3.org/TR/REC-xml-names/#NT-QName\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::';  // .. must come before [.]\n    var operatorChars =\n        'and|or|mod|div|' +\n        '//|!=|<=|>=|[*/|+\\\\-=<>]';  // //, !=, <=, >= before individual ones.\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*';  // stricter than regexp \\s.\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp(\n        // numberChars before otherChars so that leading-decimal doesn't become .\n        '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' +\n        nameTestChars + '|' + operatorChars + '|' + literal + '|' +\n        variableReference + ')'\n        // operatorName | nodeType | functionName | axisName are lumped into\n        // qName for now; we'll check them on pop.\n    );\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n\n  /***************************************************************************\n   *                               Parsing                                   *\n   ***************************************************************************/\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream,a);\n    var x, unparsed = [];\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n    if (unparsed.length)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  }\n\n  /**\n   * binaryL  ::= subExpr\n   *            | binaryL op subExpr\n   * so a op b op c becomes ((a op b) op c)\n   */\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n    return lhs;\n  }\n  /**\n   * Too bad this is never used. If they made a ** operator (raise to power),\n   ( we would use it.\n   * binaryR  ::= subExpr\n   *            | subExpr op binaryR\n   * so a op b op c becomes (a op (b op c))\n   */\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs;// TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\n   * e.g. a, a/b, //a/b\n   */\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) ||\n           relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\n   */\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\n   *                            | AbbreviatedRelativeLocationPath\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\n   * e.g. p/a, etc.\n   */\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n    var op;\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs,\n                     a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;\n      else isOnlyRootOk = false;\n      if (null == rhs)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\n   *  [12] AbbreviatedStep::= '.' | '..'\n   * e.g. @href, self::p, p, a[@href], ., ..\n   */\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep)  // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep)  // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName)\n        throw new XPathException(\n            XPathException.INVALID_EXPRESSION_ERR,\n            'Position ' + stream.position() +\n            ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';\n      else if ('namespace' === axis) nodeType = 'namespace';\n      else nodeType = 'element';\n    }\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\n   *                | 'descendant' | 'descendant-or-self' | 'following'\n   *                | 'following-sibling' | 'namespace' | 'parent' |\n   *                | 'preceding' | 'preceding-sibling' | 'self'\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\n   */\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\n   * I've split nodeTypeTest from nodeNameTest for convenience.\n   */\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n    if (null != type) {\n      if (null == stream.trypop('('))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen.');\n      var param = undefined;\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected close parens.');\n      return type\n    }\n  }\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;\n    else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\n   *  [9] PredicateExpr::= Expr\n   */\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected expression after [');\n    if (null == stream.trypop(']'))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\n   */\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\n   */\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x)\n      x = stream.trypopnumber();\n    if (null != x) {\n      return x;\n    }\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n    if (null != funCall) {\n      return funCall;\n    }\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression after (.');\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected ) after expression.');\n      return e;\n    }\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\n   *  [17] Argument::= Expr\n   */\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('('))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(','))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression as argument of function.');\n      params.push(param);\n    }\n    return a.node('FunctionCall', name, params);\n  }\n\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\n   */\n  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, '|'); }\n  /** [19] PathExpr ::= LocationPath\n   *                  | FilterExpr\n   *                  | FilterExpr '/' RelativeLocationPath\n   *                  | FilterExpr '//' RelativeLocationPath\n   * Unlike most other nodes, this one always generates a node because\n   * at this point all reverse nodesets must turn into a forward nodeset\n   */\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n      if (null == loc) {\n        throw new Error\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': The expression shouldn\\'t be empty...');\n      }\n      return a.node('PathExpr', loc);\n    }\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;\n    else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\n   */\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred, lhs = primary;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\n   */\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\n   */\n  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, 'and'); }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\n   *                     | EqualityExpr '!=' RelationalExpr\n   */\n  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, ['=','!=']); }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\n   *                       | RelationalExpr '>' AdditiveExpr\n   *                       | RelationalExpr '<=' AdditiveExpr\n   *                       | RelationalExpr '>=' AdditiveExpr\n   */\n  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, ['<','>','<=','>=']); }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\n   *                     | AdditiveExpr '+' MultiplicativeExpr\n   *                     | AdditiveExpr '-' MultiplicativeExpr\n   */\n  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, ['+','-']); }\n  /** [26] MultiplicativeExpr::= UnaryExpr\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\n   *                           | MultiplicativeExpr 'div' UnaryExpr\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\n   */\n  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, ['*','div','mod']); }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\n   */\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    }\n    else return unionExpr(stream, a);\n  }\n  var astFactory = {\n    node: function() {return Array.prototype.slice.call(arguments);}\n  };\n\n\n  /***************************************************************************\n   *                            Optimizations (TODO)                         *\n   ***************************************************************************/\n  /**\n   * Some things I've been considering:\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\n   *    position() or last()\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\n   *    node in the node-set rather than once per (node, position, last).\n   * For more optimizations, look up Gecko's optimizer:\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\n   */\n  // TODO\n  function optimize(ast) {\n  }\n\n  /***************************************************************************\n   *                           Evaluation: axes                              *\n   ***************************************************************************/\n\n  /**\n   * Data types: For string, number, boolean, we just use Javascript types.\n   * Node-sets have the form\n   *    {nodes: [node, ...]}\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\n   *\n   * Most of the time, only the node is used and the position information is\n   * discarded. But if you use a predicate, we need to try every value of\n   * position and last in case the predicate calls position() or last().\n   */\n\n  /**\n   * The NodeMultiSet is a helper class to help generate\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\n   * descendant, descendant-or-self, following-sibling, and\n   * preceding-sibling axes for which we can use a stack to organize things.\n   */\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = [];  // index within nodes that each series begins.\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n          indexInPos = this.nextPos.length,\n          seriesBeginIndex = this.seriesIndexes.pop(),\n          seriesEndIndex = this.nodes.length;\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function() {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n      var lastsJSON = JSON.stringify(this.lasts);\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + lastsJSON);\n        }\n      }\n      this.pushSeries = this.popSeries = this.addNode = function() {\n        throw new Error('Already finalized.');\n      };\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n      this._pushToNodes.call(this.nodes, node)\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function() {\n      this.finalize();\n      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};\n    }\n  };\n  function eachContext(nodeMultiSet) {\n    var r = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n      if (!nodeMultiSet.pos) {\n        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});\n        }\n      }\n    }\n    return r;\n  }\n  /** Matcher used in the axes.\n   */\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest =\n      null == nodeName ? this._alwaysTrue :\n      shouldLowerCase ? this._nodeNameLowerCaseEquals :\n      this._nodeNameEquals;\n  }\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      if (0 === this.nodeTypeNum || this._nodeTypeMatches(node)) {\n        return this.nodeNameTest(getNodeName(node));\n      }\n\n      return false;\n    },\n    _nodeTypeMatches(nodeOrAttr) {\n      if (nodeOrAttr.constructor.name === 'Attr' && this.nodeTypeNum === 2) {\n        return true;\n      }\n      return nodeOrAttr.nodeType === this.nodeTypeNum;\n    },\n    _alwaysTrue: function(name) {return true;},\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n\n  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n    while (0 < nodeList.length) {  // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n      while (null != node) {\n        if (! andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n        if (andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n      while (0 < numPushed--)\n        nodeMultiSet.popSeries();\n    }\n    return nodeMultiSet;\n  }\n\n  /** Returns the next non-descendant node in document order.\n   * This is the first node in following::node(), if node is the context.\n   */\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild)\n        return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n    return null;\n  }\n\n  /** Returns the next node in a document-order depth-first search.\n   * See the definition of document order[1]:\n   *   1) element\n   *   2) namespace nodes\n   *   3) attributes\n   *   4) children\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\n   */\n  function followingNode(node) {\n    if (node.ownerElement)  // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild)\n      return node.firstChild;\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n      node = node.parentNode;\n    } while (node);\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\n   * and namespace nodes).\n   */\n  function precedingNode(node) {\n    if (node.ownerElement)\n      return node.ownerElement;\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n      return node;\n    }\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\n   * But I think it's a pretty useless axis so it's ok. */\n  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start)\n        unorderedFollowingStarts.push(start);\n    }\n    if (0 === unorderedFollowingStarts.length)\n      return {nodes:[]};\n    var pos = [], nextPos = [];\n    var started = 0;\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--){\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i,i+1);\n          started++;\n        }\n      }\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n    console.assert(0 === unorderedFollowingStarts.length);\n    for (var i = 0; i < started; i++)\n      nodeMultiSet.popSeries();\n    return nodeMultiSet.finalize();\n  }\n  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {nodes:{}};\n    var r = {nodes:[], pos:[], lasts:[]};\n    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n      var matches = matcher.matches(cursor);\n      var pos, someoneUsed = false;\n      if (matches)\n        pos = nextPos.slice();\n\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j+1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n    return r;\n  }\n\n  /** node-set, axis -> node-set */\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n    if (null != node && !andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    var pushed = false;\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n    if (andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n    var nodeList = node.childNodes;\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [], attrNodes = [];\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n    nodeMultiSet.finalize();\n    for (var i = attrNodes.length-1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n    return nodeMultiSet;\n  }\n  /**\n   */\n  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node))\n            a.push(node);\n        }\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n      if (0 < a.length)\n        ancestors.push(a);\n    }\n    var lasts = [];\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {nodes:[], pos:[], lasts:[]};\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i+1);\n            lasts.splice(i, i+1);\n          }\n        }\n      }\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\n   * node to the root, of positions within parent.\n   * For convenience, the node is the first element of the array.\n   */\n  function addressVector(node) {\n    var r = [node];\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n    while (null != node) {\n      var i = 0;\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n      r.push(i);\n      node = node.parentNode\n    }\n    return r;\n  }\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node\n        alen = a.length,\n        blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c)\n        break;\n    }\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n    if (0 === c)\n      c = getNodeName(a) - getNodeName(b);\n    if (0 === c)\n      c = 1;\n    return c;\n  }\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {\n    var a = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n    a.sort(addressComparator);\n    var b = [];\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0])\n        continue;\n      b.push(a[i][0]);\n    }\n    return b;\n  }\n  /** Sort node multiset. Does not do any de-duping. */\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({v:v, n:nodeMultiSet.nodes[i],\n              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});\n    }\n    a.sort(compare);\n    var r = {nodes:[], pos:[], lasts:[]};\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\n   * The array starts with document.\n   */\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n    return ancestors;\n  }\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n    while (c = c.previousSibling) {\n      if (c === b)\n        return 1;  // b < a\n    }\n    c = b;\n    while (c = c.previousSibling) {\n      if (c === a)\n        return -1;  // a < b\n    }\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n  function mergeNodeLists(x, y) {\n    var a, b, aanc, banc, r = [];\n    if ('object' !== typeof x)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + x);\n    if ('object' !== typeof y)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + y);\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a)\n          aanc = addressVector(a);\n      }\n      if (null == b) {\n        b = y.shift();\n        if (null != b)\n          banc = addressVector(b);\n      }\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (getNodeName(a) < getNodeName(b)) {  // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (getNodeName(a) > getNodeName(b)) {  // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c);\n        // just skip b without pushing it.\n        b = null;\n        banc = null;\n      }\n    }\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n    return r;\n  }\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison)\n      coersion = fn.number;\n    else coersion =\n      'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] :\n      'number' === typeof x || 'number' === typeof y ? fn.number :\n      fn.string;\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]});\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({nodes:[y.nodes[j]]});\n          if (test(xi, yj)) return true;\n        }\n      }\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);\n        if (test(xi, yc))\n          return true;\n      }\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);\n        if (test(xc, yi))\n          return true;\n      }\n      return false;\n    } else {\n      var xc = coersion(x), yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n  var axes = xpath.axes = {\n    'ancestor':\n      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'ancestor-or-self':\n      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'attribute':\n      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO: figure out whether positions should be undefined here.\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        if (null != nodeName) {\n          // TODO: with namespace\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null == node.getAttributeNode)\n              continue;  // only Element has .getAttributeNode\n            var attr = node.getAttributeNode(nodeName);\n            if (null != attr && matcher.matches(attr)) {\n              nodeMultiSet.pushSeries();\n              nodeMultiSet.addNode(attr);\n              nodeMultiSet.popSeries();\n            }\n          }\n        } else {\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null != node.attributes) {\n              nodeMultiSet.pushSeries();\n              for (var j = 0; j < node.attributes.length; j++) {  // all nodes have .attributes\n                var attr = node.attributes[j];\n                if (matcher.matches(attr))  // TODO: I think this check is unnecessary\n                  nodeMultiSet.addNode(attr);\n              }\n              nodeMultiSet.popSeries();\n            }\n          }\n        }\n        return nodeMultiSet.finalize();\n      },\n    'child':\n      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        for (var i = 0; i < nodeList.length; ++i) {\n          var n = nodeList[i];\n          if (n.ownerElement)  // skip attribute nodes' text child.\n            continue;\n          if (n.childNodes) {\n            nodeMultiSet.pushSeries();\n            var childList = 1 === nodeTypeNum && null != n.children ?\n                n.children : n.childNodes;\n            for (var j = 0; j < childList.length; ++j) {\n              var child = childList[j];\n              if (matcher.matches(child)) {\n                nodeMultiSet.addNode(child);\n              }\n              // don't have to do de-duping because children have parent,\n              // which are current context.\n            }\n            nodeMultiSet.popSeries();\n          }\n        }\n        nodeMultiSet.finalize();\n        return sortNodeMultiSet(nodeMultiSet);\n      },\n    'descendant':\n      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'descendant-or-self':\n      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'following':\n      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'following-sibling':\n      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.shift, function() {return this[0];},\n          function(node) {return node.nextSibling;});\n      },\n    'namespace':\n      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO\n      },\n    'parent':\n      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodes = [], pos = [];\n        for (var i = 0; i < nodeList.length; ++i) {\n          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n          if (null == parent)\n            continue;\n          if (!matcher.matches(parent))\n            continue;\n          if (nodes.length > 0 && parent === nodes[nodes.length-1])\n            continue;\n          nodes.push(parent);\n          pos.push([1]);\n        }\n        return {nodes:nodes, pos:pos, lasts:pos};\n      },\n    'preceding':\n      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return precedingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'preceding-sibling':\n      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.pop, function() {return this[this.length-1];},\n          function(node) {return node.previousSibling},\n          false, true);\n      },\n    'self':\n      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var nodes = [], pos = [];\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        for (var i = 0; i < nodeList.length; ++i) {\n          if (matcher.matches(nodeList[i])) {\n            nodes.push(nodeList[i]);\n            pos.push([1]);\n          }\n        }\n        return {nodes: nodes, pos: pos, lasts: pos}\n      }\n  };\n\n  /***************************************************************************\n   *                         Evaluation: functions                           *\n   ***************************************************************************/\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject)\n        return optObject;\n      if ('string' === typeof optObject)\n        return parseFloat(optObject);  // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n      if ('boolean' === typeof optObject)\n        return +optObject;\n      return fn.number(fn.string.call(this, optObject));  // for node-sets\n    },\n    'string': function string(optObject) {\n      if (null == optObject)\n        return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject ||\n          'number' === typeof optObject)\n        return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent)\n        return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Function count(node-set) ' +\n                                 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {nodes: []};\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({nodes:[idNode]});\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length)\n          continue;\n        var node = doc.getElementById(id);\n        if (null != node)\n          r.nodes.push(node);\n      }\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      // TODO: namespaced version\n      return nodeSet.nodes[0].localName;\n    },\n    'namespace-uri': function(nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      return nodeSet.nodes[0].name;\n    },\n    'concat': function concat(x) {\n      var l = [];\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Must be at least 2 arguments to string()');\n      }\n      var sString = fn.string(string),\n          iStart = fn.round(start),\n          iEnd = optEnd == null ? null : fn.round(optEnd);\n      // Note that xpath string positions user 1-based index\n      if (iEnd == null)\n        return sString.substr(iStart - 1);\n      else\n        return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n          sFrom = fn.string(from),\n          sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i);  // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n        eachCharRe.push(\n          c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').\n            replace(/\\x08/g, '\\\\x08'));\n      }\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function(c) {return map[c];});\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() { return true; },\n    'false': function falseVal() { return false; },\n    // TODO\n    'lang': function lang(string) { throw new Error('Not implemented');},\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this);\n      // for node-sets, map id over each node value.\n      var sum = 0;\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({nodes:[node]});\n        sum += x;\n      }\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: operators                           *\n   ***************************************************************************/\n  var more = {\n    UnaryMinus: function(x) { return -fn.number(x); },\n    '+': function(x, y) { return fn.number(x) + fn.number(y); },\n    '-': function(x, y) { return fn.number(x) - fn.number(y); },\n    '*': function(x, y) { return fn.number(x) * fn.number(y); },\n    'div': function(x, y) { return fn.number(x) / fn.number(y); },\n    'mod': function(x, y) { return fn.number(x) % fn.number(y); },\n    '<': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) < fn.number(y);}, x, y, true);\n    },\n    '<=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) <= fn.number(y);}, x, y, true);\n    },\n    '>':  function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) > fn.number(y);}, x, y, true);\n    },\n    '>=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) >= fn.number(y);}, x, y, true);\n    },\n    'and': function(x, y) { return fn['boolean'](x) && fn['boolean'](y); },\n    'or': function(x, y) { return fn['boolean'](x) || fn['boolean'](y); },\n    '|': function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },\n    '=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x === y;}, x, y);\n      }\n    },\n    '!=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (!aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x !== y;}, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8, // this.doc.COMMENT_NODE,\n    'text': 3, // this.doc.TEXT_NODE,\n    'processing-instruction': 7, // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1  //this.doc.ELEMENT_NODE\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\n   * argument. */\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random()*1000000000);\n    return JSON.stringify(helper(ctx));\n\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function(x) {return helper(x);});\n      }\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx;\n    //  if (ctx.toString) return ctx.toString();\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n      for (var key in ctx) {\n        if (seenKey === key)\n          continue;\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n      delete ctx[seenKey];\n      return nicer;\n    }\n  }\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  }\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n      switch (ast[0]) {\n        case 'Root': return {nodes: [this.doc]};\n        case 'FunctionCall':\n          var functionName = ast[1], functionParams = ast[2];\n          if (null == fn[functionName])\n            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                     'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {nodes: []};\n          var contexts = eachContext(lhs);\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node);\n              // skip over all the rest of the same node.\n              while (i+1 < contexts.length && node === contexts[i+1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n          return ret;\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx);\n          // Make the nodeset a forward-direction-only one.\n          if (x.finalize) {  // it is a NodeMultiSet\n            return {nodes: x.nodes};\n          } else {\n            return x;\n          }\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n              nodeType = ast[2],\n              nodeTypeNum = nodeTypes[nodeType],\n              shouldLowerCase = true,  // TODO: give option\n              nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {nodes:[], pos:[]};\n          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?\n          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {nodes: [context]});\n    return val;\n  }\n\n  /***************************************************************************\n   *                           DOM interface                                 *\n   ***************************************************************************/\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  }\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n\n\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}\n  XPathEvaluator.prototype = {\n    createExpression: function(expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function(nodeResolver) {\n      // TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n\n\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  }\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType)\n        throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(\n            core.DOMException.WRONG_DOCUMENT_ERR,\n            'The document must be the same as the context node\\'s document.');\n      }\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {nodes: [contextNode]});\n      if (XPathResult.NUMBER_TYPE === type)\n        value = fn.number(value);\n      else if (XPathResult.STRING_TYPE === type)\n        value = fn.string(value);\n      else if (XPathResult.BOOLEAN_TYPE === type)\n        value = fn['boolean'](value);\n      else if (XPathResult.ANY_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &&\n               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)\n        throw new core.DOMException(\n            core.DOMException.NOT_SUPPORTED_ERR,\n            'You must provide an XPath result type (0=any).');\n      else if (XPathResult.ANY_TYPE !== type &&\n               'object' !== typeof value)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  }\n\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0;\n\n    // TODO: we removed mutation events but didn't take care of this. No tests fail, so that's nice, but eventually we\n    // should fix this, preferably by entirely replacing our XPath implementation.\n    // this._invalidated = false;\n    // if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\n    //     this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n    //   doc.addEventListener('DOMSubtreeModified', invalidate, true);\n    //   var self = this;\n    //   function invalidate() {\n    //     self._invalidated = true;\n    //     doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n    //   }\n    // }\n  }\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n      switch (typeof this._value) {\n        case 'number': return XPathResult.NUMBER_TYPE;\n        case 'string': return XPathResult.STRING_TYPE;\n        case 'boolean': return XPathResult.BOOLEAN_TYPE;\n        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &&\n          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        return false;\n      return !!this._invalidated;\n    },\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState)\n        throw new core.DOMException(\n            core.DOMException.INVALID_STATE_ERR,\n            'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  };\n  // so you can access ANY_TYPE etc. from the instances:\n  XPathResult.prototype = Object.create(XPathResult,\n      Object.keys(proto).reduce(function (descriptors, name) {\n        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n        return descriptors;\n      }, {\n        constructor: {\n          value: XPathResult,\n          writable: true,\n          configurable: true\n        }\n      }));\n\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n\n  core.Document.prototype.createExpression =\n    XPathEvaluator.prototype.createExpression;\n\n  core.Document.prototype.createNSResolver =\n      XPathEvaluator.prototype.createNSResolver;\n\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n\n  return xpath; // for tests\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/dom-token-list.js":"\"use strict\";\n\nconst DOMException = require(\"../web-idl/DOMException\");\nconst orderedSetParser = require(\"./helpers/ordered-set-parser\");\n\n// https://dom.spec.whatwg.org/#domtokenlist\n\nconst INTERNAL = Symbol(\"DOMTokenList internal\");\n\nclass DOMTokenList {\n  constructor() {\n    throw new TypeError(\"Illegal constructor\");\n  }\n\n  item(index) {\n    const length = this.length;\n    return length <= index || index < 0 ? null : this[index];\n  }\n\n  contains(token) {\n    token = String(token);\n    return indexOf(this, token) !== -1;\n  }\n\n  replace(token, newToken) {\n    token = String(token);\n    newToken = String(newToken);\n    validateTokens(token, newToken);\n    const tokenIndex = indexOf(this, token);\n    if (tokenIndex === -1) {\n      return;\n    }\n    const newTokenIndex = indexOf(this, newToken);\n    if (newTokenIndex !== -1) {\n      spliceLite(this, newTokenIndex, 1);\n    }\n    this[INTERNAL].tokens[tokenIndex] = newToken;\n    update(this);\n  }\n\n  add(/* tokens... */) {\n    for (let i = 0; i < arguments.length; i++) {\n      const token = String(arguments[i]);\n      validateTokens(token);\n\n      if (indexOf(this, token) === -1) {\n        push(this, token);\n      }\n    }\n    update(this);\n  }\n\n  remove(/* tokens... */) {\n    for (let i = 0; i < arguments.length; i++) {\n      const token = String(arguments[i]);\n      validateTokens(token);\n\n      const index = indexOf(this, token);\n      if (index !== -1) {\n        spliceLite(this, index, 1);\n      }\n    }\n    update(this);\n  }\n\n  // if force is true, this behaves like add\n  // if force is false, this behaves like remove\n  // if force is undefined, this behaves as one would expect toggle to\n  // always returns whether classList contains token after toggling\n  toggle(token, force) {\n    token = String(token);\n    force = force === undefined ? undefined : Boolean(force);\n\n    validateTokens(token);\n\n    const index = indexOf(this, token);\n\n    if (index !== -1) {\n      if (force === false || force === undefined) {\n        spliceLite(this, index, 1);\n        update(this);\n        return false;\n      }\n\n      return true;\n    }\n\n    if (force === false) {\n      return false;\n    }\n\n    push(this, token);\n    update(this);\n    return true;\n  }\n\n  get length() {\n    return this[INTERNAL].tokens.length;\n  }\n\n  get value() {\n    return serialize(this);\n  }\n\n  set value(v) {\n    this[INTERNAL].element.setAttribute(this[INTERNAL].attribute, v);\n  }\n\n  toString() {\n    return serialize(this);\n  }\n}\n\nfunction serialize(list) {\n  const value = list[INTERNAL].element.getAttribute(list[INTERNAL].attribute);\n  return value === null ? \"\" : value;\n}\n\nfunction validateTokens(/* tokens... */) {\n  for (let i = 0; i < arguments.length; i++) {\n    const token = String(arguments[i]);\n    if (token === \"\") {\n      throw new DOMException(DOMException.SYNTAX_ERR, \"The token provided must not be empty.\");\n    }\n  }\n  for (let i = 0; i < arguments.length; i++) {\n    const token = String(arguments[i]);\n    if (/\\s/.test(token)) {\n      const whitespaceMsg = \"The token provided contains HTML space characters, which are not valid in tokens.\";\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR, whitespaceMsg);\n    }\n  }\n}\n\nfunction update(list) {\n  const attribute = list[INTERNAL].attribute;\n  list[INTERNAL].element.setAttribute(attribute, list[INTERNAL].tokens.join(\" \"));\n}\n\n// calls indexOf on internal array\nfunction indexOf(dtl, token) {\n  return dtl[INTERNAL].tokens.indexOf(token);\n}\n\n// calls push on internal array, then manually adds indexed property to dtl\nfunction push(dtl, token) {\n  const len = dtl[INTERNAL].tokens.push(token);\n  dtl[len - 1] = token;\n\n  return len;\n}\n\n// calls splice on internal array then rewrites indexed properties of dtl\n// does not allow items to be added, only removed, so splice-lite\nfunction spliceLite(dtl, start, deleteCount) {\n  const tokens = dtl[INTERNAL].tokens;\n  const removedTokens = tokens.splice(start, deleteCount);\n\n  // remove indexed properties from list\n  const re = /^\\d+$/;\n\n  for (const prop in dtl) {\n    if (re.test(prop)) {\n      delete dtl[prop];\n    }\n  }\n\n  // copy indexed properties from internal array\n  const len = tokens.length;\n\n  for (let i = 0; i < len; i++) {\n    dtl[i] = tokens[i];\n  }\n\n  return removedTokens;\n}\n\nexports.DOMTokenList = DOMTokenList;\n\n// set dom token list without running update steps\nexports.reset = function resetDOMTokenList(list, value) {\n  const tokens = list[INTERNAL].tokens;\n\n  spliceLite(list, 0, tokens.length);\n\n  if (value) {\n    for (const token of orderedSetParser(value)) {\n      push(list, token);\n    }\n  }\n};\n\nexports.create = function createDOMTokenList(element, attribute) {\n  const list = Object.create(DOMTokenList.prototype);\n\n  list[INTERNAL] = {\n    element,\n    attribute,\n    tokens: []\n  };\n\n  exports.reset(list, element.getAttribute(attribute));\n\n  return list;\n};\n\nexports.contains = function domTokenListContains(list, token, options) {\n  const caseInsensitive = options && options.caseInsensitive;\n\n  if (!caseInsensitive) {\n    return indexOf(list, token) !== -1;\n  }\n\n  const tokens = list[INTERNAL].tokens;\n  const lowerToken = token.toLowerCase();\n  for (let i = 0; i < tokens.length; ++i) {\n    if (tokens[i].toLowerCase() === lowerToken) {\n      return true;\n    }\n  }\n  return false;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/helpers/ordered-set-parser.js":"\"use strict\";\n\nmodule.exports = function orderedSetParser(input) {\n  return new Set(input.split(/[\\t\\n\\f\\r ]+/).filter(Boolean));\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/form-data-symbols.js":"\"use strict\";\n\nexports.formData = Symbol(\"entries\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/html-collection.js":"\"use strict\";\nconst lengthFromProperties = require(\"../utils\").lengthFromProperties;\nconst getAttributeValue = require(\"./attributes\").getAttributeValue;\nconst idlUtils = require(\"./generated/utils\");\n\nconst privates = Symbol(\"HTMLCollection internal slots\");\n\nconst conflictKeys = new Set([\"length\", \"item\", \"namedItem\"]);\n\nclass HTMLCollection {\n  constructor(secret, element, query) {\n    if (secret !== privates) {\n      throw new TypeError(\"Invalid constructor\");\n    }\n\n    this[privates] = { element, query, keys: [], length: 0, version: -1, conflictElements: Object.create(null) };\n    updateHTMLCollection(this);\n  }\n\n  get length() {\n    updateHTMLCollection(this);\n    return this[privates].length;\n  }\n\n  item(index) {\n    updateHTMLCollection(this);\n    return this[index] || null;\n  }\n\n  namedItem(name) {\n    updateHTMLCollection(this);\n\n    if (conflictKeys.has(name)) {\n      return this[privates].conflictElements[name] || null;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(this, name)) {\n      return this[name];\n    }\n    return null;\n  }\n}\n\nHTMLCollection.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];\n\nfunction updateHTMLCollection(collection) {\n  if (collection[privates].version < collection[privates].element._version) {\n    resetHTMLCollectionTo(collection, collection[privates].query());\n    collection[privates].version = collection[privates].element._version;\n  }\n}\n\nfunction resetHTMLCollectionTo(collection, impls) {\n  const wrappers = impls.map(idlUtils.wrapperForImpl);\n\n  const startingLength = lengthFromProperties(collection);\n  for (let i = 0; i < startingLength; ++i) {\n    delete collection[i];\n  }\n\n  for (let i = 0; i < wrappers.length; ++i) {\n    collection[i] = wrappers[i];\n  }\n  collection[privates].length = wrappers.length;\n\n  const keys = collection[privates].keys;\n  for (let i = 0; i < keys.length; ++i) {\n    delete collection[keys[i]];\n  }\n  keys.length = 0;\n\n  for (let i = 0; i < impls.length; ++i) {\n    addIfAttrPresent(impls[i], wrappers[i], \"name\");\n  }\n  for (let i = 0; i < impls.length; ++i) {\n    addIfAttrPresent(impls[i], wrappers[i], \"id\");\n  }\n\n  function addIfAttrPresent(impl, wrapper, attr) {\n    const value = getAttributeValue(impl, attr);\n\n    if (value === null || value === \"\") {\n      return;\n    }\n\n    // Don't overwrite numeric indices with named ones.\n    const valueAsNumber = Number(value);\n    if (!Number.isNaN(valueAsNumber) && valueAsNumber >= 0) {\n      return;\n    }\n\n    // Don't override existing named ones\n    if (keys.includes(value)) {\n      return;\n    }\n\n    if (conflictKeys.has(value)) {\n      collection[privates].conflictElements[value] = wrapper;\n    } else {\n      collection[value] = wrapper;\n    }\n    keys.push(value);\n  }\n}\n\nmodule.exports = function (core) {\n  core.HTMLCollection = HTMLCollection;\n};\n\nmodule.exports.create = function (element, query) {\n  return new HTMLCollection(privates, element, query);\n};\n\nmodule.exports.update = updateHTMLCollection;\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/index.js":"\"use strict\";\n\nexports.DOMException = require(\"../web-idl/DOMException\");\nexports.NamedNodeMap = require(\"./attributes\").NamedNodeMap;\nexports.Attr = require(\"./generated/Attr\").interface;\nexports.Node = require(\"./generated/Node\").interface;\nexports.Element = require(\"./generated/Element\").interface;\nexports.DocumentFragment = require(\"./generated/DocumentFragment\").interface;\nexports.Document = exports.HTMLDocument = require(\"./generated/Document\").interface;\nexports.XMLDocument = require(\"./generated/XMLDocument\").interface;\nexports.CharacterData = require(\"./generated/CharacterData\").interface;\nexports.Text = require(\"./generated/Text\").interface;\nexports.CDATASection = require(\"./generated/CDATASection\").interface;\nexports.ProcessingInstruction = require(\"./generated/ProcessingInstruction\").interface;\nexports.Comment = require(\"./generated/Comment\").interface;\nexports.DocumentType = require(\"./generated/DocumentType\").interface;\nexports.DOMImplementation = require(\"./generated/DOMImplementation\").interface;\n\nexports.Event = require(\"./generated/Event\").interface;\nexports.CustomEvent = require(\"./generated/CustomEvent\").interface;\nexports.MessageEvent = require(\"./generated/MessageEvent\").interface;\nexports.ErrorEvent = require(\"./generated/ErrorEvent\").interface;\nexports.HashChangeEvent = require(\"./generated/HashChangeEvent\").interface;\nexports.FocusEvent = require(\"./generated/FocusEvent\").interface;\nexports.PopStateEvent = require(\"./generated/PopStateEvent\").interface;\nexports.UIEvent = require(\"./generated/UIEvent\").interface;\nexports.MouseEvent = require(\"./generated/MouseEvent\").interface;\nexports.KeyboardEvent = require(\"./generated/KeyboardEvent\").interface;\nexports.TouchEvent = require(\"./generated/TouchEvent\").interface;\nexports.ProgressEvent = require(\"./generated/ProgressEvent\").interface;\nexports.EventTarget = require(\"./generated/EventTarget\").interface;\n\nexports.Location = require(\"./generated/Location\").interface;\nexports.History = require(\"./generated/History\").interface;\n\nexports.Blob = require(\"./generated/Blob\").interface;\nexports.File = require(\"./generated/File\").interface;\nexports.FileList = require(\"./generated/FileList\").interface;\n\nexports.DOMParser = require(\"./generated/DOMParser\").interface;\n\nexports.FormData = require(\"./generated/FormData\").interface;\n\nrequire(\"./register-elements\")(exports);\n\n// These need to be cleaned up...\nrequire(\"../level2/style\")(exports);\nrequire(\"../level3/xpath\")(exports);\n\n// These are OK but need migration to webidl2js eventually.\nrequire(\"./html-collection\")(exports);\nrequire(\"./node-filter\")(exports);\nrequire(\"./node-iterator\")(exports);\nrequire(\"./node-list\")(exports);\nrequire(\"./xmlhttprequest-event-target\")(exports);\nrequire(\"./xmlhttprequest-upload\")(exports);\n\nexports.DOMTokenList = require(\"./dom-token-list\").DOMTokenList;\nexports.URL = require(\"whatwg-url\").URL;\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/named-properties-window.js":"\"use strict\";\nconst hasOwnProp = Object.prototype.hasOwnProperty;\nconst namedPropertiesTracker = require(\"../named-properties-tracker\");\nconst NODE_TYPE = require(\"./node-type\");\nconst createHTMLCollection = require(\"./html-collection\").create;\nconst treeOrderSorter = require(\"../utils\").treeOrderSorter;\nconst idlUtils = require(\"./generated/utils\");\n\nfunction isNamedPropertyElement(element) {\n  // (for the name attribute)\n\n  // use hasOwnProperty to make sure contentWindow comes from the prototype,\n  // and is not set directly on the node by a script.\n  if (\"contentWindow\" in element && !hasOwnProp.call(element, \"contentWindow\")) {\n    return true;\n  }\n\n  switch (element.nodeName) {\n    case \"A\":\n    case \"APPLET\":\n    case \"AREA\":\n    case \"EMBED\":\n    case \"FORM\":\n    case \"FRAMESET\":\n    case \"IMG\":\n    case \"OBJECT\":\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction namedPropertyResolver(HTMLCollection, window, name, values) {\n  function getResult() {\n    const results = [];\n\n    for (const node of values().keys()) {\n      if (node.nodeType !== NODE_TYPE.ELEMENT_NODE) {\n        continue;\n      }\n\n      if (node.getAttribute(\"id\") === name) {\n        results.push(node);\n      } else if (node.getAttribute(\"name\") === name && isNamedPropertyElement(node)) {\n        results.push(node);\n      }\n    }\n\n    results.sort(treeOrderSorter);\n\n    return results;\n  }\n\n  const document = window._document;\n  const objects = createHTMLCollection(idlUtils.implForWrapper(document.documentElement), getResult);\n\n  const length = objects.length;\n  for (let i = 0; i < length; ++i) {\n    const node = objects[i];\n\n    if (\"contentWindow\" in node && !hasOwnProp.call(node, \"contentWindow\") &&\n       node.getAttribute(\"name\") === name) {\n      return node.contentWindow;\n    }\n  }\n\n  if (length === 0) {\n    return undefined;\n  }\n\n  if (length === 1) {\n    return objects[0];\n  }\n\n  return objects;\n}\n\nexports.initializeWindow = function (window, HTMLCollection) {\n  namedPropertiesTracker.create(window, namedPropertyResolver.bind(null, HTMLCollection));\n};\n\nexports.elementAttributeModified = function (element, name, value, oldValue) {\n  if (!element._attached) {\n    return;\n  }\n\n  const useName = isNamedPropertyElement(element);\n\n  if (name === \"id\" || (name === \"name\" && useName)) {\n    const tracker = namedPropertiesTracker.get(element._ownerDocument._global);\n\n    // (tracker will be null if the document has no Window)\n    if (tracker) {\n      if (name === \"id\" && (!useName || element.getAttribute(\"name\") !== oldValue)) {\n        tracker.untrack(oldValue, element);\n      }\n\n      if (name === \"name\" && element.getAttribute(\"id\") !== oldValue) {\n        tracker.untrack(oldValue, element);\n      }\n\n      tracker.track(value, element);\n    }\n  }\n};\n\nexports.nodeAttachedToDocument = function (node) {\n  if (node.nodeType !== NODE_TYPE.ELEMENT_NODE) {\n    return;\n  }\n\n  const tracker = namedPropertiesTracker.get(node._ownerDocument._global);\n  if (!tracker) {\n    return;\n  }\n\n  tracker.track(node.getAttribute(\"id\"), node);\n\n  if (isNamedPropertyElement(node)) {\n    tracker.track(node.getAttribute(\"name\"), node);\n  }\n};\n\nexports.nodeDetachedFromDocument = function (node) {\n  if (node.nodeType !== NODE_TYPE.ELEMENT_NODE) {\n    return;\n  }\n\n  const tracker = namedPropertiesTracker.get(node._ownerDocument._global);\n  if (!tracker) {\n    return;\n  }\n\n  tracker.untrack(node.getAttribute(\"id\"), node);\n\n  if (isNamedPropertyElement(node)) {\n    tracker.untrack(node.getAttribute(\"name\"), node);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/node-document-position.js":"\"use strict\";\n\nmodule.exports = Object.freeze({\n  DOCUMENT_POSITION_DISCONNECTED: 1,\n  DOCUMENT_POSITION_PRECEDING: 2,\n  DOCUMENT_POSITION_FOLLOWING: 4,\n  DOCUMENT_POSITION_CONTAINS: 8,\n  DOCUMENT_POSITION_CONTAINED_BY: 16,\n  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32\n});\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/node-filter.js":"\"use strict\";\nconst addConstants = require(\"../utils\").addConstants;\n\nmodule.exports = function (core) {\n  // https://dom.spec.whatwg.org/#interface-nodefilter\n  core.NodeFilter = function () {\n    throw new TypeError(\"Illegal constructor\");\n  };\n\n  /**\n   * Returns an unsigned short that will be used to tell if a given Node must\n   * be accepted or not by the NodeIterator or TreeWalker iteration\n   * algorithm. This method is expected to be written by the user of a\n   * NodeFilter.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter\n   * @interface\n   *\n   * @param  {Node} node DOM Node\n   * @return {FILTER_ACCEPT|FILTER_REJECT|FILTER_SKIP}\n   */\n  core.NodeFilter.acceptNode = function (/* node */) {\n    throw new Error(\"This method is expected to be written by the user of a NodeFilter.\");\n  };\n\n  addConstants(core.NodeFilter, {\n    // Constants for whatToShow\n    SHOW_ALL: 0xFFFFFFFF,\n    SHOW_ELEMENT: 0x00000001,\n    SHOW_ATTRIBUTE: 0x00000002,\n    SHOW_TEXT: 0x00000004,\n    SHOW_CDATA_SECTION: 0x00000008,\n    SHOW_ENTITY_REFERENCE: 0x00000010,\n    SHOW_ENTITY: 0x00000020,\n    SHOW_PROCESSING_INSTRUCTION: 0x00000040,\n    SHOW_COMMENT: 0x00000080,\n    SHOW_DOCUMENT: 0x00000100,\n    SHOW_DOCUMENT_TYPE: 0x00000200,\n    SHOW_DOCUMENT_FRAGMENT: 0x00000400,\n    SHOW_NOTATION: 0x00000800,\n\n    // Constants returned by acceptNode\n    FILTER_ACCEPT: 1,\n    FILTER_REJECT: 2,\n    FILTER_SKIP: 3\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/node-iterator.js":"\"use strict\";\n\nconst idlUtils = require(\"./generated/utils\");\nconst domSymbolTree = require(\"./helpers/internal-constants\").domSymbolTree;\nconst defineGetter = require(\"../utils\").defineGetter;\nconst INTERNAL = Symbol(\"NodeIterator internal\");\nconst DocumentImpl = require(\"./nodes/Document-impl\").implementation;\n\nmodule.exports = function (core) {\n  // https://dom.spec.whatwg.org/#interface-nodeiterator\n\n  function NodeIteratorInternal(document, root, whatToShow, filter) {\n    this.active = true;\n    this.document = document;\n    this.root = root;\n    this.referenceNode = root;\n    this.pointerBeforeReferenceNode = true;\n    this.whatToShow = whatToShow;\n    this.filter = filter;\n  }\n\n  NodeIteratorInternal.prototype.throwIfNotActive = function () {\n    // (only thrown for getters/methods that are affected by removing steps)\n    if (!this.active) {\n      throw Error(\"This NodeIterator is no longer active. \" +\n                  \"More than \" + this.document._activeNodeIteratorsMax +\n                  \" iterators are being used concurrently. \" +\n                  \"You can increase the 'concurrentNodeIterators' option to \" +\n                  \"make this error go away.\"\n      );\n      // Alternatively, you can pester Ecma to add support for weak references,\n      // the DOM standard assumes the implementor has control over object life cycles.\n    }\n  };\n\n  NodeIteratorInternal.prototype.traverse = function (next) {\n    let node = this.referenceNode;\n    let beforeNode = this.pointerBeforeReferenceNode;\n\n    do {\n      if (next) {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = false;\n      } else { // previous\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = true;\n      }\n    }\n    while (this.filterNode(node) !== core.NodeFilter.FILTER_ACCEPT);\n\n    this.pointerBeforeReferenceNode = beforeNode;\n    this.referenceNode = node;\n    return node;\n  };\n\n  NodeIteratorInternal.prototype.filterNode = function (node) {\n    const n = node.nodeType - 1;\n    if (!(this.whatToShow & (1 << n))) {\n      return core.NodeFilter.FILTER_SKIP;\n    }\n\n    let ret = core.NodeFilter.FILTER_ACCEPT;\n    const filter = this.filter;\n    if (typeof filter === \"function\") {\n      ret = filter(node);\n    } else if (filter && typeof filter.acceptNode === \"function\") {\n      ret = filter.acceptNode(node);\n    }\n\n    if (ret === true) {\n      return core.NodeFilter.FILTER_ACCEPT;\n    } else if (ret === false) {\n      return core.NodeFilter.FILTER_REJECT;\n    }\n\n    return ret;\n  };\n\n  NodeIteratorInternal.prototype.runRemovingSteps = function (oldNode, oldParent, oldPreviousSibling) {\n    if (oldNode.contains(this.root)) {\n      return;\n    }\n\n    // If oldNode is not an inclusive ancestor of the referenceNode\n    // attribute value, terminate these steps.\n    if (!oldNode.contains(this.referenceNode)) {\n      return;\n    }\n\n    if (this.pointerBeforeReferenceNode) {\n      // Let nextSibling be oldPreviousSiblings next sibling, if oldPreviousSibling is non-null,\n      // and oldParents first child otherwise.\n      const nextSibling = oldPreviousSibling ?\n                          oldPreviousSibling.nextSibling :\n                          oldParent.firstChild;\n\n      // If nextSibling is non-null, set the referenceNode attribute to nextSibling\n      // and terminate these steps.\n      if (nextSibling) {\n        this.referenceNode = nextSibling;\n        return;\n      }\n\n      // Let next be the first node following oldParent (excluding any children of oldParent).\n      const next = domSymbolTree.following(oldParent, { skipChildren: true });\n\n      // If root is an inclusive ancestor of next, set the referenceNode\n      // attribute to next and terminate these steps.\n      if (this.root.contains(next)) {\n        this.referenceNode = next;\n        return;\n      }\n\n      // Otherwise, set the pointerBeforeReferenceNode attribute to false.\n      this.pointerBeforeReferenceNode = false;\n\n      // Note: Steps are not terminated here.\n    }\n\n    // Set the referenceNode attribute to the last inclusive descendant in tree order of oldPreviousSibling,\n    // if oldPreviousSibling is non-null, and to oldParent otherwise.\n    this.referenceNode = oldPreviousSibling ?\n                             domSymbolTree.lastInclusiveDescendant(oldPreviousSibling) :\n                             oldParent;\n  };\n\n  DocumentImpl._removingSteps.push((document, oldNode, oldParent, oldPreviousSibling) => {\n    for (let i = 0; i < document._activeNodeIterators.length; ++i) {\n      const internal = document._activeNodeIterators[i];\n      internal.runRemovingSteps(oldNode, oldParent, oldPreviousSibling);\n    }\n  });\n\n  core.Document.prototype.createNodeIterator = function (root, whatToShow, filter) {\n    if (!root) {\n      throw new TypeError(\"Not enough arguments to Document.createNodeIterator.\");\n    }\n    root = idlUtils.implForWrapper(root);\n\n    if (filter === undefined) {\n      filter = null;\n    }\n\n    if (filter !== null &&\n        typeof filter !== \"function\" &&\n        typeof filter.acceptNode !== \"function\") {\n      throw new TypeError(\"Argument 3 of Document.createNodeIterator should be a function or implement NodeFilter.\");\n    }\n\n    const document = root._ownerDocument;\n\n    whatToShow = whatToShow === undefined ?\n      core.NodeFilter.SHOW_ALL :\n      (whatToShow & core.NodeFilter.SHOW_ALL) >>> 0; // >>> makes sure the result is unsigned\n\n    filter = filter || null;\n\n    const it = Object.create(core.NodeIterator.prototype);\n    const internal = new NodeIteratorInternal(document, root, whatToShow, filter);\n    it[INTERNAL] = internal;\n\n    document._activeNodeIterators.push(internal);\n    while (document._activeNodeIterators.length > document._activeNodeIteratorsMax) {\n      const internalOther = document._activeNodeIterators.shift();\n      internalOther.active = false;\n    }\n\n    return it;\n  };\n\n  core.NodeIterator = function NodeIterator() {\n    throw new TypeError(\"Illegal constructor\");\n  };\n\n  defineGetter(core.NodeIterator.prototype, \"root\", function () {\n    return idlUtils.wrapperForImpl(this[INTERNAL].root);\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"referenceNode\", function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return idlUtils.wrapperForImpl(internal.referenceNode);\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"pointerBeforeReferenceNode\", function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return internal.pointerBeforeReferenceNode;\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"whatToShow\", function () {\n    return this[INTERNAL].whatToShow;\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"filter\", function () {\n    return this[INTERNAL].filter;\n  });\n\n  core.NodeIterator.prototype.previousNode = function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return idlUtils.wrapperForImpl(internal.traverse(false));\n  };\n\n  core.NodeIterator.prototype.nextNode = function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return idlUtils.wrapperForImpl(internal.traverse(true));\n  };\n\n  core.NodeIterator.prototype.detach = function () {\n    // noop\n  };\n\n  core.NodeIterator.prototype.toString = function () {\n    return \"[object NodeIterator]\";\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js":"\"use strict\";\n\nconst CookieJar = require(\"tough-cookie\").CookieJar;\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst isNodeImpl = require(\"../generated/Node\").isImpl;\n\nconst NODE_TYPE = require(\"../node-type\");\nconst memoizeQuery = require(\"../../utils\").memoizeQuery;\nconst firstChildWithHTMLLocalName = require(\"../helpers/traversal\").firstChildWithHTMLLocalName;\nconst firstChildWithHTMLLocalNames = require(\"../helpers/traversal\").firstChildWithHTMLLocalNames;\nconst firstDescendantWithHTMLLocalName = require(\"../helpers/traversal\").firstDescendantWithHTMLLocalName;\nconst whatwgURL = require(\"whatwg-url\");\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst stripAndCollapseASCIIWhitespace = require(\"../helpers/strings\").stripAndCollapseASCIIWhitespace;\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst HtmlToDom = require(\"../../browser/htmltodom\").HtmlToDom;\nconst History = require(\"../generated/History\");\nconst Location = require(\"../generated/Location\");\nconst createHTMLCollection = require(\"../html-collection\").create;\nconst idlUtils = require(\"../generated/utils\");\nconst validateName = require(\"../helpers/validate-names\").name;\nconst validateAndExtract = require(\"../helpers/validate-names\").validateAndExtract;\nconst resourceLoader = require(\"../../browser/resource-loader\");\n\nconst clone = require(\"../node\").clone;\nconst generatedAttr = require(\"../generated/Attr\");\nconst listOfElementsWithQualifiedName = require(\"../node\").listOfElementsWithQualifiedName;\nconst listOfElementsWithNamespaceAndLocalName = require(\"../node\").listOfElementsWithNamespaceAndLocalName;\nconst listOfElementsWithClassNames = require(\"../node\").listOfElementsWithClassNames;\nconst Comment = require(\"../generated/Comment\");\nconst ProcessingInstruction = require(\"../generated/ProcessingInstruction\");\nconst CDATASection = require(\"../generated/CDATASection\");\nconst Text = require(\"../generated/Text\");\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\nconst DOMImplementation = require(\"../generated/DOMImplementation\");\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\nconst HTMLElement = require(\"../generated/HTMLElement\");\nconst HTMLUnknownElement = require(\"../generated/HTMLUnknownElement\");\nconst TreeWalker = require(\"../generated/TreeWalker\");\n\nconst CustomEvent = require(\"../generated/CustomEvent\");\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\nconst Event = require(\"../generated/Event\");\nconst FocusEvent = require(\"../generated/FocusEvent\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent\");\nconst KeyboardEvent = require(\"../generated/KeyboardEvent\");\nconst MessageEvent = require(\"../generated/MessageEvent\");\nconst MouseEvent = require(\"../generated/MouseEvent\");\nconst PopStateEvent = require(\"../generated/PopStateEvent\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst TouchEvent = require(\"../generated/TouchEvent\");\nconst UIEvent = require(\"../generated/UIEvent\");\n\nfunction clearChildNodes(node) {\n  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction setInnerHTML(document, node, html) {\n  // Clear the children first:\n  if (node._templateContents) {\n    clearChildNodes(node._templateContents);\n  } else {\n    clearChildNodes(node);\n  }\n\n  if (html !== \"\") {\n    if (node.nodeName === \"#document\") {\n      document._htmlToDom.appendHtmlToDocument(html, node);\n    } else {\n      document._htmlToDom.appendHtmlToElement(html, node);\n    }\n  }\n}\n\nclass ResourceQueue {\n  constructor(paused) {\n    this.paused = Boolean(paused);\n  }\n\n  push(callback) {\n    const q = this;\n    const item = {\n      prev: q.tail,\n      check() {\n        if (!q.paused && !this.prev && this.fired) {\n          callback(this.err, this.data, this.response);\n          if (this.next) {\n            this.next.prev = null;\n            this.next.check();\n          } else { // q.tail===this\n            q.tail = null;\n          }\n        }\n      }\n    };\n    if (q.tail) {\n      q.tail.next = item;\n    }\n    q.tail = item;\n    return (err, data, response) => {\n      item.fired = 1;\n      item.err = err;\n      item.data = data;\n      item.response = response;\n      item.check();\n    };\n  }\n\n  resume() {\n    if (!this.paused) {\n      return;\n    }\n    this.paused = false;\n\n    let head = this.tail;\n    while (head && head.prev) {\n      head = head.prev;\n    }\n    if (head) {\n      head.check();\n    }\n  }\n}\n\nclass RequestManager {\n  constructor() {\n    this.openedRequests = [];\n  }\n\n  add(req) {\n    this.openedRequests.push(req);\n  }\n\n  remove(req) {\n    const idx = this.openedRequests.indexOf(req);\n    if (idx !== -1) {\n      this.openedRequests.splice(idx, 1);\n    }\n  }\n\n  close() {\n    for (const openedRequest of this.openedRequests) {\n      openedRequest.abort();\n    }\n    this.openedRequests = [];\n  }\n\n  size() {\n    return this.openedRequests.length;\n  }\n}\n\nfunction pad(number) {\n  if (number < 10) {\n    return \"0\" + number;\n  }\n  return number;\n}\n\nfunction toLastModifiedString(date) {\n  return pad(date.getMonth() + 1) +\n    \"/\" + pad(date.getDate()) +\n    \"/\" + date.getFullYear() +\n    \" \" + pad(date.getHours()) +\n    \":\" + pad(date.getMinutes()) +\n    \":\" + pad(date.getSeconds());\n}\n\nconst nonInheritedTags = new Set([\n  \"article\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"address\", \"dt\",\n  \"dd\", \"figure\", \"figcaption\", \"main\", \"em\", \"strong\", \"small\", \"s\", \"cite\", \"dfn\", \"abbr\",\n  \"ruby\", \"rt\", \"rp\", \"code\", \"var\", \"samp\", \"kbd\", \"i\", \"b\", \"u\", \"mark\", \"bdi\", \"bdo\", \"wbr\"\n]);\n\nconst eventInterfaceTable = {\n  customevent: CustomEvent,\n  errorevent: ErrorEvent,\n  event: Event,\n  events: Event,\n  focusevent: FocusEvent,\n  hashchangeevent: HashChangeEvent,\n  htmlevents: Event,\n  keyboardevent: KeyboardEvent,\n  messageevent: MessageEvent,\n  mouseevent: MouseEvent,\n  mouseevents: MouseEvent,\n  popstateevent: PopStateEvent,\n  progressevent: ProgressEvent,\n  svgevents: Event,\n  touchevent: TouchEvent,\n  uievent: UIEvent,\n  uievents: UIEvent\n};\n\nclass DocumentImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._ownerDocument = this;\n    this.nodeType = NODE_TYPE.DOCUMENT_NODE;\n    if (!privateData.options) {\n      privateData.options = {};\n    }\n    if (!privateData.options.parsingMode) {\n      privateData.options.parsingMode = \"xml\";\n    }\n\n    this._parsingMode = privateData.options.parsingMode;\n    this._htmlToDom = new HtmlToDom(privateData.core, privateData.options.parser, privateData.options.parsingMode);\n\n    this._implementation = DOMImplementation.createImpl([], {\n      core: this._core,\n      ownerDocument: this\n    });\n\n    this._defaultView = privateData.options.defaultView || null;\n    this._global = privateData.options.global;\n    this._documentElement = null;\n    this._ids = Object.create(null);\n    this._attached = true;\n    this._currentScript = null;\n    this._cookieJar = privateData.options.cookieJar;\n    this._parseOptions = privateData.options.parseOptions;\n    if (this._cookieJar === undefined) {\n      this._cookieJar = new CookieJar(null, { looseMode: true });\n    }\n\n    this._contentType = privateData.options.contentType;\n    this._encoding = privateData.options.encoding;\n\n    const urlOption = privateData.options.url === undefined ? \"about:blank\" : privateData.options.url;\n    const parsed = whatwgURL.parseURL(urlOption);\n    if (parsed === \"failure\") {\n      throw new TypeError(`Could not parse \"${urlOption}\" as a URL`);\n    }\n\n    this._URL = parsed;\n    this._origin = whatwgURL.serializeURLToUnicodeOrigin(parsed);\n\n    this._location = Location.createImpl([], { relevantDocument: this });\n    this._history = History.createImpl([], {\n      window: this._defaultView,\n      document: this,\n      actAsIfLocationReloadCalled: () => this._location.reload()\n    });\n\n    if (privateData.options.cookie) {\n      const cookies = Array.isArray(privateData.options.cookie) ?\n        privateData.options.cookie : [privateData.options.cookie];\n      const document = this;\n\n      cookies.forEach(cookieStr => {\n        document._cookieJar.setCookieSync(cookieStr, document.URL, { ignoreError: true });\n      });\n    }\n\n    this._activeNodeIterators = [];\n    this._activeNodeIteratorsMax = privateData.options.concurrentNodeIterators === undefined ?\n                                  10 :\n                                  Number(privateData.options.concurrentNodeIterators);\n\n    if (isNaN(this._activeNodeIteratorsMax)) {\n      throw new TypeError(\"The 'concurrentNodeIterators' option must be a Number\");\n    }\n\n    if (this._activeNodeIteratorsMax < 0) {\n      throw new RangeError(\"The 'concurrentNodeIterators' option must be a non negative Number\");\n    }\n\n    this._referrer = privateData.options.referrer || \"\";\n    this._lastModified = toLastModifiedString(privateData.options.lastModified || new Date());\n    this._queue = new ResourceQueue(privateData.options.deferClose);\n    this._customResourceLoader = privateData.options.resourceLoader;\n    this._pool = privateData.options.pool;\n    this._agentOptions = privateData.options.agentOptions;\n    this._strictSSL = privateData.options.strictSSL;\n    this._proxy = privateData.options.proxy;\n    this._requestManager = new RequestManager();\n    this.readyState = \"loading\";\n\n    this._lastFocusedElement = null;\n\n    // Add level2 features\n    this.implementation._addFeature(\"core\", \"2.0\");\n    this.implementation._addFeature(\"html\", \"2.0\");\n    this.implementation._addFeature(\"xhtml\", \"2.0\");\n    this.implementation._addFeature(\"xml\", \"2.0\");\n  }\n\n  _defaultElementBuilder(document, tagName) {\n    if (nonInheritedTags.has(tagName.toLowerCase())) {\n      return HTMLElement.create([], {\n        core: this._core,\n        ownerDocument: this,\n        localName: tagName\n      });\n    }\n    return HTMLUnknownElement.create([], {\n      core: this._core,\n      ownerDocument: this,\n      localName: tagName\n    });\n  }\n\n  get contentType() {\n    return this._contentType || (this._parsingMode === \"xml\" ? \"application/xml\" : \"text/html\");\n  }\n  get compatMode() {\n    return this._parsingMode === \"xml\" || this.doctype ? \"CSS1Compat\" : \"BackCompat\";\n  }\n  get charset() {\n    return this._encoding;\n  }\n  get characterSet() {\n    return this._encoding;\n  }\n  get inputEncoding() {\n    return this._encoding;\n  }\n  get doctype() {\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        return childNode;\n      }\n    }\n    return null;\n  }\n  get URL() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n  get documentURI() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n  get origin() {\n    return this._origin;\n  }\n  get location() {\n    return this._defaultView ? this._location : null;\n  }\n  get documentElement() {\n    if (this._documentElement) {\n      return this._documentElement;\n    }\n\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        this._documentElement = childNode;\n        return childNode;\n      }\n    }\n\n    return null;\n  }\n\n  get implementation() {\n    return this._implementation;\n  }\n  set implementation(implementation) {\n    this._implementation = implementation;\n  }\n\n  get defaultView() {\n    return this._defaultView;\n  }\n\n  get currentScript() {\n    return this._currentScript;\n  }\n\n  get activeElement() {\n    if (this._lastFocusedElement) {\n      return this._lastFocusedElement;\n    }\n\n    return this.body;\n  }\n\n  hasFocus() {\n    return Boolean(this._lastFocusedElement);\n  }\n\n  toString() {\n    return \"[object HTMLDocument]\";\n  }\n\n  _createElementWithCorrectElementInterface(name, namespace) {\n    // https://dom.spec.whatwg.org/#concept-element-interface\n    // TODO: eventually we should re-write the element-builder system to be namespace aware, but for now it is not.\n    const builder = this._elementBuilders[name.toLowerCase()] || this._defaultElementBuilder.bind(this);\n    const elem = builder(this, name, namespace);\n    return idlUtils.implForWrapper(elem);\n  }\n\n  appendChild(/* Node */ arg) {\n    if (this.documentElement && arg.nodeType === NODE_TYPE.ELEMENT_NODE) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR);\n    }\n    return super.appendChild(arg);\n  }\n\n  removeChild(/* Node */ arg) {\n    const ret = super.removeChild(arg);\n    if (arg === this._documentElement) {\n      this._documentElement = null;// force a recalculation\n    }\n    return ret;\n  }\n\n  _descendantRemoved(parent, child) {\n    if (child.tagName === \"STYLE\") {\n      const index = this.styleSheets.indexOf(child.sheet);\n      if (index > -1) {\n        this.styleSheets.splice(index, 1);\n      }\n    }\n  }\n\n  write() {\n    let text = \"\";\n    for (let i = 0; i < arguments.length; ++i) {\n      text += String(arguments[i]);\n    }\n\n    if (this._parsingMode === \"xml\") {\n      throw new DOMException(DOMException.INVALID_STATE_ERR, \"Cannot use document.write on XML documents\");\n    }\n\n    if (this._writeAfterElement) {\n      // If called from an script element directly (during the first tick),\n      // the new elements are inserted right after that element.\n      const tempDiv = this.createElement(\"div\");\n      setInnerHTML(this, tempDiv, text);\n\n      let child = tempDiv.firstChild;\n      let previous = this._writeAfterElement;\n      const parent = this._writeAfterElement.parentNode;\n\n      while (child) {\n        const node = child;\n        child = child.nextSibling;\n        parent.insertBefore(node, previous.nextSibling);\n        previous = node;\n      }\n    } else if (this.readyState === \"loading\") {\n      // During page loading, document.write appends to the current element\n      // Find the last child that has been added to the document.\n      let node = this;\n      while (node.lastChild && node.lastChild.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        node = node.lastChild;\n      }\n      setInnerHTML(this, node, text);\n    } else if (text) {\n      setInnerHTML(this, this, text);\n    }\n  }\n\n  writeln() {\n    this.write(...arguments, \"\\n\");\n  }\n\n  getElementById(id) {\n    // return the first element\n    return this._ids[id] && this._ids[id].length > 0 ? this._ids[id][0] : null;\n  }\n\n  get referrer() {\n    return this._referrer || \"\";\n  }\n  get lastModified() {\n    return this._lastModified;\n  }\n  get images() {\n    return this.getElementsByTagName(\"IMG\");\n  }\n  get embeds() {\n    return this.getElementsByTagName(\"EMBED\");\n  }\n  get plugins() {\n    return this.embeds;\n  }\n  get links() {\n    return createHTMLCollection(this, () => domSymbolTree.treeToArray(this, { filter(node) {\n      return (node._localName === \"a\" || node._localName === \"area\") &&\n             node.hasAttribute(\"href\") &&\n             node._namespaceURI === \"http://www.w3.org/1999/xhtml\";\n    } }));\n  }\n  get forms() {\n    return this.getElementsByTagName(\"FORM\");\n  }\n  get scripts() {\n    return this.getElementsByTagName(\"SCRIPT\");\n  }\n  get anchors() {\n    return createHTMLCollection(this, () => domSymbolTree.treeToArray(this, { filter(node) {\n      return node._localName === \"a\" &&\n             node.hasAttribute(\"name\") &&\n             node._namespaceURI === \"http://www.w3.org/1999/xhtml\";\n    } }));\n  }\n  get applets() {\n    return this.getElementsByTagName(\"APPLET\");\n  }\n  open() {\n    let child = domSymbolTree.firstChild(this);\n    while (child) {\n      this.removeChild(child);\n      child = domSymbolTree.firstChild(this);\n    }\n    this._documentElement = null;\n    this._modified();\n    return this;\n  }\n  close() {\n    this._queue.resume();\n\n    // Set the readyState to 'complete' once all resources are loaded.\n    // As a side-effect the document's load-event will be dispatched.\n    resourceLoader.enqueue(this, null, function () {\n      this.readyState = \"complete\";\n      const ev = this.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"DOMContentLoaded\", false, false);\n      this.dispatchEvent(ev);\n    })(null, true);\n  }\n\n  getElementsByName(elementName) {\n    // TODO: should be NodeList, should be memoized\n    return createHTMLCollection(this, () => domSymbolTree.treeToArray(this, { filter(node) {\n      return node.getAttribute && node.getAttribute(\"name\") === elementName;\n    } }));\n  }\n\n  get title() {\n    // TODO SVG\n\n    const titleElement = firstDescendantWithHTMLLocalName(this, \"title\");\n    let value = titleElement !== null ? titleElement.textContent : \"\";\n    value = stripAndCollapseASCIIWhitespace(value);\n    return value;\n  }\n\n  set title(val) {\n    // TODO SVG\n\n    const titleElement = firstDescendantWithHTMLLocalName(this, \"title\");\n    const headElement = this.head;\n\n    if (titleElement === null && headElement === null) {\n      return;\n    }\n\n    let element;\n    if (titleElement !== null) {\n      element = titleElement;\n    } else {\n      element = this.createElement(\"title\");\n      headElement.appendChild(element);\n    }\n\n    element.textContent = val;\n  }\n\n  get dir() {\n    return this.documentElement ? this.documentElement.dir : \"\";\n  }\n  set dir(value) {\n    if (this.documentElement) {\n      this.documentElement.dir = value;\n    }\n  }\n\n  get head() {\n    return this.documentElement ? firstChildWithHTMLLocalName(this.documentElement, \"head\") : null;\n  }\n\n  get body() {\n    const documentElement = this.documentElement;\n    if (!documentElement || documentElement._localName !== \"html\" ||\n        documentElement._namespaceURI !== \"http://www.w3.org/1999/xhtml\") {\n      return null;\n    }\n\n    return firstChildWithHTMLLocalNames(this.documentElement, new Set([\"body\", \"frameset\"]));\n  }\n\n  set body(value) {\n    if (!HTMLElement.isImpl(value)) {\n      throw new TypeError(\"Argument must be a HTMLElement\");\n    }\n    if (value._namespaceURI !== \"http://www.w3.org/1999/xhtml\" ||\n        (value._localName !== \"body\" && value._localName !== \"frameset\")) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, \"Cannot set the body to a non-body/frameset element\");\n    }\n\n    const bodyElement = this.body;\n    if (value === bodyElement) {\n      return;\n    }\n\n    if (bodyElement !== null) {\n      bodyElement.parentNode.replaceChild(value, bodyElement);\n      return;\n    }\n\n    const documentElement = this.documentElement;\n    if (documentElement === null) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,\n        \"Cannot set the body when there is no document element\");\n    }\n\n    documentElement.appendChild(value);\n  }\n\n  _runRemovingSteps(oldNode, oldParent, oldPreviousSibling) {\n    const listeners = DocumentImpl._removingSteps;\n    for (let i = 0; i < listeners.length; ++i) {\n      listeners[i](this, oldNode, oldParent, oldPreviousSibling);\n    }\n  }\n\n  createEvent(type) {\n    const typeLower = type.toLowerCase();\n    const eventWrapper = eventInterfaceTable[typeLower] || null;\n\n    if (!eventWrapper) {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR,\n        \"The provided event type (\\\"\" + type + \"\\\") is invalid\");\n    }\n\n    const impl = eventWrapper.createImpl([\"\"]);\n    impl._initializedFlag = false;\n    return impl;\n  }\n\n  createProcessingInstruction(target, data) {\n    validateName(target);\n\n    if (data.includes(\"?>\")) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n        \"Processing instruction data cannot contain the string \\\"?>\\\"\");\n    }\n\n    return ProcessingInstruction.createImpl([], {\n      core: this._core,\n      ownerDocument: this,\n      target,\n      data\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-createcdatasection\n  createCDATASection(data) {\n    if (this._parsingMode === \"html\") {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR,\n        \"Cannot create CDATA sections in HTML documents\");\n    }\n\n    if (data.includes(\"]]>\")) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n        \"CDATA section data cannot contain the string \\\"]]>\\\"\");\n    }\n\n    return CDATASection.createImpl([], {\n      core: this._core,\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createTextNode(data) {\n    return Text.createImpl([], {\n      core: this._core,\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createComment(data) {\n    return Comment.createImpl([], {\n      core: this._core,\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createElement(localName) {\n    validateName(localName);\n    if (this._parsingMode === \"html\") {\n      localName = localName.toLowerCase();\n    }\n\n    const element = this._createElementWithCorrectElementInterface(localName, \"http://www.w3.org/1999/xhtml\");\n    element._namespaceURI = \"http://www.w3.org/1999/xhtml\";\n    element._localName = localName;\n\n    return element;\n  }\n\n  createElementNS(namespace, qualifiedName) {\n    namespace = namespace !== null ? String(namespace) : namespace;\n\n    const extracted = validateAndExtract(namespace, qualifiedName);\n\n    const element = this._createElementWithCorrectElementInterface(extracted.localName, extracted.namespace);\n    element._namespaceURI = extracted.namespace;\n    element._prefix = extracted.prefix;\n    element._localName = extracted.localName;\n\n    return element;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], { ownerDocument: this });\n  }\n\n  createAttribute(localName) {\n    validateName(localName);\n\n    if (this._parsingMode === \"html\") {\n      localName = localName.toLowerCase();\n    }\n\n    return generatedAttr.createImpl([], { localName });\n  }\n\n  createAttributeNS(namespace, name) {\n    if (namespace === undefined) {\n      namespace = null;\n    }\n    namespace = namespace !== null ? String(namespace) : namespace;\n\n    const extracted = validateAndExtract(namespace, name);\n    return generatedAttr.createImpl([], {\n      namespace: extracted.namespace,\n      namespacePrefix: extracted.prefix,\n      localName: extracted.localName\n    });\n  }\n\n  // TODO: Add callback interface support to `webidl2js`\n  createTreeWalker(root, whatToShow, filter) {\n    if (!isNodeImpl(root)) {\n      throw new TypeError(\"First argument to createTreeWalker must be a Node\");\n    }\n\n    return TreeWalker.createImpl([], {\n      root,\n      whatToShow,\n      filter\n    });\n  }\n\n  importNode(node, deep) {\n    if (!isNodeImpl(node)) {\n      throw new TypeError(\"First argument to importNode must be a Node\");\n    }\n    deep = Boolean(deep);\n\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR, \"Cannot import a document node\");\n    }\n\n    return clone(this._core, node, this, deep);\n  }\n\n  adoptNode(node) {\n    if (!isNodeImpl(node)) {\n      throw new TypeError(\"First argument to adoptNode must be a Node\");\n    }\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(DOMException.NOT_SUPPORTED_ERR, \"Cannot adopt a document node\");\n    }\n    // TODO: Determine correct way to detect a shadow root\n    // See also https://github.com/w3c/webcomponents/issues/182\n\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n    node._ownerDocument = this;\n    for (const descendant of domSymbolTree.treeIterator(node)) {\n      descendant._ownerDocument = this;\n    }\n\n    return node;\n  }\n\n  get cookie() {\n    return this._cookieJar.getCookieStringSync(this.URL, { http: false });\n  }\n  set cookie(cookieStr) {\n    cookieStr = String(cookieStr);\n    this._cookieJar.setCookieSync(cookieStr, this.URL, {\n      http: false,\n      ignoreError: true\n    });\n  }\n\n  get styleSheets() {\n    if (!this._styleSheets) {\n      this._styleSheets = new this._core.StyleSheetList();\n    }\n\n    // TODO: each style and link element should register its sheet on creation\n    // and remove it on removal.\n    return this._styleSheets;\n  }\n\n  get hidden() {\n    return true;\n  }\n\n  get visibilityState() {\n    return \"prerender\";\n  }\n}\n\nidlUtils.mixin(DocumentImpl.prototype, ParentNodeImpl.prototype);\n\nDocumentImpl._removingSteps = [];\n\nDocumentImpl.prototype._elementBuilders = Object.create(null);\n\nDocumentImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\n\nDocumentImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\n\nDocumentImpl.prototype.getElementsByClassName = memoizeQuery(function getElementsByClassName(classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nmodule.exports = {\n  implementation: DocumentImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/nodes/Node-impl.js":"\"use strict\";\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\n\nconst domSymbolTree = require(\"../helpers/internal-constants\").domSymbolTree;\nconst simultaneousIterators = require(\"../../utils\").simultaneousIterators;\nconst DOMException = require(\"../../web-idl/DOMException\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst createLiveNodeList = require(\"../node-list\").createLive;\nconst updateNodeList = require(\"../node-list\").update;\nconst updateHTMLCollection = require(\"../html-collection\").update;\nconst documentBaseURLSerialized = require(\"../helpers/document-base-url\").documentBaseURLSerialized;\nconst cloneNode = require(\"../node\").clone;\nconst attributes = require(\"../attributes\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE ||\n    node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE ||\n    node.nodeType === NODE_TYPE.NOTATION_NODE ||\n//  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n    node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId ||\n          a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n          a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super();\n\n    domSymbolTree.initialize(this);\n\n    this._core = privateData.core;\n    this._ownerDocument = privateData.ownerDocument;\n\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n  }\n\n  get nodeValue() {\n    if (this.nodeType === NODE_TYPE.TEXT_NODE ||\n      this.nodeType === NODE_TYPE.COMMENT_NODE ||\n      this.nodeType === NODE_TYPE.CDATA_SECTION_NODE ||\n      this.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE) {\n      return this._data;\n    }\n\n    return null;\n  }\n\n  set nodeValue(value) {\n    if (this.nodeType === NODE_TYPE.TEXT_NODE ||\n      this.nodeType === NODE_TYPE.COMMENT_NODE ||\n      this.nodeType === NODE_TYPE.CDATA_SECTION_NODE ||\n      this.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE) {\n      this.replaceData(0, this.length, value);\n    }\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = createLiveNodeList(this, () => domSymbolTree.childrenToArray(this));\n    } else {\n      updateNodeList(this._childNodesList);\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  insertBefore(newChildImpl, refChildImpl) {\n    // TODO branding\n    if (!newChildImpl || !(newChildImpl instanceof NodeImpl)) {\n      throw new TypeError(\"First argument to Node.prototype.insertBefore must be a Node\");\n    }\n    if (refChildImpl !== null && !(refChildImpl instanceof NodeImpl)) {\n      throw new TypeError(\"Second argument to Node.prototype.insertBefore must be a Node or null or undefined\");\n    }\n\n    // DocumentType must be implicitly adopted\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      newChildImpl._ownerDocument = this._ownerDocument;\n    }\n\n    if (newChildImpl.nodeType && newChildImpl.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR);\n    }\n\n    if (this._ownerDocument !== newChildImpl._ownerDocument) {\n      // adopt the node when it's not in this document\n      this._ownerDocument.adoptNode(newChildImpl);\n    } else {\n      // search for parents matching the newChild\n      for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n        if (ancestor === newChildImpl) {\n          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR);\n        }\n      }\n    }\n\n    // fragments are merged into the element (except parser-created fragments in <template>)\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while ((grandChildImpl = domSymbolTree.firstChild(newChildImpl))) {\n        newChildImpl.removeChild(grandChildImpl);\n        this.insertBefore(grandChildImpl, refChildImpl);\n      }\n    } else if (newChildImpl === refChildImpl) {\n      return newChildImpl;\n    } else {\n      const oldParentImpl = domSymbolTree.parent(newChildImpl);\n      // if the newChild is already in the tree elsewhere, remove it first\n      if (oldParentImpl) {\n        oldParentImpl.removeChild(newChildImpl);\n      }\n\n      if (refChildImpl === null) {\n        domSymbolTree.appendChild(this, newChildImpl);\n      } else {\n        if (domSymbolTree.parent(refChildImpl) !== this) {\n          throw new DOMException(DOMException.NOT_FOUND_ERR);\n        }\n\n        domSymbolTree.insertBefore(refChildImpl, newChildImpl);\n      }\n\n      this._modified();\n\n      if (this._attached && newChildImpl._attach) {\n        newChildImpl._attach();\n      }\n\n      this._descendantAdded(this, newChildImpl);\n    }\n\n    return newChildImpl;\n  } // raises(DOMException);\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      updateHTMLCollection(this._childrenList);\n    }\n    if (this._childNodesList) {\n      updateNodeList(this._childNodesList);\n    }\n    this._clearMemoizedQueries();\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  replaceChild(node, child) {\n    if (arguments.length < 2) {\n      throw new TypeError(\"Not enough arguments to Node.prototype.replaceChild\");\n    }\n    // TODO branding\n    if (!node || !(node instanceof NodeImpl)) {\n      throw new TypeError(\"First argument to Node.prototype.replaceChild must be a Node\");\n    }\n    if (!child || !(child instanceof NodeImpl)) {\n      throw new TypeError(\"Second argument to Node.prototype.replaceChild must be a Node\");\n    }\n\n    this.insertBefore(node, child);\n    return this.removeChild(child);\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  removeChild(/* Node */ oldChildImpl) {\n    if (!oldChildImpl || domSymbolTree.parent(oldChildImpl) !== this) {\n      throw new DOMException(DOMException.NOT_FOUND_ERR);\n    }\n\n    const oldPreviousSibling = oldChildImpl.previousSibling;\n    domSymbolTree.remove(oldChildImpl);\n    this._modified();\n    oldChildImpl._detach();\n    this._descendantRemoved(this, oldChildImpl);\n    if (this._ownerDocument) {\n      this._ownerDocument._runRemovingSteps(oldChildImpl, this, oldPreviousSibling);\n    }\n    return oldChildImpl;\n  } // raises(DOMException);\n\n  appendChild(newChild) {\n    if (!(\"nodeType\" in newChild)) {\n      throw new TypeError(\"First argument to Node.prototype.appendChild must be a Node\");\n    }\n\n    return this.insertBefore(newChild, null);\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  normalize() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        continue;\n      }\n\n      const prevChild = domSymbolTree.previousSibling(child);\n\n      if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE && child.nodeType === NODE_TYPE.TEXT_NODE) {\n        // merge text nodes\n        prevChild.appendData(child.nodeValue);\n        this.removeChild(child);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(otherImpl) {\n    // Let reference be the context object.\n    const reference = this;\n\n    if (!(otherImpl instanceof NodeImpl)) {\n      throw new Error(\"Comparing position against non-Node values is not allowed\");\n    }\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    const result = domSymbolTree.compareTreePosition(reference, otherImpl);\n\n    // If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  contains(other) {\n    if (!(other instanceof NodeImpl)) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  cloneNode(deep) {\n    deep = Boolean(deep);\n\n    return cloneNode(this._core, this, undefined, deep);\n  }\n\n  get textContent() {\n    let text;\n    switch (this.nodeType) {\n      case NODE_TYPE.COMMENT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE:\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.TEXT_NODE:\n        return this.nodeValue;\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        text = \"\";\n        for (const child of domSymbolTree.treeIterator(this)) {\n          if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            text += child.nodeValue;\n          }\n        }\n        return text;\n\n      default:\n        return null;\n    }\n  }\n\n  set textContent(txt) {\n    switch (this.nodeType) {\n      case NODE_TYPE.COMMENT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE:\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.TEXT_NODE:\n        this.nodeValue = String(txt);\n        return;\n    }\n\n    let child = domSymbolTree.firstChild(this);\n    while (child) {\n      this.removeChild(child);\n      child = domSymbolTree.firstChild(this);\n    }\n\n    if (txt !== \"\" && txt !== null) {\n      this.appendChild(this._ownerDocument.createTextNode(txt));\n    }\n  }\n\n  toString() {\n    const wrapper = idlUtils.wrapperForImpl(this);\n    return `[object ${wrapper.constructor.name}]`;\n  }\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/node.js":"\"use strict\";\nconst attributes = require(\"./attributes\");\nconst cloningSteps = require(\"./helpers/internal-constants\").cloningSteps;\nconst domSymbolTree = require(\"./helpers/internal-constants\").domSymbolTree;\nconst NODE_TYPE = require(\"./node-type\");\nconst orderedSetParser = require(\"./helpers/ordered-set-parser\");\nconst createHTMLCollection = require(\"./html-collection\").create;\nconst domTokenListContains = require(\"./dom-token-list\").contains;\n\nmodule.exports.clone = function (core, node, document, cloneChildren) {\n  if (document === undefined) {\n    document = node._ownerDocument;\n  }\n\n  let copy;\n  switch (node.nodeType) {\n    case NODE_TYPE.DOCUMENT_NODE:\n      // TODO: just use Document when we eliminate the difference between Document and HTMLDocument.\n      if (node.contentType === \"text/html\") { // need to differentiate due to parsing mode\n        copy = document.implementation.createHTMLDocument();\n        copy.removeChild(copy.documentElement); // ;_;\n      } else {\n        copy = document.implementation.createDocument(\"\", \"\", null);\n      }\n      document = copy;\n      break;\n\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      copy = document.implementation.createDocumentType(node.name, node.publicId, node.systemId);\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      copy = document._createElementWithCorrectElementInterface(node._localName, node._namespaceURI);\n      copy._namespaceURI = node._namespaceURI;\n      copy._prefix = node._prefix;\n      copy._localName = node._localName;\n      attributes.copyAttributeList(node, copy);\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n      copy = document.createTextNode(node._data);\n      break;\n\n    case NODE_TYPE.CDATA_SECTION_NODE:\n      copy = document.createCDATASection(node._data);\n      break;\n\n    case NODE_TYPE.COMMENT_NODE:\n      copy = document.createComment(node._data);\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      copy = document.createProcessingInstruction(node.target, node._data);\n      break;\n\n    case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      copy = document.createDocumentFragment();\n      break;\n  }\n\n  if (node[cloningSteps]) {\n    node[cloningSteps](copy, node, document, cloneChildren);\n  }\n\n  if (cloneChildren) {\n    for (const child of domSymbolTree.childrenIterator(node)) {\n      const childCopy = module.exports.clone(core, child, document, true);\n      copy.appendChild(childCopy);\n    }\n  }\n\n  return copy;\n};\n\n// For the following, memoization is not applied here since the memoized results are stored on `this`.\n\nmodule.exports.listOfElementsWithClassNames = (classNames, root) => {\n  // https://dom.spec.whatwg.org/#concept-getElementsByClassName\n\n  const classes = orderedSetParser(classNames);\n\n  if (classes.size === 0) {\n    return createHTMLCollection(root, () => []);\n  }\n\n  return createHTMLCollection(root, () => {\n    const isQuirksMode = root._ownerDocument.compatMode === \"BackCompat\";\n\n    return domSymbolTree.treeToArray(root, { filter(node) {\n      if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n        return false;\n      }\n\n      for (const className of classes) {\n        if (!domTokenListContains(node.classList, className, { caseInsensitive: isQuirksMode })) {\n          return false;\n        }\n      }\n\n      return true;\n    } });\n  });\n};\n\nmodule.exports.listOfElementsWithQualifiedName = (qualifiedName, root) => {\n  // https://dom.spec.whatwg.org/#concept-getelementsbytagname\n\n  if (qualifiedName === \"*\") {\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        return node.nodeType === NODE_TYPE.ELEMENT_NODE && node !== root;\n      } });\n    });\n  }\n\n  if (root._ownerDocument._parsingMode === \"html\") {\n    const lowerQualifiedName = qualifiedName.toLowerCase();\n\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        if (node._namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n          return node._qualifiedName === lowerQualifiedName;\n        }\n\n        return node._qualifiedName === qualifiedName;\n      } });\n    });\n  }\n\n  return createHTMLCollection(root, () => {\n    return domSymbolTree.treeToArray(root, { filter(node) {\n      if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n        return false;\n      }\n\n      return node._qualifiedName === qualifiedName;\n    } });\n  });\n};\n\nmodule.exports.listOfElementsWithNamespaceAndLocalName = (namespace, localName, root) => {\n  // https://dom.spec.whatwg.org/#concept-getelementsbytagnamens\n\n  if (namespace === \"\") {\n    namespace = null;\n  }\n\n  if (namespace === \"*\" && localName === \"*\") {\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        return node.nodeType === NODE_TYPE.ELEMENT_NODE && node !== root;\n      } });\n    });\n  }\n\n  if (namespace === \"*\") {\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        return node._localName === localName;\n      } });\n    });\n  }\n\n  if (localName === \"*\") {\n    return createHTMLCollection(root, () => {\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        return node._namespaceURI === namespace;\n      } });\n    });\n  }\n\n  return createHTMLCollection(root, () => {\n    return domSymbolTree.treeToArray(root, { filter(node) {\n      if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n        return false;\n      }\n\n      return node._localName === localName && node._namespaceURI === namespace;\n    } });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/node-list.js":"\"use strict\";\nconst lengthFromProperties = require(\"../utils\").lengthFromProperties;\nconst idlUtils = require(\"./generated/utils\");\n\nconst privates = Symbol(\"NodeList internal slots\");\n\nclass NodeList {\n  constructor(secret, config) {\n    if (secret !== privates) {\n      throw new TypeError(\"Invalid constructor\");\n    }\n\n    if (config.nodes) {\n      this[privates] = {\n        isLive: false,\n        length: config.nodes.length\n      };\n\n      for (let i = 0; i < config.nodes.length; ++i) {\n        this[i] = config.nodes[i];\n      }\n    } else {\n      this[privates] = {\n        isLive: true,\n        element: config.element,\n        query: config.query,\n        snapshot: undefined,\n        length: 0,\n        version: -1\n      };\n      updateNodeList(this);\n    }\n  }\n\n  get length() {\n    updateNodeList(this);\n    return this[privates].length;\n  }\n\n  item(index) {\n    updateNodeList(this);\n    return this[index] || null;\n  }\n\n  // TODO reimplement this in webidl2js so these become more per-spec\n  * keys() {\n    updateNodeList(this);\n    const length = this[privates].length;\n    for (let i = 0; i < length; ++i) {\n      yield i;\n    }\n  }\n\n  * entries() {\n    updateNodeList(this);\n    const length = this[privates].length;\n    for (let i = 0; i < length; ++i) {\n      yield [i, this[i]];\n    }\n  }\n\n  forEach(callback, thisArg = undefined) {\n    let values = Array.from(this);\n    let i = 0;\n    while (i < values.length) {\n      callback.call(thisArg, values[i], i, this);\n      values = Array.from(this);\n      ++i;\n    }\n  }\n}\n\nNodeList.prototype[Symbol.iterator] = NodeList.prototype.values = Array.prototype[Symbol.iterator];\n\nfunction updateNodeList(nodeList) {\n  if (nodeList[privates].isLive) {\n    if (nodeList[privates].version < nodeList[privates].element._version) {\n      nodeList[privates].snapshot = nodeList[privates].query();\n      resetNodeListTo(nodeList, nodeList[privates].snapshot);\n      nodeList[privates].version = nodeList[privates].element._version;\n    }\n  } else {\n    nodeList[privates].length = lengthFromProperties(nodeList);\n  }\n}\n\nfunction resetNodeListTo(nodeList, nodes) {\n  const startingLength = lengthFromProperties(nodeList);\n  for (let i = 0; i < startingLength; ++i) {\n    delete nodeList[i];\n  }\n\n  for (let i = 0; i < nodes.length; ++i) {\n    const wrapper = idlUtils.wrapperForImpl(nodes[i]);\n    nodeList[i] = wrapper ? wrapper : nodes[i];\n  }\n  nodeList[privates].length = nodes.length;\n}\n\nmodule.exports = function (core) {\n  core.NodeList = NodeList;\n};\n\nmodule.exports.createLive = function (element, query) {\n  return new NodeList(privates, { element, query });\n};\n\nmodule.exports.createStatic = function (nodes) {\n  return new NodeList(privates, { nodes });\n};\n\nmodule.exports.update = updateNodeList;\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/post-message.js":"\"use strict\";\nconst isValidTargetOrigin = require(\"../utils\").isValidTargetOrigin;\nconst DOMException = require(\"../web-idl/DOMException\");\n\nmodule.exports = function (message, targetOrigin) {\n  if (arguments.length < 2) {\n    throw new TypeError(\"'postMessage' requires 2 arguments: 'message' and 'targetOrigin'\");\n  }\n\n  targetOrigin = String(targetOrigin);\n\n  if (!isValidTargetOrigin(targetOrigin)) {\n    throw new DOMException(DOMException.SYNTAX_ERR, \"Failed to execute 'postMessage' on 'Window': \" +\n      \"Invalid target origin '\" + targetOrigin + \"' in a call to 'postMessage'.\");\n  }\n\n  // TODO: targetOrigin === '/' - requires reference to source window\n  // See https://github.com/tmpvar/jsdom/pull/1140#issuecomment-111587499\n  if (targetOrigin !== \"*\" && targetOrigin !== this.location.origin) {\n    return;\n  }\n\n  // TODO: event.source - requires reference to source window\n  // TODO: event.origin - requires reference to source window\n  // TODO: event.ports\n  // TODO: event.data - structured clone message - requires cloning DOM nodes\n  const event = new this.MessageEvent(\"message\", {\n    data: message\n  });\n\n  event.initEvent(\"message\", false, false);\n\n  setTimeout(() => {\n    this.dispatchEvent(event);\n  }, 0);\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/register-elements.js":"\"use strict\";\n/* eslint global-require: 0 */\n\nconst DocumentImpl = require(\"./nodes/Document-impl.js\");\n\nconst mappings = {\n  HTMLElement: {\n    file: require(\"./generated/HTMLElement.js\"),\n    tags: []\n  },\n  HTMLAnchorElement: {\n    file: require(\"./generated/HTMLAnchorElement.js\"),\n    tags: [\"a\"]\n  },\n  HTMLAppletElement: {\n    file: require(\"./generated/HTMLAppletElement.js\"),\n    tags: [\"applet\"]\n  },\n  HTMLAreaElement: {\n    file: require(\"./generated/HTMLAreaElement.js\"),\n    tags: [\"area\"]\n  },\n  HTMLAudioElement: {\n    file: require(\"./generated/HTMLAudioElement.js\"),\n    tags: [\"audio\"]\n  },\n  HTMLBaseElement: {\n    file: require(\"./generated/HTMLBaseElement.js\"),\n    tags: [\"base\"]\n  },\n  HTMLBodyElement: {\n    file: require(\"./generated/HTMLBodyElement.js\"),\n    tags: [\"body\"]\n  },\n  HTMLBRElement: {\n    file: require(\"./generated/HTMLBRElement.js\"),\n    tags: [\"br\"]\n  },\n  HTMLButtonElement: {\n    file: require(\"./generated/HTMLButtonElement.js\"),\n    tags: [\"button\"]\n  },\n  HTMLCanvasElement: {\n    file: require(\"./generated/HTMLCanvasElement.js\"),\n    tags: [\"canvas\"]\n  },\n  HTMLDataElement: {\n    file: require(\"./generated/HTMLDataElement.js\"),\n    tags: [\"data\"]\n  },\n  HTMLDataListElement: {\n    file: require(\"./generated/HTMLDataListElement.js\"),\n    tags: [\"datalist\"]\n  },\n  HTMLDialogElement: {\n    file: require(\"./generated/HTMLDialogElement.js\"),\n    tags: [\"dialog\"]\n  },\n  HTMLDirectoryElement: {\n    file: require(\"./generated/HTMLDirectoryElement.js\"),\n    tags: [\"dir\"]\n  },\n  HTMLDivElement: {\n    file: require(\"./generated/HTMLDivElement.js\"),\n    tags: [\"div\"]\n  },\n  HTMLDListElement: {\n    file: require(\"./generated/HTMLDListElement.js\"),\n    tags: [\"dl\"]\n  },\n  HTMLEmbedElement: {\n    file: require(\"./generated/HTMLEmbedElement.js\"),\n    tags: [\"embed\"]\n  },\n  HTMLFieldSetElement: {\n    file: require(\"./generated/HTMLFieldSetElement.js\"),\n    tags: [\"fieldset\"]\n  },\n  HTMLFontElement: {\n    file: require(\"./generated/HTMLFontElement.js\"),\n    tags: [\"font\"]\n  },\n  HTMLFormElement: {\n    file: require(\"./generated/HTMLFormElement.js\"),\n    tags: [\"form\"]\n  },\n  HTMLFrameElement: {\n    file: require(\"./generated/HTMLFrameElement.js\"),\n    tags: [\"frame\"]\n  },\n  HTMLFrameSetElement: {\n    file: require(\"./generated/HTMLFrameSetElement.js\"),\n    tags: [\"frameset\"]\n  },\n  HTMLHeadingElement: {\n    file: require(\"./generated/HTMLHeadingElement.js\"),\n    tags: [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"]\n  },\n  HTMLHeadElement: {\n    file: require(\"./generated/HTMLHeadElement.js\"),\n    tags: [\"head\"]\n  },\n  HTMLHRElement: {\n    file: require(\"./generated/HTMLHRElement.js\"),\n    tags: [\"hr\"]\n  },\n  HTMLHtmlElement: {\n    file: require(\"./generated/HTMLHtmlElement.js\"),\n    tags: [\"html\"]\n  },\n  HTMLIFrameElement: {\n    file: require(\"./generated/HTMLIFrameElement.js\"),\n    tags: [\"iframe\"]\n  },\n  HTMLImageElement: {\n    file: require(\"./generated/HTMLImageElement.js\"),\n    tags: [\"img\"]\n  },\n  HTMLInputElement: {\n    file: require(\"./generated/HTMLInputElement.js\"),\n    tags: [\"input\"]\n  },\n  HTMLLabelElement: {\n    file: require(\"./generated/HTMLLabelElement.js\"),\n    tags: [\"label\"]\n  },\n  HTMLLegendElement: {\n    file: require(\"./generated/HTMLLegendElement.js\"),\n    tags: [\"legend\"]\n  },\n  HTMLLIElement: {\n    file: require(\"./generated/HTMLLIElement.js\"),\n    tags: [\"li\"]\n  },\n  HTMLLinkElement: {\n    file: require(\"./generated/HTMLLinkElement.js\"),\n    tags: [\"link\"]\n  },\n  HTMLMapElement: {\n    file: require(\"./generated/HTMLMapElement.js\"),\n    tags: [\"map\"]\n  },\n  HTMLMediaElement: {\n    file: require(\"./generated/HTMLMediaElement.js\"),\n    tags: []\n  },\n  HTMLMenuElement: {\n    file: require(\"./generated/HTMLMenuElement.js\"),\n    tags: [\"menu\"]\n  },\n  HTMLMetaElement: {\n    file: require(\"./generated/HTMLMetaElement.js\"),\n    tags: [\"meta\"]\n  },\n  HTMLMeterElement: {\n    file: require(\"./generated/HTMLMeterElement.js\"),\n    tags: [\"meter\"]\n  },\n  HTMLModElement: {\n    file: require(\"./generated/HTMLModElement.js\"),\n    tags: [\"del\", \"ins\"]\n  },\n  HTMLObjectElement: {\n    file: require(\"./generated/HTMLObjectElement.js\"),\n    tags: [\"object\"]\n  },\n  HTMLOListElement: {\n    file: require(\"./generated/HTMLOListElement.js\"),\n    tags: [\"ol\"]\n  },\n  HTMLOptGroupElement: {\n    file: require(\"./generated/HTMLOptGroupElement.js\"),\n    tags: [\"optgroup\"]\n  },\n  HTMLOptionElement: {\n    file: require(\"./generated/HTMLOptionElement.js\"),\n    tags: [\"option\"]\n  },\n  HTMLOutputElement: {\n    file: require(\"./generated/HTMLOutputElement.js\"),\n    tags: [\"output\"]\n  },\n  HTMLParagraphElement: {\n    file: require(\"./generated/HTMLParagraphElement.js\"),\n    tags: [\"p\"]\n  },\n  HTMLParamElement: {\n    file: require(\"./generated/HTMLParamElement.js\"),\n    tags: [\"param\"]\n  },\n  HTMLPreElement: {\n    file: require(\"./generated/HTMLPreElement.js\"),\n    tags: [\"pre\"]\n  },\n  HTMLProgressElement: {\n    file: require(\"./generated/HTMLProgressElement.js\"),\n    tags: [\"progress\"]\n  },\n  HTMLQuoteElement: {\n    file: require(\"./generated/HTMLQuoteElement.js\"),\n    tags: [\"blockquote\", \"q\"]\n  },\n  HTMLScriptElement: {\n    file: require(\"./generated/HTMLScriptElement.js\"),\n    tags: [\"script\"]\n  },\n  HTMLSelectElement: {\n    file: require(\"./generated/HTMLSelectElement.js\"),\n    tags: [\"select\"]\n  },\n  HTMLSourceElement: {\n    file: require(\"./generated/HTMLSourceElement.js\"),\n    tags: [\"source\"]\n  },\n  HTMLSpanElement: {\n    file: require(\"./generated/HTMLSpanElement.js\"),\n    tags: [\"span\"]\n  },\n  HTMLStyleElement: {\n    file: require(\"./generated/HTMLStyleElement.js\"),\n    tags: [\"style\"]\n  },\n  HTMLTableCaptionElement: {\n    file: require(\"./generated/HTMLTableCaptionElement.js\"),\n    tags: [\"caption\"]\n  },\n  HTMLTableCellElement: {\n    file: require(\"./generated/HTMLTableCellElement.js\"),\n    tags: []\n  },\n  HTMLTableColElement: {\n    file: require(\"./generated/HTMLTableColElement.js\"),\n    tags: [\"col\", \"colgroup\"]\n  },\n  HTMLTableDataCellElement: {\n    file: require(\"./generated/HTMLTableDataCellElement.js\"),\n    tags: [\"td\"]\n  },\n  HTMLTableElement: {\n    file: require(\"./generated/HTMLTableElement.js\"),\n    tags: [\"table\"]\n  },\n  HTMLTableHeaderCellElement: {\n    file: require(\"./generated/HTMLTableHeaderCellElement.js\"),\n    tags: [\"th\"]\n  },\n  HTMLTimeElement: {\n    file: require(\"./generated/HTMLTimeElement.js\"),\n    tags: [\"time\"]\n  },\n  HTMLTitleElement: {\n    file: require(\"./generated/HTMLTitleElement.js\"),\n    tags: [\"title\"]\n  },\n  HTMLTableRowElement: {\n    file: require(\"./generated/HTMLTableRowElement.js\"),\n    tags: [\"tr\"]\n  },\n  HTMLTableSectionElement: {\n    file: require(\"./generated/HTMLTableSectionElement.js\"),\n    tags: [\"thead\", \"tbody\", \"tfoot\"]\n  },\n  HTMLTemplateElement: {\n    file: require(\"./generated/HTMLTemplateElement.js\"),\n    tags: [\"template\"]\n  },\n  HTMLTextAreaElement: {\n    file: require(\"./generated/HTMLTextAreaElement.js\"),\n    tags: [\"textarea\"]\n  },\n  HTMLTrackElement: {\n    file: require(\"./generated/HTMLTrackElement.js\"),\n    tags: [\"track\"]\n  },\n  HTMLUListElement: {\n    file: require(\"./generated/HTMLUListElement.js\"),\n    tags: [\"ul\"]\n  },\n  HTMLUnknownElement: {\n    file: require(\"./generated/HTMLUnknownElement.js\"),\n    tags: []\n  },\n  HTMLVideoElement: {\n    file: require(\"./generated/HTMLVideoElement.js\"),\n    tags: [\"video\"]\n  }\n};\n\nmodule.exports = core => {\n  for (const interfaceName of Object.keys(mappings)) {\n    const file = mappings[interfaceName].file;\n    const tags = mappings[interfaceName].tags;\n\n    core[interfaceName] = file.interface;\n\n    for (const tagName of tags) {\n      DocumentImpl.implementation.prototype._elementBuilders[tagName] = (document, elName) => {\n        return file.create([], {\n          core,\n          ownerDocument: document,\n          localName: elName || tagName.toUpperCase()\n        });\n      };\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/xhr-sync-worker.js":"\"use strict\";\n/* eslint-disable no-process-exit */\nconst util = require(\"util\");\nconst { JSDOM } = require(\"../../..\");\nconst tough = require(\"tough-cookie\");\nconst xhrSymbols = require(\"./xmlhttprequest-symbols.js\");\n\nconst dom = new JSDOM();\nconst xhr = new dom.window.XMLHttpRequest();\n\nconst chunks = [];\n\nprocess.stdin.on(\"data\", chunk => {\n  chunks.push(chunk);\n});\n\nprocess.stdin.on(\"end\", () => {\n  const buffer = Buffer.concat(chunks);\n  const flag = JSON.parse(buffer.toString(), (k, v) => {\n    if (v && v.type === \"Buffer\" && v.data) {\n      return new Buffer(v.data);\n    }\n    if (k === \"cookieJar\" && v) {\n      return tough.CookieJar.fromJSON(v);\n    }\n    return v;\n  });\n  flag.synchronous = false;\n  xhr[xhrSymbols.flag] = flag;\n  const properties = xhr[xhrSymbols.properties];\n  properties.readyState = xhr.OPENED;\n  try {\n    xhr.addEventListener(\"loadend\", () => {\n      if (properties.error) {\n        properties.error = properties.error.stack || util.inspect(properties.error);\n      }\n      process.stdout.write(JSON.stringify({ properties }), () => {\n        process.exit(0);\n      });\n    }, false);\n    xhr.send(flag.body);\n  } catch (error) {\n    properties.error += error.stack || util.inspect(error);\n    process.stdout.write(JSON.stringify({ properties }), () => {\n      process.exit(0);\n    });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/xhr-utils.js":"\"use strict\";\n\nconst request = require(\"request\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst fs = require(\"fs\");\nconst URL = require(\"whatwg-url\").URL;\n\nconst utils = require(\"../utils\");\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nfunction wrapCookieJarForRequest(cookieJar) {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n}\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction mergeHeaders(lhs, rhs) {\n  const rhsParts = rhs.split(\",\");\n  const lhsParts = lhs.split(\",\");\n  return rhsParts.concat(lhsParts.filter(p => rhsParts.indexOf(p) < 0)).join(\",\");\n}\n\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\n  \"access-control-expose-headers\",\n  \"access-control-allow-headers\",\n  \"access-control-allow-credentials\",\n  \"access-control-allow-origin\"\n]);\n\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\n\n// return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\nexports.createClient = function createClient(xhr) {\n  const flag = xhr[xhrSymbols.flag];\n  const properties = xhr[xhrSymbols.properties];\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n\n  const requestManager = flag.requestManager;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = { uri: urlObj };\n    const filePath = urlObj.pathname\n      .replace(/^file:\\/\\//, \"\")\n      .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n      .replace(/%20/g, \" \");\n\n    const client = new EventEmitter();\n\n    const readableStream = fs.createReadStream(filePath, { encoding: null });\n\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n\n    readableStream.on(\"error\", err => {\n      response.emit(\"error\", err);\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response));\n\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n\n    response.request = { uri: urlObj };\n\n    const client = new EventEmitter();\n\n    let buffer;\n    if (ucMethod === \"GET\") {\n      try {\n        const dataUrlContent = utils.parseDataUrl(uri);\n        buffer = dataUrlContent.buffer;\n        response.statusCode = 200;\n        response.rawHeaders = dataUrlContent.type ? [\"Content-Type\", dataUrlContent.type] : [];\n        response.headers = dataUrlContent.type ? { \"content-type\": dataUrlContent.type } : {};\n      } catch (err) {\n        process.nextTick(() => client.emit(\"error\", err));\n        return client;\n      }\n    } else {\n      buffer = new Buffer(\"\");\n      response.statusCode = 0;\n      response.rawHeaders = {};\n      response.headers = {};\n    }\n\n    client.abort = () => {\n      // do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n\n    return client;\n  }\n\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    pool: flag.pool,\n    agentOptions: flag.agentOptions,\n    strictSSL: flag.strictSSL\n  };\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  if (flag.proxy) {\n    options.proxy = flag.proxy;\n  }\n\n  const body = flag.body;\n  const hasBody = body !== undefined &&\n    body !== null &&\n    body !== \"\" &&\n    !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      const client = request(options);\n\n      if (hasBody && flag.formData) {\n        const form = client.form();\n        for (const entry of body) {\n          form.append(entry.name, entry.value, entry.options);\n        }\n      }\n\n      return client;\n    } catch (e) {\n      const client = new EventEmitter();\n      process.nextTick(() => client.emit(\"error\", e));\n      return client;\n    }\n  }\n\n  let client;\n\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders)\n    .filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0)) {\n    client = new EventEmitter();\n\n    const preflightRequestHeaders = [];\n    for (const header in requestHeaders) {\n      preflightRequestHeaders[header] = requestHeaders[header];\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    flag.preflight = true;\n\n    const preflightOptions = {\n      uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      agentOptions: flag.agentOptions,\n      strictSSL: flag.strictSSL\n    };\n\n    if (flag.proxy) {\n      preflightOptions.proxy = flag.proxy;\n    }\n\n    const preflightClient = request(preflightOptions);\n\n    preflightClient.on(\"response\", resp => {\n      if (resp.statusCode >= 200 && resp.statusCode <= 299) {\n        const realClient = doRequest();\n        realClient.on(\"response\", res => {\n          for (const header in resp.headers) {\n            if (preflightHeaders.has(header)) {\n              res.headers[header] = res.headers.hasOwnProperty(header) ?\n                mergeHeaders(res.headers[header], resp.headers[header]) : resp.headers[header];\n            }\n          }\n          client.emit(\"response\", res);\n        });\n        realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n        realClient.on(\"end\", () => client.emit(\"end\"));\n        realClient.on(\"abort\", () => client.emit(\"abort\"));\n        realClient.on(\"request\", req => {\n          client.headers = realClient.headers;\n          client.emit(\"request\", req);\n        });\n        realClient.on(\"redirect\", () => {\n          client.response = realClient.response;\n          client.emit(\"redirect\");\n        });\n        realClient.on(\"error\", err => client.emit(\"error\", err));\n        client.abort = () => {\n          realClient.abort();\n        };\n      } else {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n      }\n    });\n\n    preflightClient.on(\"error\", err => client.emit(\"error\", err));\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n};\n\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/xmlhttprequest-event-target.js":"\"use strict\";\n\nconst EventTarget = require(\"./generated/EventTarget\");\n\nfunction XMLHttpRequestEventTarget() {\n  if (!(this instanceof XMLHttpRequestEventTarget)) {\n    throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n  }\n  EventTarget.setup(this);\n  this.onabort = null;\n  this.onerror = null;\n  this.onload = null;\n  this.onloadend = null;\n  this.onloadstart = null;\n  this.onprogress = null;\n  this.ontimeout = null;\n}\n\nXMLHttpRequestEventTarget.prototype = Object.create(EventTarget.interface.prototype);\n\nmodule.exports = function (core) {\n  core.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/xmlhttprequest.js":"\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\nconst spawnSync = require(\"child_process\").spawnSync;\nconst URL = require(\"whatwg-url\").URL;\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst tough = require(\"tough-cookie\");\nconst parseContentType = require(\"content-type-parser\");\n\nconst xhrUtils = require(\"./xhr-utils\");\nconst DOMException = require(\"../web-idl/DOMException\");\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\nconst addConstants = require(\"../utils\").addConstants;\nconst documentBaseURLSerialized = require(\"./helpers/document-base-url\").documentBaseURLSerialized;\nconst idlUtils = require(\"./generated/utils\");\nconst Document = require(\"./generated/Document\");\nconst Blob = require(\"./generated/Blob\");\nconst domToHtml = require(\"../browser/domtohtml\").domToHtml;\n\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\n\nconst forbiddenRequestHeaders = new Set([\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"access-control-request-headers\",\n  \"access-control-request-method\",\n  \"connection\",\n  \"content-length\",\n  \"cookie\",\n  \"cookie2\",\n  \"date\",\n  \"dnt\",\n  \"expect\",\n  \"host\",\n  \"keep-alive\",\n  \"origin\",\n  \"referer\",\n  \"te\",\n  \"trailer\",\n  \"transfer-encoding\",\n  \"upgrade\",\n  \"via\"\n]);\nconst forbiddenResponseHeaders = new Set([\n  \"set-cookie\",\n  \"set-cookie2\"\n]);\nconst uniqueResponseHeaders = new Set([\n  \"content-type\",\n  \"content-length\",\n  \"user-agent\",\n  \"referer\",\n  \"host\",\n  \"authorization\",\n  \"proxy-authorization\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"from\",\n  \"location\",\n  \"max-forwards\"\n]);\nconst corsSafeResponseHeaders = new Set([\n  \"cache-control\",\n  \"content-language\",\n  \"content-type\",\n  \"expires\",\n  \"last-modified\",\n  \"pragma\"\n]);\n\n\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nconst XMLHttpRequestResponseType = new Set([\n  \"\",\n  \"arraybuffer\",\n  \"blob\",\n  \"document\",\n  \"json\",\n  \"text\"\n]);\n\nconst simpleHeaders = xhrUtils.simpleHeaders;\n\nconst redirectStatuses = new Set([301, 302, 303, 307, 308]);\n\nmodule.exports = function createXMLHttpRequest(window) {\n  const Event = window.Event;\n  const ProgressEvent = window.ProgressEvent;\n  const FormData = window.FormData;\n  const XMLHttpRequestEventTarget = window.XMLHttpRequestEventTarget;\n  const XMLHttpRequestUpload = window.XMLHttpRequestUpload;\n\n  class XMLHttpRequest extends XMLHttpRequestEventTarget {\n    constructor() {\n      super();\n      if (!(this instanceof XMLHttpRequest)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      this.upload = new XMLHttpRequestUpload();\n      this.upload._ownerDocument = window.document;\n\n      this[xhrSymbols.flag] = {\n        synchronous: false,\n        withCredentials: false,\n        mimeType: null,\n        auth: null,\n        method: undefined,\n        responseType: \"\",\n        requestHeaders: {},\n        referrer: this._ownerDocument.URL,\n        uri: \"\",\n        timeout: 0,\n        body: undefined,\n        formData: false,\n        preflight: false,\n        requestManager: this._ownerDocument._requestManager,\n        pool: this._ownerDocument._pool,\n        agentOptions: this._ownerDocument._agentOptions,\n        strictSSL: this._ownerDocument._strictSSL,\n        proxy: this._ownerDocument._proxy,\n        cookieJar: this._ownerDocument._cookieJar,\n        encoding: this._ownerDocument._encoding,\n        origin: this._ownerDocument.origin,\n        userAgent: this._ownerDocument._defaultView.navigator.userAgent\n      };\n\n      this[xhrSymbols.properties] = {\n        beforeSend: false,\n        send: false,\n        timeoutStart: 0,\n        timeoutId: 0,\n        timeoutFn: null,\n        client: null,\n        responseHeaders: {},\n        filteredResponseHeaders: [],\n        responseBuffer: null,\n        responseCache: null,\n        responseTextCache: null,\n        responseXMLCache: null,\n        responseURL: \"\",\n        readyState: XMLHttpRequest.UNSENT,\n        status: 0,\n        statusText: \"\",\n        error: \"\",\n        uploadComplete: true,\n        abortError: false,\n        cookieJar: this._ownerDocument._cookieJar\n      };\n      this.onreadystatechange = null;\n    }\n    get readyState() {\n      return this[xhrSymbols.properties].readyState;\n    }\n    get status() {\n      return this[xhrSymbols.properties].status;\n    }\n    get statusText() {\n      return this[xhrSymbols.properties].statusText;\n    }\n    get responseType() {\n      return this[xhrSymbols.flag].responseType;\n    }\n    set responseType(responseType) {\n      const flag = this[xhrSymbols.flag];\n      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (this.readyState === XMLHttpRequest.OPENED && flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n      if (!XMLHttpRequestResponseType.has(responseType)) {\n        responseType = \"\";\n      }\n      flag.responseType = responseType;\n    }\n    get response() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (properties.responseCache) {\n        return properties.responseCache;\n      }\n      let res = \"\";\n      switch (this.responseType) {\n        case \"\":\n        case \"text\": {\n          res = this.responseText;\n          break;\n        }\n        case \"arraybuffer\": {\n          if (!properties.responseBuffer) {\n            return null;\n          }\n          res = (new Uint8Array(properties.responseBuffer)).buffer;\n          break;\n        }\n        case \"blob\": {\n          if (!properties.responseBuffer) {\n            return null;\n          }\n          const contentType = getContentType(this);\n          res = Blob.create([[new Uint8Array(properties.responseBuffer)], {\n            type: contentType && contentType.toString() || \"\"\n          }]);\n          break;\n        }\n        case \"document\": {\n          res = this.responseXML;\n          break;\n        }\n        case \"json\": {\n          if (this.readyState !== XMLHttpRequest.DONE || !properties.responseBuffer) {\n            res = null;\n          }\n\n          const contentType = getContentType(this);\n          const fallbackEncoding = whatwgEncoding.labelToName(\n            contentType && contentType.get(\"charset\") || flag.encoding);\n          const jsonStr = whatwgEncoding.decode(properties.responseBuffer, fallbackEncoding);\n\n          try {\n            res = JSON.parse(jsonStr);\n          } catch (e) {\n            res = null;\n          }\n          break;\n        }\n      }\n      properties.responseCache = res;\n      return res;\n    }\n    get responseText() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (this.responseType !== \"\" && this.responseType !== \"text\") {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (this.readyState !== XMLHttpRequest.LOADING && this.readyState !== XMLHttpRequest.DONE) {\n        return \"\";\n      }\n      if (properties.responseTextCache) {\n        return properties.responseTextCache;\n      }\n      const responseBuffer = properties.responseBuffer;\n      if (!responseBuffer) {\n        return \"\";\n      }\n\n      const contentType = getContentType(this);\n      const fallbackEncoding = whatwgEncoding.labelToName(contentType && contentType.get(\"charset\") || flag.encoding);\n      const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n\n      properties.responseTextCache = res;\n      return res;\n    }\n    get responseXML() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (this.responseType !== \"\" && this.responseType !== \"document\") {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (this.readyState !== XMLHttpRequest.DONE) {\n        return null;\n      }\n      if (properties.responseXMLCache) {\n        return properties.responseXMLCache;\n      }\n      const responseBuffer = properties.responseBuffer;\n      if (!responseBuffer) {\n        return null;\n      }\n      const contentType = getContentType(this);\n      let isHTML = false;\n      let isXML = false;\n      if (contentType) {\n        isHTML = contentType.isHTML();\n        isXML = contentType.isXML();\n        if (!isXML && !isHTML) {\n          return null;\n        }\n      }\n\n      const encoding = whatwgEncoding.getBOMEncoding(responseBuffer) ||\n                       whatwgEncoding.labelToName(contentType && contentType.get(\"charset\") || flag.encoding);\n      const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n      if (!resText) {\n        return null;\n      }\n      if (this.responseType === \"\" && isHTML) {\n        return null;\n      }\n      const res = Document.create([], { core: window._core, options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: { setCookieSync: () => undefined, getCookieStringSync: () => \"\" },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      } });\n      const resImpl = idlUtils.implForWrapper(res);\n      try {\n        resImpl._htmlToDom.appendHtmlToDocument(resText, resImpl);\n      } catch (e) {\n        properties.responseXMLCache = null;\n        return null;\n      }\n      res.close();\n      properties.responseXMLCache = res;\n      return res;\n    }\n\n    get responseURL() {\n      return this[xhrSymbols.properties].responseURL;\n    }\n\n    get timeout() {\n      return this[xhrSymbols.flag].timeout;\n    }\n    set timeout(val) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n      flag.timeout = val;\n      clearTimeout(properties.timeoutId);\n      if (val > 0 && properties.timeoutFn) {\n        properties.timeoutId = setTimeout(\n          properties.timeoutFn,\n          Math.max(0, val - ((new Date()).getTime() - properties.timeoutStart))\n        );\n      } else {\n        properties.timeoutFn = null;\n        properties.timeoutStart = 0;\n      }\n    }\n    get withCredentials() {\n      return this[xhrSymbols.flag].withCredentials;\n    }\n    set withCredentials(val) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED)) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      flag.withCredentials = val;\n    }\n\n    abort() {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      // Terminate the request\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n\n      const client = properties.client;\n      if (client) {\n        client.abort();\n        properties.client = null;\n      }\n\n      if ((this.readyState === XMLHttpRequest.OPENED && properties.send) ||\n          this.readyState === XMLHttpRequest.HEADERS_RECEIVED ||\n          this.readyState === XMLHttpRequest.LOADING) {\n        // Run the request error steps for event abort\n        properties.readyState = XMLHttpRequest.DONE;\n        properties.send = false;\n\n        properties.status = 0;\n        properties.statusText = \"\";\n        properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n\n        if (flag.synchronous) {\n          throw new DOMException(DOMException.ABORT_ERR);\n        }\n\n        this.dispatchEvent(new Event(\"readystatechange\"));\n\n        // TODO: spec says this should only be checking upload complete flag?\n        if (!(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          properties.uploadComplete = true;\n\n          // TODO upload listener\n\n          this.upload.dispatchEvent(new ProgressEvent(\"abort\"));\n          if (properties.abortError) {\n            // TODO document what this is about (here and below)\n            this.upload.dispatchEvent(new ProgressEvent(\"error\"));\n          }\n          this.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n        }\n\n        this.dispatchEvent(new ProgressEvent(\"abort\"));\n        if (properties.abortError) {\n          this.dispatchEvent(new ProgressEvent(\"error\"));\n        }\n        this.dispatchEvent(new ProgressEvent(\"loadend\"));\n      }\n\n      if (this.readyState === XMLHttpRequest.DONE) {\n        properties.readyState = XMLHttpRequest.UNSENT;\n\n        properties.status = 0;\n        properties.statusText = \"\";\n        properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n      }\n    }\n    getAllResponseHeaders() {\n      const properties = this[xhrSymbols.properties];\n      const readyState = this.readyState;\n      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n        return \"\";\n      }\n      return Object.keys(properties.responseHeaders)\n        .filter(key => properties.filteredResponseHeaders.indexOf(key) === -1)\n        .map(key => [key, properties.responseHeaders[key]].join(\": \")).join(\"\\r\\n\");\n    }\n\n    getResponseHeader(header) {\n      const properties = this[xhrSymbols.properties];\n      const readyState = this.readyState;\n      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n        return null;\n      }\n      const lcHeader = toByteString(header).toLowerCase();\n      if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n        return null;\n      }\n      return getResponseHeader(this, lcHeader);\n    }\n\n    open(method, uri, asynchronous, user, password) {\n      if (!this._ownerDocument) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n      const argumentCount = arguments.length;\n      if (argumentCount < 2) {\n        throw new TypeError(\"Not enough arguments (expected at least 2)\");\n      }\n      method = toByteString(method);\n      if (!tokenRegexp.test(method)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n      const upperCaseMethod = method.toUpperCase();\n      if (forbiddenRequestMethods.has(upperCaseMethod)) {\n        throw new DOMException(DOMException.SECURITY_ERR);\n      }\n\n      const client = properties.client;\n      if (client && typeof client.abort === \"function\") {\n        client.abort();\n      }\n\n      if (allowedRequestMethods.has(upperCaseMethod)) {\n        method = upperCaseMethod;\n      }\n      if (typeof asynchronous !== \"undefined\") {\n        flag.synchronous = !asynchronous;\n      } else {\n        flag.synchronous = false;\n      }\n      if (flag.responseType && flag.synchronous) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n      if (flag.synchronous && flag.timeout) {\n        throw new DOMException(DOMException.INVALID_ACCESS_ERR);\n      }\n      flag.method = method;\n\n      let urlObj;\n      try {\n        urlObj = new URL(uri, documentBaseURLSerialized(this._ownerDocument));\n      } catch (e) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      if (user || (password && !urlObj.username)) {\n        flag.auth = {\n          user,\n          pass: password\n        };\n        urlObj.username = \"\";\n        urlObj.password = \"\";\n      }\n\n      flag.uri = urlObj.href;\n      flag.requestHeaders = {};\n      flag.preflight = false;\n\n      properties.send = false;\n      properties.requestBuffer = null;\n      properties.requestCache = null;\n      properties.abortError = false;\n      properties.responseURL = \"\";\n      readyStateChange(this, XMLHttpRequest.OPENED);\n    }\n\n    overrideMimeType(mime) {\n      const readyState = this.readyState;\n      if (readyState === XMLHttpRequest.LOADING || readyState === XMLHttpRequest.DONE) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      if (!mime) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n      mime = String(mime);\n      if (!parseContentType(mime)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n      this[xhrSymbols.flag].mimeType = mime;\n    }\n\n    send(body) {\n      if (!this._ownerDocument) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      properties.beforeSend = true;\n\n      try {\n        if (!flag.body &&\n            body !== undefined &&\n            body !== null &&\n            body !== \"\" &&\n            !(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          let contentType = null;\n          let encoding = null;\n          if (body instanceof FormData) {\n            flag.formData = true;\n            const formData = [];\n            for (const entry of idlUtils.implForWrapper(body)._entries) {\n              let val;\n              if (Blob.isImpl(entry.value)) {\n                const blob = entry.value;\n                val = {\n                  name: entry.name,\n                  value: blob._buffer,\n                  options: {\n                    filename: blob.name,\n                    contentType: blob.type,\n                    knownLength: blob.size\n                  }\n                };\n              } else {\n                val = entry;\n              }\n              formData.push(val);\n            }\n            flag.body = formData;\n            // TODO content type; what is the form boundary?\n          } else if (Blob.is(body)) {\n            const blob = idlUtils.implForWrapper(body);\n            flag.body = blob._buffer;\n            if (blob.type !== \"\") {\n              contentType = blob.type;\n            }\n          } else if (body instanceof ArrayBuffer) {\n            flag.body = new Buffer(new Uint8Array(body));\n          } else if (body instanceof Document.interface) {\n            if (body.childNodes.length === 0) {\n              throw new DOMException(DOMException.INVALID_STATE_ERR);\n            }\n            flag.body = domToHtml([body]);\n\n            encoding = \"UTF-8\";\n\n            const documentBodyParsingMode = idlUtils.implForWrapper(body)._parsingMode;\n            contentType = documentBodyParsingMode === \"html\" ? \"text/html\" : \"application/xml\";\n            contentType += \";charset=UTF-8\";\n          } else if (typeof body !== \"string\") {\n            flag.body = String(body);\n          } else {\n            flag.body = body;\n            contentType = \"text/plain;charset=UTF-8\";\n            encoding = \"UTF-8\";\n          }\n\n          const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n          if (contentType !== null && existingContentType === null) {\n            flag.requestHeaders[\"Content-Type\"] = contentType;\n          } else if (existingContentType !== null && encoding !== null) {\n            const parsed = parseContentType(existingContentType);\n            if (parsed) {\n              parsed.parameterList\n                .filter(v => v.key && v.key.toLowerCase() === \"charset\" &&\n                        whatwgEncoding.labelToName(v.value) !== \"UTF-8\")\n                .forEach(v => {\n                  v.value = \"UTF-8\";\n                });\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      } finally {\n        if (properties.beforeSend) {\n          properties.beforeSend = false;\n        } else {\n          throw new DOMException(DOMException.INVALID_STATE_ERR);\n        }\n      }\n\n      if (flag.synchronous) {\n        const flagStr = JSON.stringify(flag, function (k, v) {\n          if (this === flag && k === \"requestManager\") {\n            return null;\n          }\n          if (this === flag && k === \"pool\" && v) {\n            return { maxSockets: v.maxSockets };\n          }\n          return v;\n        });\n        const res = spawnSync(\n          process.execPath,\n          [syncWorkerFile],\n          { input: flagStr }\n        );\n        if (res.status !== 0) {\n          throw new Error(res.stderr.toString());\n        }\n        if (res.error) {\n          if (typeof res.error === \"string\") {\n            res.error = new Error(res.error);\n          }\n          throw res.error;\n        }\n        const response = JSON.parse(res.stdout.toString(), (k, v) => {\n          if (k === \"responseBuffer\" && v && v.data) {\n            return new Buffer(v.data);\n          }\n          if (k === \"cookieJar\" && v) {\n            return tough.CookieJar.deserializeSync(v, this._ownerDocument._cookieJar.store);\n          }\n          return v;\n        });\n        response.properties.readyState = XMLHttpRequest.LOADING;\n        this[xhrSymbols.properties] = response.properties;\n\n        if (response.properties.error) {\n          dispatchError(this);\n          throw new DOMException(DOMException.NETWORK_ERR, response.properties.error);\n        } else {\n          const responseBuffer = this[xhrSymbols.properties].responseBuffer;\n          const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n          const bufferLength = parseInt(contentLength) || responseBuffer.length;\n          const progressObj = { lengthComputable: false };\n          if (bufferLength !== 0) {\n            progressObj.total = bufferLength;\n            progressObj.loaded = bufferLength;\n            progressObj.lengthComputable = true;\n          }\n          this.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n          readyStateChange(this, XMLHttpRequest.DONE);\n          this.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n          this.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n        }\n      } else {\n        properties.send = true;\n\n        this.dispatchEvent(new ProgressEvent(\"loadstart\"));\n\n        const client = xhrUtils.createClient(this);\n\n        properties.client = client;\n\n        properties.origin = flag.origin;\n\n        client.on(\"error\", err => {\n          client.removeAllListeners();\n          properties.error = err;\n          dispatchError(this);\n        });\n\n        client.on(\"response\", res => receiveResponse(this, res));\n\n        client.on(\"redirect\", () => {\n          if (flag.preflight) {\n            properties.error = \"Redirect after preflight forbidden\";\n            dispatchError(this);\n            client.abort();\n            return;\n          }\n\n          const response = client.response;\n          const destUrlObj = new URL(response.request.headers.Referer);\n\n          const urlObj = new URL(response.request.uri.href);\n\n          if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n            properties.origin = \"null\";\n          }\n\n          response.request.headers.Origin = properties.origin;\n\n          if (flag.origin !== destUrlObj.origin &&\n              destUrlObj.protocol !== \"data:\") {\n            if (!validCORSHeaders(this, response, flag, properties, flag.origin)) {\n              return;\n            }\n            if (urlObj.username || urlObj.password || response.request.uri.href.match(/^https?:\\/\\/:@/)) {\n              properties.error = \"Userinfo forbidden in cors redirect\";\n              dispatchError(this);\n              return;\n            }\n          }\n        });\n        if (body !== undefined &&\n          body !== null &&\n          body !== \"\" &&\n          !(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n          properties.uploadComplete = false;\n          setDispatchProgressEvents(this);\n        } else {\n          properties.uploadComplete = true;\n        }\n        if (this.timeout > 0) {\n          properties.timeoutStart = (new Date()).getTime();\n          properties.timeoutFn = () => {\n            client.abort();\n            if (!(this.readyState === XMLHttpRequest.UNSENT ||\n                (this.readyState === XMLHttpRequest.OPENED && !properties.send) ||\n                this.readyState === XMLHttpRequest.DONE)) {\n              properties.send = false;\n              let stateChanged = false;\n              if (!(flag.method === \"HEAD\" || flag.method === \"GET\")) {\n                this.upload.dispatchEvent(new ProgressEvent(\"progress\"));\n                readyStateChange(this, XMLHttpRequest.DONE);\n                this.upload.dispatchEvent(new ProgressEvent(\"timeout\"));\n                this.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n                stateChanged = true;\n              }\n              this.dispatchEvent(new ProgressEvent(\"progress\"));\n              if (!stateChanged) {\n                readyStateChange(this, XMLHttpRequest.DONE);\n              }\n              this.dispatchEvent(new ProgressEvent(\"timeout\"));\n              this.dispatchEvent(new ProgressEvent(\"loadend\"));\n            }\n            properties.readyState = XMLHttpRequest.UNSENT;\n          };\n          properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n        }\n      }\n      flag.body = undefined;\n      flag.formData = false;\n    }\n\n    setRequestHeader(header, value) {\n      const flag = this[xhrSymbols.flag];\n      const properties = this[xhrSymbols.properties];\n\n      if (arguments.length !== 2) {\n        throw new TypeError(\"2 arguments required for setRequestHeader\");\n      }\n      header = toByteString(header);\n      value = toByteString(value);\n\n      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n        throw new DOMException(DOMException.INVALID_STATE_ERR);\n      }\n\n      value = normalizeHeaderValue(value);\n\n      if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n        throw new DOMException(DOMException.SYNTAX_ERR);\n      }\n\n      const lcHeader = header.toLowerCase();\n\n      if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n        return;\n      }\n\n      const keys = Object.keys(flag.requestHeaders);\n      let n = keys.length;\n      while (n--) {\n        const key = keys[n];\n        if (key.toLowerCase() === lcHeader) {\n          flag.requestHeaders[key] += \",\" + value;\n          return;\n        }\n      }\n      flag.requestHeaders[lcHeader] = value;\n    }\n\n    toString() {\n      return \"[object XMLHttpRequest]\";\n    }\n\n    get _ownerDocument() {\n      return idlUtils.implForWrapper(window.document);\n    }\n  }\n\n  addConstants(XMLHttpRequest, {\n    UNSENT: 0,\n    OPENED: 1,\n    HEADERS_RECEIVED: 2,\n    LOADING: 3,\n    DONE: 4\n  });\n\n  function readyStateChange(xhr, readyState) {\n    const properties = xhr[xhrSymbols.properties];\n    if (properties.readyState === readyState) {\n      return;\n    }\n\n    properties.readyState = readyState;\n\n    const readyStateChangeEvent = new Event(\"readystatechange\");\n    xhr.dispatchEvent(readyStateChangeEvent);\n  }\n\n  function receiveResponse(xhr, response) {\n    const properties = xhr[xhrSymbols.properties];\n    const flag = xhr[xhrSymbols.flag];\n\n    const statusCode = response.statusCode;\n\n    if (flag.preflight && redirectStatuses.has(statusCode)) {\n      properties.error = \"Redirect after preflight forbidden\";\n      dispatchError(this);\n      return;\n    }\n\n    let byteOffset = 0;\n\n    const headers = {};\n    const filteredResponseHeaders = [];\n    const headerMap = {};\n    const rawHeaders = response.rawHeaders;\n    const n = Number(rawHeaders.length);\n    for (let i = 0; i < n; i += 2) {\n      const k = rawHeaders[i];\n      const kl = k.toLowerCase();\n      const v = rawHeaders[i + 1];\n      if (uniqueResponseHeaders.has(kl)) {\n        if (headerMap[kl] !== undefined) {\n          delete headers[headerMap[kl]];\n        }\n        headers[k] = v;\n      } else if (headerMap[kl] !== undefined) {\n        headers[headerMap[kl]] += \", \" + v;\n      } else {\n        headers[k] = v;\n      }\n      headerMap[kl] = k;\n    }\n\n    const destUrlObj = new URL(response.request.uri.href);\n    if (properties.origin !== destUrlObj.origin &&\n        destUrlObj.protocol !== \"data:\") {\n      if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n        return;\n      }\n      const acehStr = response.headers[\"access-control-expose-headers\"];\n      const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n      for (const header in headers) {\n        const lcHeader = header.toLowerCase();\n        if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n          filteredResponseHeaders.push(header);\n        }\n      }\n    }\n\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n      if (forbiddenResponseHeaders.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n\n    properties.responseURL = destUrlObj.href;\n\n    properties.status = statusCode;\n    properties.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n\n    properties.responseHeaders = headers;\n    properties.filteredResponseHeaders = filteredResponseHeaders;\n\n    const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n    const bufferLength = parseInt(contentLength) || 0;\n    const progressObj = { lengthComputable: false };\n    let lastProgressReported;\n    if (bufferLength !== 0) {\n      progressObj.total = bufferLength;\n      progressObj.loaded = 0;\n      progressObj.lengthComputable = true;\n    }\n    properties.responseBuffer = new Buffer(0);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n    readyStateChange(xhr, XMLHttpRequest.HEADERS_RECEIVED);\n\n    // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n    // Content-Length).\n    response.on(\"data\", chunk => {\n      byteOffset += chunk.length;\n      progressObj.loaded = byteOffset;\n    });\n\n    properties.client.on(\"data\", chunk => {\n      properties.responseBuffer = Buffer.concat([properties.responseBuffer, chunk]);\n      properties.responseCache = null;\n      properties.responseTextCache = null;\n      properties.responseXMLCache = null;\n\n      if (properties.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n        properties.readyState = XMLHttpRequest.LOADING;\n      }\n      xhr.dispatchEvent(new Event(\"readystatechange\"));\n\n      if (progressObj.total !== progressObj.loaded || properties.responseBuffer.length === byteOffset) {\n        if (lastProgressReported !== progressObj.loaded) {\n          // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n          // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n          lastProgressReported = progressObj.loaded;\n          xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n        }\n      }\n    });\n    properties.client.on(\"end\", () => {\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n      properties.client = null;\n      xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n      readyStateChange(xhr, XMLHttpRequest.DONE);\n      xhr.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n      xhr.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n    });\n  }\n\n  function setDispatchProgressEvents(xhr) {\n    const properties = xhr[xhrSymbols.properties];\n    const client = properties.client;\n    const upload = xhr.upload;\n\n    let total = 0;\n    let lengthComputable = false;\n    const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n    if (length) {\n      total = length;\n      lengthComputable = true;\n    }\n    const initProgress = {\n      lengthComputable,\n      total,\n      loaded: 0\n    };\n    upload.dispatchEvent(new ProgressEvent(\"loadstart\", initProgress));\n\n    client.on(\"request\", req => {\n      req.on(\"response\", () => {\n        properties.uploadComplete = true;\n        const progress = {\n          lengthComputable,\n          total,\n          loaded: total\n        };\n        upload.dispatchEvent(new ProgressEvent(\"progress\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"load\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"loadend\", progress));\n      });\n    });\n  }\n\n  function dispatchError(xhr) {\n    const properties = xhr[xhrSymbols.properties];\n    readyStateChange(xhr, XMLHttpRequest.DONE);\n    if (!properties.uploadComplete) {\n      xhr.upload.dispatchEvent(new ProgressEvent(\"error\"));\n      xhr.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n    }\n    xhr.dispatchEvent(new ProgressEvent(\"error\"));\n    xhr.dispatchEvent(new ProgressEvent(\"loadend\"));\n    if (xhr._ownerDocument) {\n      const error = new Error(properties.error);\n      error.type = \"XMLHttpRequest\";\n\n      xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n    }\n  }\n\n  function validCORSHeaders(xhr, response, flag, properties, origin) {\n    const acaoStr = response.headers[\"access-control-allow-origin\"];\n    const acao = acaoStr ? acaoStr.trim() : null;\n    if (acao !== \"*\" && acao !== origin) {\n      properties.error = \"Cross origin \" + origin + \" forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n    const acacStr = response.headers[\"access-control-allow-credentials\"];\n    const acac = acacStr ? acacStr.trim() : null;\n    if (flag.withCredentials && acac !== \"true\") {\n      properties.error = \"Credentials forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n    const acahStr = response.headers[\"access-control-allow-headers\"];\n    const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n    const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n      const lcHeader = header.toLowerCase();\n      return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n    });\n    if (forbiddenHeaders.length > 0) {\n      properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n      dispatchError(xhr);\n      return false;\n    }\n    return true;\n  }\n\n  function toByteString(value) {\n    value = String(value);\n    if (!/^[\\0-\\xFF]*$/.test(value)) {\n      throw new TypeError(\"invalid ByteString\");\n    }\n    return value;\n  }\n\n  function getContentType(xhr) {\n    const flag = xhr[xhrSymbols.flag];\n    return parseContentType(flag.mimeType || getResponseHeader(xhr, \"content-type\"));\n  }\n\n  function getResponseHeader(xhr, lcHeader) {\n    const properties = xhr[xhrSymbols.properties];\n    const keys = Object.keys(properties.responseHeaders);\n    let n = keys.length;\n    while (n--) {\n      const key = keys[n];\n      if (key.toLowerCase() === lcHeader) {\n        return properties.responseHeaders[key];\n      }\n    }\n    return null;\n  }\n\n  function normalizeHeaderValue(value) {\n    return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n  }\n\n  return XMLHttpRequest;\n};\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/xmlhttprequest-symbols.js":"\"use strict\";\n\nexports.flag = Symbol(\"flag\");\nexports.properties = Symbol(\"properties\");\n","/home/travis/build/npmtest/node-npmtest-jsdom/node_modules/jsdom/lib/jsdom/living/xmlhttprequest-upload.js":"\"use strict\";\n\nmodule.exports = function (core) {\n  const XMLHttpRequestEventTarget = core.XMLHttpRequestEventTarget;\n\n  class XMLHttpRequestUpload extends XMLHttpRequestEventTarget {\n    constructor() {\n      super();\n      if (!(this instanceof XMLHttpRequestUpload)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n    }\n  }\n\n  core.XMLHttpRequestUpload = XMLHttpRequestUpload;\n};\n\n"}